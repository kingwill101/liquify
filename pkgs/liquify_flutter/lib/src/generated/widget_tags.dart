// GENERATED CODE - DO NOT MODIFY BY HAND.
// Generated by widget_spec_builder.
// ignore_for_file: deprecated_member_use

import 'dart:ui';
import 'package:flutter/foundation.dart';
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/painting.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';
import 'package:liquify/parser.dart';
import 'package:liquify_flutter/src/generated/type_parsers.dart';
import 'package:liquify_flutter/src/tags/tag_helpers.dart';
import 'package:liquify_flutter/src/tags/widget_tag_base.dart';

class GeneratedAboutDialogTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAboutDialogTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAboutDialogTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAboutDialogTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('about_dialog').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endabout_dialog').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'about_dialog',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAboutDialogTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAboutDialogTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'applicationIcon':
          config.applicationIcon = resolveWidget(value);
          break;
        case 'applicationLegalese':
          config.applicationLegalese = toStringValue(value);
          break;
        case 'applicationName':
          config.applicationName = toStringValue(value);
          break;
        case 'applicationVersion':
          config.applicationVersion = toStringValue(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('about_dialog', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedAboutDialogTagConfig {
  Widget? applicationIcon;
  String? applicationLegalese;
  String? applicationName;
  String? applicationVersion;
  Key? key;
}

AboutDialog _buildGeneratedAboutDialogTagWidget(_GeneratedAboutDialogTagConfig config, List<Widget> children) {
  return AboutDialog(
    applicationIcon: config.applicationIcon,
    applicationLegalese: config.applicationLegalese,
    applicationName: config.applicationName,
    applicationVersion: config.applicationVersion,
    key: config.key,
    children: children,
  );
}


class GeneratedAbsorbPointerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAbsorbPointerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAbsorbPointerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAbsorbPointerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('absorb_pointer').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endabsorb_pointer').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'absorb_pointer',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAbsorbPointerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAbsorbPointerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'absorbing':
          config.absorbing = toBool(value);
          break;
        case 'ignoringSemantics':
          config.ignoringSemantics = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('absorb_pointer', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedAbsorbPointerTagConfig {
  bool? absorbing;
  bool? ignoringSemantics;
  Key? key;
}

AbsorbPointer _buildGeneratedAbsorbPointerTagWidget(_GeneratedAbsorbPointerTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AbsorbPointer(
    absorbing: config.absorbing ?? true,
    ignoringSemantics: config.ignoringSemantics,
    key: config.key,
    child: child,
  );
}


class GeneratedActionChipTag extends WidgetTagBase with AsyncTag {
  GeneratedActionChipTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedActionChipTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedActionChipTagWidget(config, children));
  }

  _GeneratedActionChipTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedActionChipTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'avatar':
          config.avatar = resolveWidget(value);
          break;
        case 'avatarBoxConstraints':
          config.avatarBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'chipAnimationStyle':
          config.chipAnimationStyle = parseGeneratedChipAnimationStyle(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'disabledColor':
          config.disabledColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'iconTheme':
          config.iconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'labelPadding':
          config.labelPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'labelStyle':
          config.labelStyle = parseGeneratedTextStyle(value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'pressElevation':
          config.pressElevation = toDouble(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedOutlinedBorder(value);
          break;
        case 'side':
          config.side = parseGeneratedBorderSide(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('action_chip', name);
          break;
      }
    }
    if (config.label == null) {
      throw Exception('action_chip tag requires "label"');
    }
    return config;
  }
}

class _GeneratedActionChipTagConfig {
  bool? autofocus;
  Widget? avatar;
  BoxConstraints? avatarBoxConstraints;
  Color? backgroundColor;
  ChipAnimationStyle? chipAnimationStyle;
  Clip? clipBehavior;
  WidgetStateProperty<Color?>? color;
  Color? disabledColor;
  double? elevation;
  FocusNode? focusNode;
  IconThemeData? iconTheme;
  Key? key;
  Widget? label;
  EdgeInsetsGeometry? labelPadding;
  TextStyle? labelStyle;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  VoidCallback? onPressed;
  EdgeInsetsGeometry? padding;
  double? pressElevation;
  Color? shadowColor;
  OutlinedBorder? shape;
  BorderSide? side;
  Color? surfaceTintColor;
  String? tooltip;
  VisualDensity? visualDensity;
}

ActionChip _buildGeneratedActionChipTagWidget(_GeneratedActionChipTagConfig config, List<Widget> children) {
  return ActionChip(
    autofocus: config.autofocus ?? false,
    avatar: config.avatar,
    avatarBoxConstraints: config.avatarBoxConstraints,
    backgroundColor: config.backgroundColor,
    chipAnimationStyle: config.chipAnimationStyle,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    disabledColor: config.disabledColor,
    elevation: config.elevation,
    focusNode: config.focusNode,
    iconTheme: config.iconTheme,
    key: config.key,
    label: config.label!,
    labelPadding: config.labelPadding,
    labelStyle: config.labelStyle,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onPressed: config.onPressed,
    padding: config.padding,
    pressElevation: config.pressElevation,
    shadowColor: config.shadowColor,
    shape: config.shape,
    side: config.side,
    surfaceTintColor: config.surfaceTintColor,
    tooltip: config.tooltip,
    visualDensity: config.visualDensity,
  );
}


class GeneratedAlertDialogTag extends WidgetTagBase with AsyncTag {
  GeneratedAlertDialogTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedAlertDialogTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedAlertDialogTagWidget(config, children));
  }

  _GeneratedAlertDialogTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAlertDialogTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'actions':
          config.actions = value;
          break;
        case 'actionsAlignment':
          config.actionsAlignment = parseGeneratedMainAxisAlignment(value);
          break;
        case 'actionsOverflowAlignment':
          config.actionsOverflowAlignment = parseGeneratedOverflowBarAlignment(value);
          break;
        case 'actionsOverflowButtonSpacing':
          config.actionsOverflowButtonSpacing = toDouble(value);
          break;
        case 'actionsOverflowDirection':
          config.actionsOverflowDirection = parseGeneratedVerticalDirection(value);
          break;
        case 'actionsPadding':
          config.actionsPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'buttonPadding':
          config.buttonPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'content':
          config.content = resolveWidget(value);
          break;
        case 'contentPadding':
          config.contentPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'contentTextStyle':
          config.contentTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'iconColor':
          config.iconColor = parseGeneratedColor(value);
          break;
        case 'iconPadding':
          config.iconPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'insetPadding':
          config.insetPadding = parseGeneratedEdgeInsets(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'scrollable':
          config.scrollable = toBool(value);
          break;
        case 'semanticLabel':
          config.semanticLabel = toStringValue(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'titlePadding':
          config.titlePadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'titleTextStyle':
          config.titleTextStyle = parseGeneratedTextStyle(value);
          break;
        default:
          handleUnknownArg('alert_dialog', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedAlertDialogTagConfig {
  List<Widget>? actions;
  MainAxisAlignment? actionsAlignment;
  OverflowBarAlignment? actionsOverflowAlignment;
  double? actionsOverflowButtonSpacing;
  VerticalDirection? actionsOverflowDirection;
  EdgeInsetsGeometry? actionsPadding;
  AlignmentGeometry? alignment;
  Color? backgroundColor;
  EdgeInsetsGeometry? buttonPadding;
  Clip? clipBehavior;
  BoxConstraints? constraints;
  Widget? content;
  EdgeInsetsGeometry? contentPadding;
  TextStyle? contentTextStyle;
  double? elevation;
  Widget? icon;
  Color? iconColor;
  EdgeInsetsGeometry? iconPadding;
  EdgeInsets? insetPadding;
  Key? key;
  bool? scrollable;
  String? semanticLabel;
  Color? shadowColor;
  ShapeBorder? shape;
  Color? surfaceTintColor;
  Widget? title;
  EdgeInsetsGeometry? titlePadding;
  TextStyle? titleTextStyle;
}

AlertDialog _buildGeneratedAlertDialogTagWidget(_GeneratedAlertDialogTagConfig config, List<Widget> children) {
  return AlertDialog(
    actions: config.actions,
    actionsAlignment: config.actionsAlignment,
    actionsOverflowAlignment: config.actionsOverflowAlignment,
    actionsOverflowButtonSpacing: config.actionsOverflowButtonSpacing,
    actionsOverflowDirection: config.actionsOverflowDirection,
    actionsPadding: config.actionsPadding,
    alignment: config.alignment,
    backgroundColor: config.backgroundColor,
    buttonPadding: config.buttonPadding,
    clipBehavior: config.clipBehavior,
    constraints: config.constraints,
    content: config.content,
    contentPadding: config.contentPadding,
    contentTextStyle: config.contentTextStyle,
    elevation: config.elevation,
    icon: config.icon,
    iconColor: config.iconColor,
    iconPadding: config.iconPadding,
    insetPadding: config.insetPadding,
    key: config.key,
    scrollable: config.scrollable ?? false,
    semanticLabel: config.semanticLabel,
    shadowColor: config.shadowColor,
    shape: config.shape,
    surfaceTintColor: config.surfaceTintColor,
    title: config.title,
    titlePadding: config.titlePadding,
    titleTextStyle: config.titleTextStyle,
  );
}


class GeneratedAlignTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAlignTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAlignTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAlignTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('align').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endalign').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'align',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAlignTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAlignTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'heightFactor':
          config.heightFactor = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'widthFactor':
          config.widthFactor = toDouble(value);
          break;
        default:
          handleUnknownArg('align', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedAlignTagConfig {
  AlignmentGeometry? alignment;
  double? heightFactor;
  Key? key;
  double? widthFactor;
}

Align _buildGeneratedAlignTagWidget(_GeneratedAlignTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Align(
    alignment: config.alignment ?? Alignment.center,
    heightFactor: config.heightFactor,
    key: config.key,
    widthFactor: config.widthFactor,
    child: child,
  );
}


class GeneratedAnimatedAlignTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedAlignTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedAlignTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedAlignTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_align').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_align').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_align',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedAlignTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedAlignTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'heightFactor':
          config.heightFactor = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'widthFactor':
          config.widthFactor = toDouble(value);
          break;
        default:
          handleUnknownArg('animated_align', name);
          break;
      }
    }
    if (config.alignment == null) {
      throw Exception('animated_align tag requires "alignment"');
    }
    if (config.duration == null) {
      throw Exception('animated_align tag requires "duration"');
    }
    return config;
  }
}

class _GeneratedAnimatedAlignTagConfig {
  AlignmentGeometry? alignment;
  Curve? curve;
  Duration? duration;
  double? heightFactor;
  Key? key;
  VoidCallback? onEnd;
  double? widthFactor;
}

AnimatedAlign _buildGeneratedAnimatedAlignTagWidget(_GeneratedAnimatedAlignTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AnimatedAlign(
    alignment: config.alignment!,
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    heightFactor: config.heightFactor,
    key: config.key,
    onEnd: config.onEnd,
    widthFactor: config.widthFactor,
    child: child,
  );
}


class GeneratedAnimatedContainerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedContainerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedContainerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedContainerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_container').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_container').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_container',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedContainerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedContainerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'decoration':
          config.decoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'foregroundDecoration':
          config.foregroundDecoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'transform':
          config.transform = parseGeneratedMatrix4(value);
          break;
        case 'transformAlignment':
          config.transformAlignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('animated_container', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_container tag requires "duration"');
    }
    return config;
  }
}

class _GeneratedAnimatedContainerTagConfig {
  AlignmentGeometry? alignment;
  Clip? clipBehavior;
  Color? color;
  BoxConstraints? constraints;
  Curve? curve;
  Decoration? decoration;
  Duration? duration;
  Decoration? foregroundDecoration;
  double? height;
  Key? key;
  EdgeInsetsGeometry? margin;
  VoidCallback? onEnd;
  EdgeInsetsGeometry? padding;
  Matrix4? transform;
  AlignmentGeometry? transformAlignment;
  double? width;
}

AnimatedContainer _buildGeneratedAnimatedContainerTagWidget(_GeneratedAnimatedContainerTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AnimatedContainer(
    alignment: config.alignment,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    constraints: config.constraints,
    curve: config.curve ?? Curves.linear,
    decoration: config.decoration,
    duration: config.duration!,
    foregroundDecoration: config.foregroundDecoration,
    height: config.height,
    key: config.key,
    margin: config.margin,
    onEnd: config.onEnd,
    padding: config.padding,
    transform: config.transform,
    transformAlignment: config.transformAlignment,
    width: config.width,
    child: child,
  );
}


class GeneratedAnimatedDefaultTextStyleTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedDefaultTextStyleTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedDefaultTextStyleTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedDefaultTextStyleTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_default_text_style').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_default_text_style').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_default_text_style',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedDefaultTextStyleTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedDefaultTextStyleTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'maxLines':
          config.maxLines = toInt(value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'overflow':
          config.overflow = parseGeneratedTextOverflow(value);
          break;
        case 'softWrap':
          config.softWrap = toBool(value);
          break;
        case 'style':
          config.style = parseGeneratedTextStyle(value);
          break;
        case 'textAlign':
          config.textAlign = parseGeneratedTextAlign(value);
          break;
        case 'textHeightBehavior':
          config.textHeightBehavior = parseGeneratedTextHeightBehavior(value);
          break;
        case 'textWidthBasis':
          config.textWidthBasis = parseGeneratedTextWidthBasis(value);
          break;
        default:
          handleUnknownArg('animated_default_text_style', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_default_text_style tag requires "duration"');
    }
    if (config.style == null) {
      throw Exception('animated_default_text_style tag requires "style"');
    }
    return config;
  }
}

class _GeneratedAnimatedDefaultTextStyleTagConfig {
  Curve? curve;
  Duration? duration;
  Key? key;
  int? maxLines;
  VoidCallback? onEnd;
  TextOverflow? overflow;
  bool? softWrap;
  TextStyle? style;
  TextAlign? textAlign;
  TextHeightBehavior? textHeightBehavior;
  TextWidthBasis? textWidthBasis;
}

AnimatedDefaultTextStyle _buildGeneratedAnimatedDefaultTextStyleTagWidget(_GeneratedAnimatedDefaultTextStyleTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return AnimatedDefaultTextStyle(
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    key: config.key,
    maxLines: config.maxLines,
    onEnd: config.onEnd,
    overflow: config.overflow ?? TextOverflow.clip,
    softWrap: config.softWrap ?? true,
    style: config.style!,
    textAlign: config.textAlign,
    textHeightBehavior: config.textHeightBehavior,
    textWidthBasis: config.textWidthBasis ?? TextWidthBasis.parent,
    child: child,
  );
}


class GeneratedAnimatedOpacityTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedOpacityTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedOpacityTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedOpacityTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_opacity').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_opacity').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_opacity',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedOpacityTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedOpacityTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alwaysIncludeSemantics':
          config.alwaysIncludeSemantics = toBool(value);
          break;
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'opacity':
          config.opacity = toDouble(value);
          break;
        default:
          handleUnknownArg('animated_opacity', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_opacity tag requires "duration"');
    }
    if (config.opacity == null) {
      throw Exception('animated_opacity tag requires "opacity"');
    }
    return config;
  }
}

class _GeneratedAnimatedOpacityTagConfig {
  bool? alwaysIncludeSemantics;
  Curve? curve;
  Duration? duration;
  Key? key;
  VoidCallback? onEnd;
  double? opacity;
}

AnimatedOpacity _buildGeneratedAnimatedOpacityTagWidget(_GeneratedAnimatedOpacityTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AnimatedOpacity(
    alwaysIncludeSemantics: config.alwaysIncludeSemantics ?? false,
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    key: config.key,
    onEnd: config.onEnd,
    opacity: config.opacity!,
    child: child,
  );
}


class GeneratedAnimatedPaddingTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedPaddingTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedPaddingTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedPaddingTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_padding').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_padding').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_padding',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedPaddingTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedPaddingTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        default:
          handleUnknownArg('animated_padding', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_padding tag requires "duration"');
    }
    if (config.padding == null) {
      throw Exception('animated_padding tag requires "padding"');
    }
    return config;
  }
}

class _GeneratedAnimatedPaddingTagConfig {
  Curve? curve;
  Duration? duration;
  Key? key;
  VoidCallback? onEnd;
  EdgeInsetsGeometry? padding;
}

AnimatedPadding _buildGeneratedAnimatedPaddingTagWidget(_GeneratedAnimatedPaddingTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AnimatedPadding(
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    key: config.key,
    onEnd: config.onEnd,
    padding: config.padding!,
    child: child,
  );
}


class GeneratedAnimatedPositionedTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedPositionedTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedPositionedTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedPositionedTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_positioned').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_positioned').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_positioned',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedPositionedTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedPositionedTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'bottom':
          config.bottom = toDouble(value);
          break;
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'left':
          config.left = toDouble(value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'right':
          config.right = toDouble(value);
          break;
        case 'top':
          config.top = toDouble(value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('animated_positioned', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_positioned tag requires "duration"');
    }
    return config;
  }
}

class _GeneratedAnimatedPositionedTagConfig {
  double? bottom;
  Curve? curve;
  Duration? duration;
  double? height;
  Key? key;
  double? left;
  VoidCallback? onEnd;
  double? right;
  double? top;
  double? width;
}

AnimatedPositioned _buildGeneratedAnimatedPositionedTagWidget(_GeneratedAnimatedPositionedTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return AnimatedPositioned(
    bottom: config.bottom,
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    height: config.height,
    key: config.key,
    left: config.left,
    onEnd: config.onEnd,
    right: config.right,
    top: config.top,
    width: config.width,
    child: child,
  );
}


class GeneratedAnimatedRotationTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedRotationTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedRotationTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedRotationTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_rotation').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_rotation').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_rotation',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedRotationTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedRotationTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignment(value);
          break;
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'filterQuality':
          config.filterQuality = parseGeneratedFilterQuality(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'turns':
          config.turns = toDouble(value);
          break;
        default:
          handleUnknownArg('animated_rotation', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_rotation tag requires "duration"');
    }
    if (config.turns == null) {
      throw Exception('animated_rotation tag requires "turns"');
    }
    return config;
  }
}

class _GeneratedAnimatedRotationTagConfig {
  Alignment? alignment;
  Curve? curve;
  Duration? duration;
  FilterQuality? filterQuality;
  Key? key;
  VoidCallback? onEnd;
  double? turns;
}

AnimatedRotation _buildGeneratedAnimatedRotationTagWidget(_GeneratedAnimatedRotationTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AnimatedRotation(
    alignment: config.alignment ?? Alignment.center,
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    filterQuality: config.filterQuality,
    key: config.key,
    onEnd: config.onEnd,
    turns: config.turns!,
    child: child,
  );
}


class GeneratedAnimatedScaleTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedScaleTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedScaleTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedScaleTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_scale').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_scale').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_scale',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedScaleTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedScaleTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignment(value);
          break;
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'filterQuality':
          config.filterQuality = parseGeneratedFilterQuality(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        case 'scale':
          config.scale = toDouble(value);
          break;
        default:
          handleUnknownArg('animated_scale', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_scale tag requires "duration"');
    }
    if (config.scale == null) {
      throw Exception('animated_scale tag requires "scale"');
    }
    return config;
  }
}

class _GeneratedAnimatedScaleTagConfig {
  Alignment? alignment;
  Curve? curve;
  Duration? duration;
  FilterQuality? filterQuality;
  Key? key;
  VoidCallback? onEnd;
  double? scale;
}

AnimatedScale _buildGeneratedAnimatedScaleTagWidget(_GeneratedAnimatedScaleTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AnimatedScale(
    alignment: config.alignment ?? Alignment.center,
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    filterQuality: config.filterQuality,
    key: config.key,
    onEnd: config.onEnd,
    scale: config.scale!,
    child: child,
  );
}


class GeneratedAnimatedSlideTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAnimatedSlideTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAnimatedSlideTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAnimatedSlideTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('animated_slide').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endanimated_slide').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'animated_slide',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAnimatedSlideTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAnimatedSlideTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'offset':
          config.offset = parseGeneratedOffset(value);
          break;
        case 'onEnd':
          config.onEnd = resolveActionCallback(evaluator, value);
          break;
        default:
          handleUnknownArg('animated_slide', name);
          break;
      }
    }
    if (config.duration == null) {
      throw Exception('animated_slide tag requires "duration"');
    }
    if (config.offset == null) {
      throw Exception('animated_slide tag requires "offset"');
    }
    return config;
  }
}

class _GeneratedAnimatedSlideTagConfig {
  Curve? curve;
  Duration? duration;
  Key? key;
  Offset? offset;
  VoidCallback? onEnd;
}

AnimatedSlide _buildGeneratedAnimatedSlideTagWidget(_GeneratedAnimatedSlideTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AnimatedSlide(
    curve: config.curve ?? Curves.linear,
    duration: config.duration!,
    key: config.key,
    offset: config.offset!,
    onEnd: config.onEnd,
    child: child,
  );
}


class GeneratedAppBarTag extends WidgetTagBase with AsyncTag {
  GeneratedAppBarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedAppBarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedAppBarTagWidget(config, children));
  }

  _GeneratedAppBarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAppBarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'actions':
          config.actions = value;
          break;
        case 'actionsIconTheme':
          config.actionsIconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'actionsPadding':
          config.actionsPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'animateColor':
          config.animateColor = toBool(value);
          break;
        case 'automaticallyImplyActions':
          config.automaticallyImplyActions = toBool(value);
          break;
        case 'automaticallyImplyLeading':
          config.automaticallyImplyLeading = toBool(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'bottom':
          config.bottom = (value is PreferredSizeWidget ? value : parsePreferredSizeWidget(value) as PreferredSizeWidget?);
          break;
        case 'bottomOpacity':
          config.bottomOpacity = toDouble(value);
          break;
        case 'centerTitle':
          config.centerTitle = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'excludeHeaderSemantics':
          config.excludeHeaderSemantics = toBool(value);
          break;
        case 'flexibleSpace':
          config.flexibleSpace = resolveWidget(value);
          break;
        case 'forceMaterialTransparency':
          config.forceMaterialTransparency = toBool(value);
          break;
        case 'foregroundColor':
          config.foregroundColor = parseGeneratedColor(value);
          break;
        case 'iconTheme':
          config.iconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'leading':
          config.leading = resolveWidget(value);
          break;
        case 'leadingWidth':
          config.leadingWidth = toDouble(value);
          break;
        case 'notificationPredicate':
          config.notificationPredicate = resolveBoolPredicateCallback(evaluator, value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'scrolledUnderElevation':
          config.scrolledUnderElevation = toDouble(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'systemOverlayStyle':
          config.systemOverlayStyle = parseGeneratedSystemUiOverlayStyle(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'titleSpacing':
          config.titleSpacing = toDouble(value);
          break;
        case 'titleTextStyle':
          config.titleTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'toolbarHeight':
          config.toolbarHeight = toDouble(value);
          break;
        case 'toolbarOpacity':
          config.toolbarOpacity = toDouble(value);
          break;
        case 'toolbarTextStyle':
          config.toolbarTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'useDefaultSemanticsOrder':
          config.useDefaultSemanticsOrder = toBool(value);
          break;
        default:
          handleUnknownArg('app_bar', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedAppBarTagConfig {
  List<Widget>? actions;
  IconThemeData? actionsIconTheme;
  EdgeInsetsGeometry? actionsPadding;
  bool? animateColor;
  bool? automaticallyImplyActions;
  bool? automaticallyImplyLeading;
  Color? backgroundColor;
  PreferredSizeWidget? bottom;
  double? bottomOpacity;
  bool? centerTitle;
  Clip? clipBehavior;
  double? elevation;
  bool? excludeHeaderSemantics;
  Widget? flexibleSpace;
  bool? forceMaterialTransparency;
  Color? foregroundColor;
  IconThemeData? iconTheme;
  Key? key;
  Widget? leading;
  double? leadingWidth;
  ScrollNotificationPredicate? notificationPredicate;
  bool? primary;
  double? scrolledUnderElevation;
  Color? shadowColor;
  ShapeBorder? shape;
  Color? surfaceTintColor;
  SystemUiOverlayStyle? systemOverlayStyle;
  Widget? title;
  double? titleSpacing;
  TextStyle? titleTextStyle;
  double? toolbarHeight;
  double? toolbarOpacity;
  TextStyle? toolbarTextStyle;
  bool? useDefaultSemanticsOrder;
}

AppBar _buildGeneratedAppBarTagWidget(_GeneratedAppBarTagConfig config, List<Widget> children) {
  return AppBar(
    actions: config.actions,
    actionsIconTheme: config.actionsIconTheme,
    actionsPadding: config.actionsPadding,
    animateColor: config.animateColor ?? false,
    automaticallyImplyActions: config.automaticallyImplyActions ?? true,
    automaticallyImplyLeading: config.automaticallyImplyLeading ?? true,
    backgroundColor: config.backgroundColor,
    bottom: config.bottom,
    bottomOpacity: config.bottomOpacity ?? 1.0,
    centerTitle: config.centerTitle,
    clipBehavior: config.clipBehavior,
    elevation: config.elevation,
    excludeHeaderSemantics: config.excludeHeaderSemantics ?? false,
    flexibleSpace: config.flexibleSpace,
    forceMaterialTransparency: config.forceMaterialTransparency ?? false,
    foregroundColor: config.foregroundColor,
    iconTheme: config.iconTheme,
    key: config.key,
    leading: config.leading,
    leadingWidth: config.leadingWidth,
    notificationPredicate: config.notificationPredicate ?? defaultScrollNotificationPredicate,
    primary: config.primary ?? true,
    scrolledUnderElevation: config.scrolledUnderElevation,
    shadowColor: config.shadowColor,
    shape: config.shape,
    surfaceTintColor: config.surfaceTintColor,
    systemOverlayStyle: config.systemOverlayStyle,
    title: config.title,
    titleSpacing: config.titleSpacing,
    titleTextStyle: config.titleTextStyle,
    toolbarHeight: config.toolbarHeight,
    toolbarOpacity: config.toolbarOpacity ?? 1.0,
    toolbarTextStyle: config.toolbarTextStyle,
    useDefaultSemanticsOrder: config.useDefaultSemanticsOrder ?? true,
  );
}


class GeneratedAspectRatioTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedAspectRatioTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedAspectRatioTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedAspectRatioTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('aspect_ratio').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endaspect_ratio').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'aspect_ratio',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedAspectRatioTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAspectRatioTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'aspectRatio':
          config.aspectRatio = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('aspect_ratio', name);
          break;
      }
    }
    if (config.aspectRatio == null) {
      throw Exception('aspect_ratio tag requires "aspectRatio"');
    }
    return config;
  }
}

class _GeneratedAspectRatioTagConfig {
  double? aspectRatio;
  Key? key;
}

AspectRatio _buildGeneratedAspectRatioTagWidget(_GeneratedAspectRatioTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return AspectRatio(
    aspectRatio: config.aspectRatio!,
    key: config.key,
    child: child,
  );
}


class GeneratedAutocompleteTag extends WidgetTagBase with AsyncTag {
  GeneratedAutocompleteTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedAutocompleteTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedAutocompleteTagWidget(config, children));
  }

  _GeneratedAutocompleteTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedAutocompleteTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'displayStringForOption':
          config.displayStringForOption = (value is AutocompleteOptionToString<Object> ? value : resolveGenericCallback1(evaluator, value) as AutocompleteOptionToString<Object>?);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'initialValue':
          config.initialValue = parseGeneratedTextEditingValue(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onSelected':
          config.onSelected = (value is AutocompleteOnSelected<Object> ? value : resolveGenericValueChanged(evaluator, value) as AutocompleteOnSelected<Object>?);
          break;
        case 'optionsBuilder':
          config.optionsBuilder = (value is AutocompleteOptionsBuilder<Object> ? value : resolveGenericCallback1(evaluator, value) as AutocompleteOptionsBuilder<Object>?);
          break;
        case 'optionsMaxHeight':
          config.optionsMaxHeight = toDouble(value);
          break;
        case 'optionsViewBuilder':
          config.optionsViewBuilder = (value is AutocompleteOptionsViewBuilder<Object> ? value : resolveCallbackValue(evaluator, value) as AutocompleteOptionsViewBuilder<Object>?);
          break;
        case 'optionsViewOpenDirection':
          config.optionsViewOpenDirection = parseGeneratedOptionsViewOpenDirection(value);
          break;
        case 'textEditingController':
          config.textEditingController = parseGeneratedTextEditingController(value);
          break;
        default:
          handleUnknownArg('autocomplete', name);
          break;
      }
    }
    if (config.optionsBuilder == null) {
      throw Exception('autocomplete tag requires "optionsBuilder"');
    }
    return config;
  }
}

class _GeneratedAutocompleteTagConfig {
  AutocompleteOptionToString<Object>? displayStringForOption;
  FocusNode? focusNode;
  TextEditingValue? initialValue;
  Key? key;
  AutocompleteOnSelected<Object>? onSelected;
  AutocompleteOptionsBuilder<Object>? optionsBuilder;
  double? optionsMaxHeight;
  AutocompleteOptionsViewBuilder<Object>? optionsViewBuilder;
  OptionsViewOpenDirection? optionsViewOpenDirection;
  TextEditingController? textEditingController;
}

Autocomplete _buildGeneratedAutocompleteTagWidget(_GeneratedAutocompleteTagConfig config, List<Widget> children) {
  return Autocomplete(
    displayStringForOption: config.displayStringForOption ?? RawAutocomplete.defaultStringForOption,
    focusNode: config.focusNode,
    initialValue: config.initialValue,
    key: config.key,
    onSelected: config.onSelected,
    optionsBuilder: config.optionsBuilder!,
    optionsMaxHeight: config.optionsMaxHeight ?? 200.0,
    optionsViewBuilder: config.optionsViewBuilder,
    optionsViewOpenDirection: config.optionsViewOpenDirection ?? OptionsViewOpenDirection.down,
    textEditingController: config.textEditingController,
  );
}


class GeneratedBadgeTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedBadgeTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedBadgeTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedBadgeTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('badge').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endbadge').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'badge',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedBadgeTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedBadgeTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'isLabelVisible':
          config.isLabelVisible = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'largeSize':
          config.largeSize = toDouble(value);
          break;
        case 'offset':
          config.offset = parseGeneratedOffset(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'smallSize':
          config.smallSize = toDouble(value);
          break;
        case 'textColor':
          config.textColor = parseGeneratedColor(value);
          break;
        case 'textStyle':
          config.textStyle = parseGeneratedTextStyle(value);
          break;
        default:
          handleUnknownArg('badge', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedBadgeTagConfig {
  AlignmentGeometry? alignment;
  Color? backgroundColor;
  bool? isLabelVisible;
  Key? key;
  Widget? label;
  double? largeSize;
  Offset? offset;
  EdgeInsetsGeometry? padding;
  double? smallSize;
  Color? textColor;
  TextStyle? textStyle;
}

Badge _buildGeneratedBadgeTagWidget(_GeneratedBadgeTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Badge(
    alignment: config.alignment,
    backgroundColor: config.backgroundColor,
    isLabelVisible: config.isLabelVisible ?? true,
    key: config.key,
    label: config.label,
    largeSize: config.largeSize,
    offset: config.offset,
    padding: config.padding,
    smallSize: config.smallSize,
    textColor: config.textColor,
    textStyle: config.textStyle,
    child: child,
  );
}


class GeneratedBaselineTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedBaselineTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedBaselineTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedBaselineTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('baseline').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endbaseline').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'baseline',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedBaselineTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedBaselineTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'baseline':
          config.baseline = toDouble(value);
          break;
        case 'baselineType':
          config.baselineType = parseGeneratedTextBaseline(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('baseline', name);
          break;
      }
    }
    if (config.baseline == null) {
      throw Exception('baseline tag requires "baseline"');
    }
    if (config.baselineType == null) {
      throw Exception('baseline tag requires "baselineType"');
    }
    return config;
  }
}

class _GeneratedBaselineTagConfig {
  double? baseline;
  TextBaseline? baselineType;
  Key? key;
}

Baseline _buildGeneratedBaselineTagWidget(_GeneratedBaselineTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Baseline(
    baseline: config.baseline!,
    baselineType: config.baselineType!,
    key: config.key,
    child: child,
  );
}


class GeneratedBottomAppBarTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedBottomAppBarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedBottomAppBarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedBottomAppBarTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('bottom_app_bar').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endbottom_app_bar').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'bottom_app_bar',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedBottomAppBarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedBottomAppBarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'notchMargin':
          config.notchMargin = toDouble(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedNotchedShape(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        default:
          handleUnknownArg('bottom_app_bar', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedBottomAppBarTagConfig {
  Clip? clipBehavior;
  Color? color;
  double? elevation;
  double? height;
  Key? key;
  double? notchMargin;
  EdgeInsetsGeometry? padding;
  Color? shadowColor;
  NotchedShape? shape;
  Color? surfaceTintColor;
}

BottomAppBar _buildGeneratedBottomAppBarTagWidget(_GeneratedBottomAppBarTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return BottomAppBar(
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    elevation: config.elevation,
    height: config.height,
    key: config.key,
    notchMargin: config.notchMargin ?? 4.0,
    padding: config.padding,
    shadowColor: config.shadowColor,
    shape: config.shape,
    surfaceTintColor: config.surfaceTintColor,
    child: child,
  );
}


class GeneratedBottomNavigationBarTag extends WidgetTagBase with AsyncTag {
  GeneratedBottomNavigationBarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedBottomNavigationBarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedBottomNavigationBarTagWidget(config, children));
  }

  _GeneratedBottomNavigationBarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedBottomNavigationBarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'currentIndex':
          config.currentIndex = toInt(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'fixedColor':
          config.fixedColor = parseGeneratedColor(value);
          break;
        case 'iconSize':
          config.iconSize = toDouble(value);
          break;
        case 'items':
          config.items = parseGeneratedListOfBottomNavigationBarItem(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'landscapeLayout':
          config.landscapeLayout = parseGeneratedBottomNavigationBarLandscapeLayout(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onTap':
          config.onTap = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'selectedFontSize':
          config.selectedFontSize = toDouble(value);
          break;
        case 'selectedIconTheme':
          config.selectedIconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'selectedItemColor':
          config.selectedItemColor = parseGeneratedColor(value);
          break;
        case 'selectedLabelStyle':
          config.selectedLabelStyle = parseGeneratedTextStyle(value);
          break;
        case 'showSelectedLabels':
          config.showSelectedLabels = toBool(value);
          break;
        case 'showUnselectedLabels':
          config.showUnselectedLabels = toBool(value);
          break;
        case 'type':
          config.type = parseGeneratedBottomNavigationBarType(value);
          break;
        case 'unselectedFontSize':
          config.unselectedFontSize = toDouble(value);
          break;
        case 'unselectedIconTheme':
          config.unselectedIconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'unselectedItemColor':
          config.unselectedItemColor = parseGeneratedColor(value);
          break;
        case 'unselectedLabelStyle':
          config.unselectedLabelStyle = parseGeneratedTextStyle(value);
          break;
        case 'useLegacyColorScheme':
          config.useLegacyColorScheme = toBool(value);
          break;
        default:
          handleUnknownArg('bottom_navigation_bar', name);
          break;
      }
    }
    if (config.items == null) {
      throw Exception('bottom_navigation_bar tag requires "items"');
    }
    return config;
  }
}

class _GeneratedBottomNavigationBarTagConfig {
  Color? backgroundColor;
  int? currentIndex;
  double? elevation;
  bool? enableFeedback;
  Color? fixedColor;
  double? iconSize;
  List<BottomNavigationBarItem>? items;
  Key? key;
  BottomNavigationBarLandscapeLayout? landscapeLayout;
  MouseCursor? mouseCursor;
  ValueChanged<int>? onTap;
  double? selectedFontSize;
  IconThemeData? selectedIconTheme;
  Color? selectedItemColor;
  TextStyle? selectedLabelStyle;
  bool? showSelectedLabels;
  bool? showUnselectedLabels;
  BottomNavigationBarType? type;
  double? unselectedFontSize;
  IconThemeData? unselectedIconTheme;
  Color? unselectedItemColor;
  TextStyle? unselectedLabelStyle;
  bool? useLegacyColorScheme;
}

BottomNavigationBar _buildGeneratedBottomNavigationBarTagWidget(_GeneratedBottomNavigationBarTagConfig config, List<Widget> children) {
  return BottomNavigationBar(
    backgroundColor: config.backgroundColor,
    currentIndex: config.currentIndex ?? 0,
    elevation: config.elevation,
    enableFeedback: config.enableFeedback,
    fixedColor: config.fixedColor,
    iconSize: config.iconSize ?? 24.0,
    items: config.items!,
    key: config.key,
    landscapeLayout: config.landscapeLayout,
    mouseCursor: config.mouseCursor,
    onTap: config.onTap,
    selectedFontSize: config.selectedFontSize ?? 14.0,
    selectedIconTheme: config.selectedIconTheme,
    selectedItemColor: config.selectedItemColor,
    selectedLabelStyle: config.selectedLabelStyle,
    showSelectedLabels: config.showSelectedLabels,
    showUnselectedLabels: config.showUnselectedLabels,
    type: config.type,
    unselectedFontSize: config.unselectedFontSize ?? 12.0,
    unselectedIconTheme: config.unselectedIconTheme,
    unselectedItemColor: config.unselectedItemColor,
    unselectedLabelStyle: config.unselectedLabelStyle,
    useLegacyColorScheme: config.useLegacyColorScheme ?? true,
  );
}


class GeneratedBottomSheetTag extends WidgetTagBase with AsyncTag {
  GeneratedBottomSheetTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedBottomSheetTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedBottomSheetTagWidget(config, children));
  }

  _GeneratedBottomSheetTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedBottomSheetTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'animationController':
          config.animationController = parseGeneratedAnimationController(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'builder':
          config.builder = resolveWidgetBuilderCallback(evaluator, value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'dragHandleColor':
          config.dragHandleColor = parseGeneratedColor(value);
          break;
        case 'dragHandleSize':
          config.dragHandleSize = parseGeneratedSize(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'enableDrag':
          config.enableDrag = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onClosing':
          config.onClosing = resolveActionCallback(evaluator, value);
          break;
        case 'onDragEnd':
          config.onDragEnd = (value is BottomSheetDragEndHandler ? value : resolveCallbackValue(evaluator, value) as BottomSheetDragEndHandler?);
          break;
        case 'onDragStart':
          config.onDragStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'showDragHandle':
          config.showDragHandle = toBool(value);
          break;
        default:
          handleUnknownArg('bottom_sheet', name);
          break;
      }
    }
    if (config.builder == null) {
      throw Exception('bottom_sheet tag requires "builder"');
    }
    if (config.onClosing == null) {
      throw Exception('bottom_sheet tag requires "onClosing"');
    }
    return config;
  }
}

class _GeneratedBottomSheetTagConfig {
  AnimationController? animationController;
  Color? backgroundColor;
  WidgetBuilder? builder;
  Clip? clipBehavior;
  BoxConstraints? constraints;
  Color? dragHandleColor;
  Size? dragHandleSize;
  double? elevation;
  bool? enableDrag;
  Key? key;
  VoidCallback? onClosing;
  BottomSheetDragEndHandler? onDragEnd;
  BottomSheetDragStartHandler? onDragStart;
  Color? shadowColor;
  ShapeBorder? shape;
  bool? showDragHandle;
}

BottomSheet _buildGeneratedBottomSheetTagWidget(_GeneratedBottomSheetTagConfig config, List<Widget> children) {
  return BottomSheet(
    animationController: config.animationController,
    backgroundColor: config.backgroundColor,
    builder: config.builder!,
    clipBehavior: config.clipBehavior,
    constraints: config.constraints,
    dragHandleColor: config.dragHandleColor,
    dragHandleSize: config.dragHandleSize,
    elevation: config.elevation,
    enableDrag: config.enableDrag ?? true,
    key: config.key,
    onClosing: config.onClosing!,
    onDragEnd: config.onDragEnd,
    onDragStart: config.onDragStart,
    shadowColor: config.shadowColor,
    shape: config.shape,
    showDragHandle: config.showDragHandle,
  );
}


class GeneratedCalendarDatePickerTag extends WidgetTagBase with AsyncTag {
  GeneratedCalendarDatePickerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCalendarDatePickerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCalendarDatePickerTagWidget(config, children));
  }

  _GeneratedCalendarDatePickerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCalendarDatePickerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'calendarDelegate':
          config.calendarDelegate = (value is CalendarDelegate<DateTime> ? value : parseGeneratedCalendarDelegate(value) as CalendarDelegate<DateTime>?);
          break;
        case 'currentDate':
          config.currentDate = parseGeneratedDateTime(value);
          break;
        case 'firstDate':
          config.firstDate = parseGeneratedDateTime(value);
          break;
        case 'initialCalendarMode':
          config.initialCalendarMode = parseGeneratedDatePickerMode(value);
          break;
        case 'initialDate':
          config.initialDate = parseGeneratedDateTime(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'lastDate':
          config.lastDate = parseGeneratedDateTime(value);
          break;
        case 'onDateChanged':
          config.onDateChanged = (value is ValueChanged<DateTime> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<DateTime>?);
          break;
        case 'onDisplayedMonthChanged':
          config.onDisplayedMonthChanged = (value is ValueChanged<DateTime> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<DateTime>?);
          break;
        case 'selectableDayPredicate':
          config.selectableDayPredicate = resolveBoolPredicateCallback(evaluator, value);
          break;
        default:
          handleUnknownArg('calendar_date_picker', name);
          break;
      }
    }
    if (config.firstDate == null) {
      throw Exception('calendar_date_picker tag requires "firstDate"');
    }
    if (config.initialDate == null) {
      throw Exception('calendar_date_picker tag requires "initialDate"');
    }
    if (config.lastDate == null) {
      throw Exception('calendar_date_picker tag requires "lastDate"');
    }
    if (config.onDateChanged == null) {
      throw Exception('calendar_date_picker tag requires "onDateChanged"');
    }
    return config;
  }
}

class _GeneratedCalendarDatePickerTagConfig {
  CalendarDelegate<DateTime>? calendarDelegate;
  DateTime? currentDate;
  DateTime? firstDate;
  DatePickerMode? initialCalendarMode;
  DateTime? initialDate;
  Key? key;
  DateTime? lastDate;
  ValueChanged<DateTime>? onDateChanged;
  ValueChanged<DateTime>? onDisplayedMonthChanged;
  SelectableDayPredicate? selectableDayPredicate;
}

CalendarDatePicker _buildGeneratedCalendarDatePickerTagWidget(_GeneratedCalendarDatePickerTagConfig config, List<Widget> children) {
  return CalendarDatePicker(
    calendarDelegate: config.calendarDelegate ?? const GregorianCalendarDelegate(),
    currentDate: config.currentDate,
    firstDate: config.firstDate!,
    initialCalendarMode: config.initialCalendarMode ?? DatePickerMode.day,
    initialDate: config.initialDate,
    key: config.key,
    lastDate: config.lastDate!,
    onDateChanged: config.onDateChanged!,
    onDisplayedMonthChanged: config.onDisplayedMonthChanged,
    selectableDayPredicate: config.selectableDayPredicate,
  );
}


class GeneratedCardTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedCardTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedCardTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedCardTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('card').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endcard').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'card',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedCardTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCardTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'borderOnForeground':
          config.borderOnForeground = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'semanticContainer':
          config.semanticContainer = toBool(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        default:
          handleUnknownArg('card', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedCardTagConfig {
  bool? borderOnForeground;
  Clip? clipBehavior;
  Color? color;
  double? elevation;
  Key? key;
  EdgeInsetsGeometry? margin;
  bool? semanticContainer;
  Color? shadowColor;
  ShapeBorder? shape;
  Color? surfaceTintColor;
}

Card _buildGeneratedCardTagWidget(_GeneratedCardTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Card(
    borderOnForeground: config.borderOnForeground ?? true,
    clipBehavior: config.clipBehavior,
    color: config.color,
    elevation: config.elevation,
    key: config.key,
    margin: config.margin,
    semanticContainer: config.semanticContainer ?? true,
    shadowColor: config.shadowColor,
    shape: config.shape,
    surfaceTintColor: config.surfaceTintColor,
    child: child,
  );
}


class GeneratedCenterTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedCenterTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedCenterTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedCenterTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('center').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endcenter').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'center',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedCenterTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCenterTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'heightFactor':
          config.heightFactor = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'widthFactor':
          config.widthFactor = toDouble(value);
          break;
        default:
          handleUnknownArg('center', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedCenterTagConfig {
  double? heightFactor;
  Key? key;
  double? widthFactor;
}

Center _buildGeneratedCenterTagWidget(_GeneratedCenterTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Center(
    heightFactor: config.heightFactor,
    key: config.key,
    widthFactor: config.widthFactor,
    child: child,
  );
}


class GeneratedCheckboxTag extends WidgetTagBase with AsyncTag {
  GeneratedCheckboxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCheckboxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCheckboxTagWidget(config, children));
  }

  _GeneratedCheckboxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCheckboxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'activeColor':
          config.activeColor = parseGeneratedColor(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'checkColor':
          config.checkColor = parseGeneratedColor(value);
          break;
        case 'fillColor':
          config.fillColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'focusColor':
          config.focusColor = parseGeneratedColor(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'isError':
          config.isError = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<bool?> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool?>?);
          break;
        case 'overlayColor':
          config.overlayColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'semanticLabel':
          config.semanticLabel = toStringValue(value);
          break;
        case 'shape':
          config.shape = parseGeneratedOutlinedBorder(value);
          break;
        case 'side':
          config.side = parseGeneratedBorderSide(value);
          break;
        case 'splashRadius':
          config.splashRadius = toDouble(value);
          break;
        case 'tristate':
          config.tristate = toBool(value);
          break;
        case 'value':
          config.value = toBool(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('checkbox', name);
          break;
      }
    }
    if (config.onChanged == null) {
      throw Exception('checkbox tag requires "onChanged"');
    }
    if (config.value == null) {
      throw Exception('checkbox tag requires "value"');
    }
    return config;
  }
}

class _GeneratedCheckboxTagConfig {
  Color? activeColor;
  bool? autofocus;
  Color? checkColor;
  WidgetStateProperty<Color?>? fillColor;
  Color? focusColor;
  FocusNode? focusNode;
  Color? hoverColor;
  bool? isError;
  Key? key;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  ValueChanged<bool?>? onChanged;
  WidgetStateProperty<Color?>? overlayColor;
  String? semanticLabel;
  OutlinedBorder? shape;
  BorderSide? side;
  double? splashRadius;
  bool? tristate;
  bool? value;
  VisualDensity? visualDensity;
}

Checkbox _buildGeneratedCheckboxTagWidget(_GeneratedCheckboxTagConfig config, List<Widget> children) {
  return Checkbox(
    activeColor: config.activeColor,
    autofocus: config.autofocus ?? false,
    checkColor: config.checkColor,
    fillColor: config.fillColor,
    focusColor: config.focusColor,
    focusNode: config.focusNode,
    hoverColor: config.hoverColor,
    isError: config.isError ?? false,
    key: config.key,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onChanged: config.onChanged,
    overlayColor: config.overlayColor,
    semanticLabel: config.semanticLabel,
    shape: config.shape,
    side: config.side,
    splashRadius: config.splashRadius,
    tristate: config.tristate ?? false,
    value: config.value,
    visualDensity: config.visualDensity,
  );
}


class GeneratedCheckboxListTileTag extends WidgetTagBase with AsyncTag {
  GeneratedCheckboxListTileTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCheckboxListTileTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCheckboxListTileTagWidget(config, children));
  }

  _GeneratedCheckboxListTileTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCheckboxListTileTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'activeColor':
          config.activeColor = parseGeneratedColor(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'checkColor':
          config.checkColor = parseGeneratedColor(value);
          break;
        case 'checkboxScaleFactor':
          config.checkboxScaleFactor = toDouble(value);
          break;
        case 'checkboxSemanticLabel':
          config.checkboxSemanticLabel = toStringValue(value);
          break;
        case 'checkboxShape':
          config.checkboxShape = parseGeneratedOutlinedBorder(value);
          break;
        case 'contentPadding':
          config.contentPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'controlAffinity':
          config.controlAffinity = parseGeneratedListTileControlAffinity(value);
          break;
        case 'dense':
          config.dense = toBool(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'fillColor':
          config.fillColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'internalAddSemanticForOnTap':
          config.internalAddSemanticForOnTap = toBool(value);
          break;
        case 'isError':
          config.isError = toBool(value);
          break;
        case 'isThreeLine':
          config.isThreeLine = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<bool?> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool?>?);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'overlayColor':
          config.overlayColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'secondary':
          config.secondary = resolveWidget(value);
          break;
        case 'selected':
          config.selected = toBool(value);
          break;
        case 'selectedTileColor':
          config.selectedTileColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'side':
          config.side = parseGeneratedBorderSide(value);
          break;
        case 'splashRadius':
          config.splashRadius = toDouble(value);
          break;
        case 'subtitle':
          config.subtitle = resolveWidget(value);
          break;
        case 'tileColor':
          config.tileColor = parseGeneratedColor(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'titleAlignment':
          config.titleAlignment = parseGeneratedListTileTitleAlignment(value);
          break;
        case 'tristate':
          config.tristate = toBool(value);
          break;
        case 'value':
          config.value = toBool(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('checkbox_list_tile', name);
          break;
      }
    }
    if (config.onChanged == null) {
      throw Exception('checkbox_list_tile tag requires "onChanged"');
    }
    if (config.value == null) {
      throw Exception('checkbox_list_tile tag requires "value"');
    }
    return config;
  }
}

class _GeneratedCheckboxListTileTagConfig {
  Color? activeColor;
  bool? autofocus;
  Color? checkColor;
  double? checkboxScaleFactor;
  String? checkboxSemanticLabel;
  OutlinedBorder? checkboxShape;
  EdgeInsetsGeometry? contentPadding;
  ListTileControlAffinity? controlAffinity;
  bool? dense;
  bool? enableFeedback;
  bool? enabled;
  WidgetStateProperty<Color?>? fillColor;
  FocusNode? focusNode;
  Color? hoverColor;
  bool? internalAddSemanticForOnTap;
  bool? isError;
  bool? isThreeLine;
  Key? key;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  ValueChanged<bool?>? onChanged;
  ValueChanged<bool>? onFocusChange;
  WidgetStateProperty<Color?>? overlayColor;
  Widget? secondary;
  bool? selected;
  Color? selectedTileColor;
  ShapeBorder? shape;
  BorderSide? side;
  double? splashRadius;
  Widget? subtitle;
  Color? tileColor;
  Widget? title;
  ListTileTitleAlignment? titleAlignment;
  bool? tristate;
  bool? value;
  VisualDensity? visualDensity;
}

CheckboxListTile _buildGeneratedCheckboxListTileTagWidget(_GeneratedCheckboxListTileTagConfig config, List<Widget> children) {
  return CheckboxListTile(
    activeColor: config.activeColor,
    autofocus: config.autofocus ?? false,
    checkColor: config.checkColor,
    checkboxScaleFactor: config.checkboxScaleFactor ?? 1.0,
    checkboxSemanticLabel: config.checkboxSemanticLabel,
    checkboxShape: config.checkboxShape,
    contentPadding: config.contentPadding,
    controlAffinity: config.controlAffinity,
    dense: config.dense,
    enableFeedback: config.enableFeedback,
    enabled: config.enabled,
    fillColor: config.fillColor,
    focusNode: config.focusNode,
    hoverColor: config.hoverColor,
    internalAddSemanticForOnTap: config.internalAddSemanticForOnTap ?? false,
    isError: config.isError ?? false,
    isThreeLine: config.isThreeLine,
    key: config.key,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onChanged: config.onChanged,
    onFocusChange: config.onFocusChange,
    overlayColor: config.overlayColor,
    secondary: config.secondary,
    selected: config.selected ?? false,
    selectedTileColor: config.selectedTileColor,
    shape: config.shape,
    side: config.side,
    splashRadius: config.splashRadius,
    subtitle: config.subtitle,
    tileColor: config.tileColor,
    title: config.title,
    titleAlignment: config.titleAlignment,
    tristate: config.tristate ?? false,
    value: config.value,
    visualDensity: config.visualDensity,
  );
}


class GeneratedChipTag extends WidgetTagBase with AsyncTag {
  GeneratedChipTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedChipTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedChipTagWidget(config, children));
  }

  _GeneratedChipTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedChipTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'avatar':
          config.avatar = resolveWidget(value);
          break;
        case 'avatarBoxConstraints':
          config.avatarBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'chipAnimationStyle':
          config.chipAnimationStyle = parseGeneratedChipAnimationStyle(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'deleteButtonTooltipMessage':
          config.deleteButtonTooltipMessage = toStringValue(value);
          break;
        case 'deleteIcon':
          config.deleteIcon = resolveWidget(value);
          break;
        case 'deleteIconBoxConstraints':
          config.deleteIconBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'deleteIconColor':
          config.deleteIconColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'iconTheme':
          config.iconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'labelPadding':
          config.labelPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'labelStyle':
          config.labelStyle = parseGeneratedTextStyle(value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onDeleted':
          config.onDeleted = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedOutlinedBorder(value);
          break;
        case 'side':
          config.side = parseGeneratedBorderSide(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('chip', name);
          break;
      }
    }
    if (config.label == null) {
      throw Exception('chip tag requires "label"');
    }
    return config;
  }
}

class _GeneratedChipTagConfig {
  bool? autofocus;
  Widget? avatar;
  BoxConstraints? avatarBoxConstraints;
  Color? backgroundColor;
  ChipAnimationStyle? chipAnimationStyle;
  Clip? clipBehavior;
  WidgetStateProperty<Color?>? color;
  String? deleteButtonTooltipMessage;
  Widget? deleteIcon;
  BoxConstraints? deleteIconBoxConstraints;
  Color? deleteIconColor;
  double? elevation;
  FocusNode? focusNode;
  IconThemeData? iconTheme;
  Key? key;
  Widget? label;
  EdgeInsetsGeometry? labelPadding;
  TextStyle? labelStyle;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  VoidCallback? onDeleted;
  EdgeInsetsGeometry? padding;
  Color? shadowColor;
  OutlinedBorder? shape;
  BorderSide? side;
  Color? surfaceTintColor;
  VisualDensity? visualDensity;
}

Chip _buildGeneratedChipTagWidget(_GeneratedChipTagConfig config, List<Widget> children) {
  return Chip(
    autofocus: config.autofocus ?? false,
    avatar: config.avatar,
    avatarBoxConstraints: config.avatarBoxConstraints,
    backgroundColor: config.backgroundColor,
    chipAnimationStyle: config.chipAnimationStyle,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    deleteButtonTooltipMessage: config.deleteButtonTooltipMessage,
    deleteIcon: config.deleteIcon,
    deleteIconBoxConstraints: config.deleteIconBoxConstraints,
    deleteIconColor: config.deleteIconColor,
    elevation: config.elevation,
    focusNode: config.focusNode,
    iconTheme: config.iconTheme,
    key: config.key,
    label: config.label!,
    labelPadding: config.labelPadding,
    labelStyle: config.labelStyle,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onDeleted: config.onDeleted,
    padding: config.padding,
    shadowColor: config.shadowColor,
    shape: config.shape,
    side: config.side,
    surfaceTintColor: config.surfaceTintColor,
    visualDensity: config.visualDensity,
  );
}


class GeneratedChoiceChipTag extends WidgetTagBase with AsyncTag {
  GeneratedChoiceChipTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedChoiceChipTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedChoiceChipTagWidget(config, children));
  }

  _GeneratedChoiceChipTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedChoiceChipTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'avatar':
          config.avatar = resolveWidget(value);
          break;
        case 'avatarBorder':
          config.avatarBorder = parseGeneratedShapeBorder(value);
          break;
        case 'avatarBoxConstraints':
          config.avatarBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'checkmarkColor':
          config.checkmarkColor = parseGeneratedColor(value);
          break;
        case 'chipAnimationStyle':
          config.chipAnimationStyle = parseGeneratedChipAnimationStyle(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'disabledColor':
          config.disabledColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'iconTheme':
          config.iconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'labelPadding':
          config.labelPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'labelStyle':
          config.labelStyle = parseGeneratedTextStyle(value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onSelected':
          config.onSelected = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'pressElevation':
          config.pressElevation = toDouble(value);
          break;
        case 'selected':
          config.selected = toBool(value);
          break;
        case 'selectedColor':
          config.selectedColor = parseGeneratedColor(value);
          break;
        case 'selectedShadowColor':
          config.selectedShadowColor = parseGeneratedColor(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedOutlinedBorder(value);
          break;
        case 'showCheckmark':
          config.showCheckmark = toBool(value);
          break;
        case 'side':
          config.side = parseGeneratedBorderSide(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('choice_chip', name);
          break;
      }
    }
    if (config.label == null) {
      throw Exception('choice_chip tag requires "label"');
    }
    if (config.selected == null) {
      throw Exception('choice_chip tag requires "selected"');
    }
    return config;
  }
}

class _GeneratedChoiceChipTagConfig {
  bool? autofocus;
  Widget? avatar;
  ShapeBorder? avatarBorder;
  BoxConstraints? avatarBoxConstraints;
  Color? backgroundColor;
  Color? checkmarkColor;
  ChipAnimationStyle? chipAnimationStyle;
  Clip? clipBehavior;
  WidgetStateProperty<Color?>? color;
  Color? disabledColor;
  double? elevation;
  FocusNode? focusNode;
  IconThemeData? iconTheme;
  Key? key;
  Widget? label;
  EdgeInsetsGeometry? labelPadding;
  TextStyle? labelStyle;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  ValueChanged<bool>? onSelected;
  EdgeInsetsGeometry? padding;
  double? pressElevation;
  bool? selected;
  Color? selectedColor;
  Color? selectedShadowColor;
  Color? shadowColor;
  OutlinedBorder? shape;
  bool? showCheckmark;
  BorderSide? side;
  Color? surfaceTintColor;
  String? tooltip;
  VisualDensity? visualDensity;
}

ChoiceChip _buildGeneratedChoiceChipTagWidget(_GeneratedChoiceChipTagConfig config, List<Widget> children) {
  return ChoiceChip(
    autofocus: config.autofocus ?? false,
    avatar: config.avatar,
    avatarBorder: config.avatarBorder ?? const CircleBorder(),
    avatarBoxConstraints: config.avatarBoxConstraints,
    backgroundColor: config.backgroundColor,
    checkmarkColor: config.checkmarkColor,
    chipAnimationStyle: config.chipAnimationStyle,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    disabledColor: config.disabledColor,
    elevation: config.elevation,
    focusNode: config.focusNode,
    iconTheme: config.iconTheme,
    key: config.key,
    label: config.label!,
    labelPadding: config.labelPadding,
    labelStyle: config.labelStyle,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onSelected: config.onSelected,
    padding: config.padding,
    pressElevation: config.pressElevation,
    selected: config.selected!,
    selectedColor: config.selectedColor,
    selectedShadowColor: config.selectedShadowColor,
    shadowColor: config.shadowColor,
    shape: config.shape,
    showCheckmark: config.showCheckmark,
    side: config.side,
    surfaceTintColor: config.surfaceTintColor,
    tooltip: config.tooltip,
    visualDensity: config.visualDensity,
  );
}


class GeneratedCircleAvatarTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedCircleAvatarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedCircleAvatarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedCircleAvatarTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('circle_avatar').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endcircle_avatar').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'circle_avatar',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedCircleAvatarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCircleAvatarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'backgroundImage':
          config.backgroundImage = (value is ImageProvider<Object> ? value : parseGeneratedImageProvider(value) as ImageProvider<Object>?);
          break;
        case 'foregroundColor':
          config.foregroundColor = parseGeneratedColor(value);
          break;
        case 'foregroundImage':
          config.foregroundImage = (value is ImageProvider<Object> ? value : parseGeneratedImageProvider(value) as ImageProvider<Object>?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'maxRadius':
          config.maxRadius = toDouble(value);
          break;
        case 'minRadius':
          config.minRadius = toDouble(value);
          break;
        case 'onBackgroundImageError':
          config.onBackgroundImageError = (value is ImageErrorListener ? value : resolveGenericActionCallback2(evaluator, value) as ImageErrorListener?);
          break;
        case 'onForegroundImageError':
          config.onForegroundImageError = (value is ImageErrorListener ? value : resolveGenericActionCallback2(evaluator, value) as ImageErrorListener?);
          break;
        case 'radius':
          config.radius = toDouble(value);
          break;
        default:
          handleUnknownArg('circle_avatar', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedCircleAvatarTagConfig {
  Color? backgroundColor;
  ImageProvider<Object>? backgroundImage;
  Color? foregroundColor;
  ImageProvider<Object>? foregroundImage;
  Key? key;
  double? maxRadius;
  double? minRadius;
  ImageErrorListener? onBackgroundImageError;
  ImageErrorListener? onForegroundImageError;
  double? radius;
}

CircleAvatar _buildGeneratedCircleAvatarTagWidget(_GeneratedCircleAvatarTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return CircleAvatar(
    backgroundColor: config.backgroundColor,
    backgroundImage: config.backgroundImage,
    foregroundColor: config.foregroundColor,
    foregroundImage: config.foregroundImage,
    key: config.key,
    maxRadius: config.maxRadius,
    minRadius: config.minRadius,
    onBackgroundImageError: config.onBackgroundImageError,
    onForegroundImageError: config.onForegroundImageError,
    radius: config.radius,
    child: child,
  );
}


class GeneratedCircularProgressIndicatorTag extends WidgetTagBase with AsyncTag {
  GeneratedCircularProgressIndicatorTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCircularProgressIndicatorTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCircularProgressIndicatorTagWidget(config, children));
  }

  _GeneratedCircularProgressIndicatorTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCircularProgressIndicatorTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'controller':
          config.controller = parseGeneratedAnimationController(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'semanticsLabel':
          config.semanticsLabel = toStringValue(value);
          break;
        case 'semanticsValue':
          config.semanticsValue = toStringValue(value);
          break;
        case 'strokeAlign':
          config.strokeAlign = toDouble(value);
          break;
        case 'strokeCap':
          config.strokeCap = parseGeneratedStrokeCap(value);
          break;
        case 'strokeWidth':
          config.strokeWidth = toDouble(value);
          break;
        case 'trackGap':
          config.trackGap = toDouble(value);
          break;
        case 'value':
          config.value = toDouble(value);
          break;
        case 'valueColor':
          config.valueColor = parseGeneratedAnimationOfColor(value);
          break;
        case 'year2023':
          config.year2023 = toBool(value);
          break;
        default:
          handleUnknownArg('circular_progress_indicator', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedCircularProgressIndicatorTagConfig {
  Color? backgroundColor;
  Color? color;
  BoxConstraints? constraints;
  AnimationController? controller;
  Key? key;
  EdgeInsetsGeometry? padding;
  String? semanticsLabel;
  String? semanticsValue;
  double? strokeAlign;
  StrokeCap? strokeCap;
  double? strokeWidth;
  double? trackGap;
  double? value;
  Animation<Color?>? valueColor;
  bool? year2023;
}

CircularProgressIndicator _buildGeneratedCircularProgressIndicatorTagWidget(_GeneratedCircularProgressIndicatorTagConfig config, List<Widget> children) {
  return CircularProgressIndicator(
    backgroundColor: config.backgroundColor,
    color: config.color,
    constraints: config.constraints,
    controller: config.controller,
    key: config.key,
    padding: config.padding,
    semanticsLabel: config.semanticsLabel,
    semanticsValue: config.semanticsValue,
    strokeAlign: config.strokeAlign,
    strokeCap: config.strokeCap,
    strokeWidth: config.strokeWidth,
    trackGap: config.trackGap,
    value: config.value,
    valueColor: config.valueColor,
    year2023: config.year2023,
  );
}


class GeneratedClipOvalTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedClipOvalTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedClipOvalTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedClipOvalTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('clip_oval').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endclip_oval').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'clip_oval',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedClipOvalTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedClipOvalTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'clipper':
          config.clipper = (value is CustomClipper<Rect> ? value : parseGeneratedCustomClipper(value) as CustomClipper<Rect>?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('clip_oval', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedClipOvalTagConfig {
  Clip? clipBehavior;
  CustomClipper<Rect>? clipper;
  Key? key;
}

ClipOval _buildGeneratedClipOvalTagWidget(_GeneratedClipOvalTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ClipOval(
    clipBehavior: config.clipBehavior ?? Clip.antiAlias,
    clipper: config.clipper,
    key: config.key,
    child: child,
  );
}


class GeneratedClipPathTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedClipPathTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedClipPathTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedClipPathTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('clip_path').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endclip_path').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'clip_path',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedClipPathTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedClipPathTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'clipper':
          config.clipper = (value is CustomClipper<Path> ? value : parseGeneratedCustomClipper(value) as CustomClipper<Path>?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('clip_path', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedClipPathTagConfig {
  Clip? clipBehavior;
  CustomClipper<Path>? clipper;
  Key? key;
}

ClipPath _buildGeneratedClipPathTagWidget(_GeneratedClipPathTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ClipPath(
    clipBehavior: config.clipBehavior ?? Clip.antiAlias,
    clipper: config.clipper,
    key: config.key,
    child: child,
  );
}


class GeneratedClipRRectTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedClipRRectTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedClipRRectTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedClipRRectTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('clip_r_rect').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endclip_r_rect').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'clip_r_rect',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedClipRRectTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedClipRRectTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'borderRadius':
          config.borderRadius = parseGeneratedBorderRadiusGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'clipper':
          config.clipper = (value is CustomClipper<RRect> ? value : parseGeneratedCustomClipper(value) as CustomClipper<RRect>?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('clip_r_rect', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedClipRRectTagConfig {
  BorderRadiusGeometry? borderRadius;
  Clip? clipBehavior;
  CustomClipper<RRect>? clipper;
  Key? key;
}

ClipRRect _buildGeneratedClipRRectTagWidget(_GeneratedClipRRectTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ClipRRect(
    borderRadius: config.borderRadius ?? BorderRadius.zero,
    clipBehavior: config.clipBehavior ?? Clip.antiAlias,
    clipper: config.clipper,
    key: config.key,
    child: child,
  );
}


class GeneratedClipRectTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedClipRectTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedClipRectTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedClipRectTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('clip_rect').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endclip_rect').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'clip_rect',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedClipRectTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedClipRectTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'clipper':
          config.clipper = (value is CustomClipper<Rect> ? value : parseGeneratedCustomClipper(value) as CustomClipper<Rect>?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('clip_rect', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedClipRectTagConfig {
  Clip? clipBehavior;
  CustomClipper<Rect>? clipper;
  Key? key;
}

ClipRect _buildGeneratedClipRectTagWidget(_GeneratedClipRectTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ClipRect(
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    clipper: config.clipper,
    key: config.key,
    child: child,
  );
}


class GeneratedColoredBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedColoredBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedColoredBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedColoredBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('colored_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endcolored_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'colored_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedColoredBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedColoredBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('colored_box', name);
          break;
      }
    }
    if (config.color == null) {
      throw Exception('colored_box tag requires "color"');
    }
    return config;
  }
}

class _GeneratedColoredBoxTagConfig {
  Color? color;
  Key? key;
}

ColoredBox _buildGeneratedColoredBoxTagWidget(_GeneratedColoredBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ColoredBox(
    color: config.color!,
    key: config.key,
    child: child,
  );
}


class GeneratedColumnTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedColumnTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedColumnTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedColumnTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('column').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endcolumn').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'column',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedColumnTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedColumnTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'crossAxisAlignment':
          config.crossAxisAlignment = parseGeneratedCrossAxisAlignment(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'mainAxisAlignment':
          config.mainAxisAlignment = parseGeneratedMainAxisAlignment(value);
          break;
        case 'mainAxisSize':
          config.mainAxisSize = parseGeneratedMainAxisSize(value);
          break;
        case 'spacing':
          config.spacing = toDouble(value);
          break;
        case 'textBaseline':
          config.textBaseline = parseGeneratedTextBaseline(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'verticalDirection':
          config.verticalDirection = parseGeneratedVerticalDirection(value);
          break;
        default:
          handleUnknownArg('column', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedColumnTagConfig {
  CrossAxisAlignment? crossAxisAlignment;
  Key? key;
  MainAxisAlignment? mainAxisAlignment;
  MainAxisSize? mainAxisSize;
  double? spacing;
  TextBaseline? textBaseline;
  TextDirection? textDirection;
  VerticalDirection? verticalDirection;
}

Column _buildGeneratedColumnTagWidget(_GeneratedColumnTagConfig config, List<Widget> children) {
  return Column(
    crossAxisAlignment: config.crossAxisAlignment ?? CrossAxisAlignment.center,
    key: config.key,
    mainAxisAlignment: config.mainAxisAlignment ?? MainAxisAlignment.start,
    mainAxisSize: config.mainAxisSize ?? MainAxisSize.max,
    spacing: config.spacing ?? 0.0,
    textBaseline: config.textBaseline,
    textDirection: config.textDirection,
    verticalDirection: config.verticalDirection ?? VerticalDirection.down,
    children: children,
  );
}


class GeneratedConstrainedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedConstrainedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedConstrainedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedConstrainedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('constrained_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endconstrained_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'constrained_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedConstrainedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedConstrainedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('constrained_box', name);
          break;
      }
    }
    if (config.constraints == null) {
      throw Exception('constrained_box tag requires "constraints"');
    }
    return config;
  }
}

class _GeneratedConstrainedBoxTagConfig {
  BoxConstraints? constraints;
  Key? key;
}

ConstrainedBox _buildGeneratedConstrainedBoxTagWidget(_GeneratedConstrainedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ConstrainedBox(
    constraints: config.constraints!,
    key: config.key,
    child: child,
  );
}


class GeneratedContainerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedContainerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedContainerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedContainerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('container').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endcontainer').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'container',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedContainerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedContainerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'decoration':
          config.decoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'foregroundDecoration':
          config.foregroundDecoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'transform':
          config.transform = parseGeneratedMatrix4(value);
          break;
        case 'transformAlignment':
          config.transformAlignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('container', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedContainerTagConfig {
  AlignmentGeometry? alignment;
  Clip? clipBehavior;
  Color? color;
  BoxConstraints? constraints;
  Decoration? decoration;
  Decoration? foregroundDecoration;
  double? height;
  Key? key;
  EdgeInsetsGeometry? margin;
  EdgeInsetsGeometry? padding;
  Matrix4? transform;
  AlignmentGeometry? transformAlignment;
  double? width;
}

Container _buildGeneratedContainerTagWidget(_GeneratedContainerTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Container(
    alignment: config.alignment,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    constraints: config.constraints,
    decoration: config.decoration,
    foregroundDecoration: config.foregroundDecoration,
    height: config.height,
    key: config.key,
    margin: config.margin,
    padding: config.padding,
    transform: config.transform,
    transformAlignment: config.transformAlignment,
    width: config.width,
    child: child,
  );
}


class GeneratedCustomScrollViewTag extends WidgetTagBase with AsyncTag {
  GeneratedCustomScrollViewTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCustomScrollViewTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedCustomScrollViewTagWidget(config, children));
  }

  _GeneratedCustomScrollViewTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedCustomScrollViewTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'anchor':
          config.anchor = toDouble(value);
          break;
        case 'cacheExtent':
          config.cacheExtent = toDouble(value);
          break;
        case 'center':
          config.center = parseGeneratedKey(evaluator, value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'controller':
          config.controller = parseGeneratedScrollController(evaluator, value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'hitTestBehavior':
          config.hitTestBehavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardDismissBehavior':
          config.keyboardDismissBehavior = parseGeneratedScrollViewKeyboardDismissBehavior(value);
          break;
        case 'paintOrder':
          config.paintOrder = parseGeneratedSliverPaintOrder(value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'reverse':
          config.reverse = toBool(value);
          break;
        case 'scrollBehavior':
          config.scrollBehavior = parseGeneratedScrollBehavior(value);
          break;
        case 'scrollDirection':
          config.scrollDirection = parseGeneratedAxis(value);
          break;
        case 'semanticChildCount':
          config.semanticChildCount = toInt(value);
          break;
        case 'shrinkWrap':
          config.shrinkWrap = toBool(value);
          break;
        case 'slivers':
          config.slivers = value;
          break;
        default:
          handleUnknownArg('custom_scroll_view', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedCustomScrollViewTagConfig {
  double? anchor;
  double? cacheExtent;
  Key? center;
  Clip? clipBehavior;
  ScrollController? controller;
  DragStartBehavior? dragStartBehavior;
  HitTestBehavior? hitTestBehavior;
  Key? key;
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
  SliverPaintOrder? paintOrder;
  ScrollPhysics? physics;
  bool? primary;
  String? restorationId;
  bool? reverse;
  ScrollBehavior? scrollBehavior;
  Axis? scrollDirection;
  int? semanticChildCount;
  bool? shrinkWrap;
  List<Widget>? slivers;
}

CustomScrollView _buildGeneratedCustomScrollViewTagWidget(_GeneratedCustomScrollViewTagConfig config, List<Widget> children) {
  return CustomScrollView(
    anchor: config.anchor ?? 0.0,
    cacheExtent: config.cacheExtent,
    center: config.center,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    controller: config.controller,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    hitTestBehavior: config.hitTestBehavior ?? HitTestBehavior.opaque,
    key: config.key,
    keyboardDismissBehavior: config.keyboardDismissBehavior,
    paintOrder: config.paintOrder ?? SliverPaintOrder.firstIsTop,
    physics: config.physics,
    primary: config.primary,
    restorationId: config.restorationId,
    reverse: config.reverse ?? false,
    scrollBehavior: config.scrollBehavior,
    scrollDirection: config.scrollDirection ?? Axis.vertical,
    semanticChildCount: config.semanticChildCount,
    shrinkWrap: config.shrinkWrap ?? false,
    slivers: config.slivers ?? const <Widget>[],
  );
}


class GeneratedDataTableTag extends WidgetTagBase with AsyncTag {
  GeneratedDataTableTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDataTableTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDataTableTagWidget(config, children));
  }

  _GeneratedDataTableTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDataTableTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'border':
          config.border = parseGeneratedTableBorder(value);
          break;
        case 'checkboxHorizontalMargin':
          config.checkboxHorizontalMargin = toDouble(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'columnSpacing':
          config.columnSpacing = toDouble(value);
          break;
        case 'columns':
          config.columns = parseGeneratedListOfDataColumn(value);
          break;
        case 'dataRowColor':
          config.dataRowColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'dataRowHeight':
          config.dataRowHeight = toDouble(value);
          break;
        case 'dataRowMaxHeight':
          config.dataRowMaxHeight = toDouble(value);
          break;
        case 'dataRowMinHeight':
          config.dataRowMinHeight = toDouble(value);
          break;
        case 'dataTextStyle':
          config.dataTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'decoration':
          config.decoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'dividerThickness':
          config.dividerThickness = toDouble(value);
          break;
        case 'headingRowColor':
          config.headingRowColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'headingRowHeight':
          config.headingRowHeight = toDouble(value);
          break;
        case 'headingTextStyle':
          config.headingTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'horizontalMargin':
          config.horizontalMargin = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onSelectAll':
          config.onSelectAll = (value is ValueSetter<bool?> ? value : resolveGenericValueChanged(evaluator, value) as ValueSetter<bool?>?);
          break;
        case 'rows':
          config.rows = parseGeneratedListOfDataRow(evaluator, value);
          break;
        case 'showBottomBorder':
          config.showBottomBorder = toBool(value);
          break;
        case 'showCheckboxColumn':
          config.showCheckboxColumn = toBool(value);
          break;
        case 'sortAscending':
          config.sortAscending = toBool(value);
          break;
        case 'sortColumnIndex':
          config.sortColumnIndex = toInt(value);
          break;
        default:
          handleUnknownArg('data_table', name);
          break;
      }
    }
    if (config.columns == null) {
      throw Exception('data_table tag requires "columns"');
    }
    if (config.rows == null) {
      throw Exception('data_table tag requires "rows"');
    }
    return config;
  }
}

class _GeneratedDataTableTagConfig {
  TableBorder? border;
  double? checkboxHorizontalMargin;
  Clip? clipBehavior;
  double? columnSpacing;
  List<DataColumn>? columns;
  WidgetStateProperty<Color?>? dataRowColor;
  double? dataRowHeight;
  double? dataRowMaxHeight;
  double? dataRowMinHeight;
  TextStyle? dataTextStyle;
  Decoration? decoration;
  double? dividerThickness;
  WidgetStateProperty<Color?>? headingRowColor;
  double? headingRowHeight;
  TextStyle? headingTextStyle;
  double? horizontalMargin;
  Key? key;
  ValueSetter<bool?>? onSelectAll;
  List<DataRow>? rows;
  bool? showBottomBorder;
  bool? showCheckboxColumn;
  bool? sortAscending;
  int? sortColumnIndex;
}

DataTable _buildGeneratedDataTableTagWidget(_GeneratedDataTableTagConfig config, List<Widget> children) {
  return DataTable(
    border: config.border,
    checkboxHorizontalMargin: config.checkboxHorizontalMargin,
    clipBehavior: config.clipBehavior ?? Clip.none,
    columnSpacing: config.columnSpacing,
    columns: config.columns!,
    dataRowColor: config.dataRowColor,
    dataRowHeight: config.dataRowHeight,
    dataRowMaxHeight: config.dataRowMaxHeight,
    dataRowMinHeight: config.dataRowMinHeight,
    dataTextStyle: config.dataTextStyle,
    decoration: config.decoration,
    dividerThickness: config.dividerThickness,
    headingRowColor: config.headingRowColor,
    headingRowHeight: config.headingRowHeight,
    headingTextStyle: config.headingTextStyle,
    horizontalMargin: config.horizontalMargin,
    key: config.key,
    onSelectAll: config.onSelectAll,
    rows: config.rows!,
    showBottomBorder: config.showBottomBorder ?? false,
    showCheckboxColumn: config.showCheckboxColumn ?? true,
    sortAscending: config.sortAscending ?? true,
    sortColumnIndex: config.sortColumnIndex,
  );
}


class GeneratedDatePickerDialogTag extends WidgetTagBase with AsyncTag {
  GeneratedDatePickerDialogTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDatePickerDialogTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDatePickerDialogTagWidget(config, children));
  }

  _GeneratedDatePickerDialogTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDatePickerDialogTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'calendarDelegate':
          config.calendarDelegate = (value is CalendarDelegate<DateTime> ? value : parseGeneratedCalendarDelegate(value) as CalendarDelegate<DateTime>?);
          break;
        case 'cancelText':
          config.cancelText = toStringValue(value);
          break;
        case 'confirmText':
          config.confirmText = toStringValue(value);
          break;
        case 'currentDate':
          config.currentDate = parseGeneratedDateTime(value);
          break;
        case 'errorFormatText':
          config.errorFormatText = toStringValue(value);
          break;
        case 'errorInvalidText':
          config.errorInvalidText = toStringValue(value);
          break;
        case 'fieldHintText':
          config.fieldHintText = toStringValue(value);
          break;
        case 'fieldLabelText':
          config.fieldLabelText = toStringValue(value);
          break;
        case 'firstDate':
          config.firstDate = parseGeneratedDateTime(value);
          break;
        case 'helpText':
          config.helpText = toStringValue(value);
          break;
        case 'initialCalendarMode':
          config.initialCalendarMode = parseGeneratedDatePickerMode(value);
          break;
        case 'initialDate':
          config.initialDate = parseGeneratedDateTime(value);
          break;
        case 'initialEntryMode':
          config.initialEntryMode = parseGeneratedDatePickerEntryMode(value);
          break;
        case 'insetPadding':
          config.insetPadding = parseGeneratedEdgeInsets(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardType':
          config.keyboardType = parseGeneratedTextInputType(value);
          break;
        case 'lastDate':
          config.lastDate = parseGeneratedDateTime(value);
          break;
        case 'onDatePickerModeChange':
          config.onDatePickerModeChange = (value is ValueChanged<DatePickerEntryMode> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<DatePickerEntryMode>?);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'selectableDayPredicate':
          config.selectableDayPredicate = resolveBoolPredicateCallback(evaluator, value);
          break;
        case 'switchToCalendarEntryModeIcon':
          config.switchToCalendarEntryModeIcon = parseGeneratedIcon(evaluator, value);
          break;
        case 'switchToInputEntryModeIcon':
          config.switchToInputEntryModeIcon = parseGeneratedIcon(evaluator, value);
          break;
        default:
          handleUnknownArg('date_picker_dialog', name);
          break;
      }
    }
    if (config.firstDate == null) {
      throw Exception('date_picker_dialog tag requires "firstDate"');
    }
    if (config.lastDate == null) {
      throw Exception('date_picker_dialog tag requires "lastDate"');
    }
    return config;
  }
}

class _GeneratedDatePickerDialogTagConfig {
  CalendarDelegate<DateTime>? calendarDelegate;
  String? cancelText;
  String? confirmText;
  DateTime? currentDate;
  String? errorFormatText;
  String? errorInvalidText;
  String? fieldHintText;
  String? fieldLabelText;
  DateTime? firstDate;
  String? helpText;
  DatePickerMode? initialCalendarMode;
  DateTime? initialDate;
  DatePickerEntryMode? initialEntryMode;
  EdgeInsets? insetPadding;
  Key? key;
  TextInputType? keyboardType;
  DateTime? lastDate;
  ValueChanged<DatePickerEntryMode>? onDatePickerModeChange;
  String? restorationId;
  SelectableDayPredicate? selectableDayPredicate;
  Icon? switchToCalendarEntryModeIcon;
  Icon? switchToInputEntryModeIcon;
}

DatePickerDialog _buildGeneratedDatePickerDialogTagWidget(_GeneratedDatePickerDialogTagConfig config, List<Widget> children) {
  return DatePickerDialog(
    calendarDelegate: config.calendarDelegate ?? const GregorianCalendarDelegate(),
    cancelText: config.cancelText,
    confirmText: config.confirmText,
    currentDate: config.currentDate,
    errorFormatText: config.errorFormatText,
    errorInvalidText: config.errorInvalidText,
    fieldHintText: config.fieldHintText,
    fieldLabelText: config.fieldLabelText,
    firstDate: config.firstDate!,
    helpText: config.helpText,
    initialCalendarMode: config.initialCalendarMode ?? DatePickerMode.day,
    initialDate: config.initialDate,
    initialEntryMode: config.initialEntryMode ?? DatePickerEntryMode.calendar,
    insetPadding: config.insetPadding ?? const EdgeInsets.symmetric(horizontal: 16.0, vertical: 24.0),
    key: config.key,
    keyboardType: config.keyboardType,
    lastDate: config.lastDate!,
    onDatePickerModeChange: config.onDatePickerModeChange,
    restorationId: config.restorationId,
    selectableDayPredicate: config.selectableDayPredicate,
    switchToCalendarEntryModeIcon: config.switchToCalendarEntryModeIcon,
    switchToInputEntryModeIcon: config.switchToInputEntryModeIcon,
  );
}


class GeneratedDecoratedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedDecoratedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedDecoratedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedDecoratedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('decorated_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('enddecorated_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'decorated_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedDecoratedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDecoratedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'decoration':
          config.decoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'position':
          config.position = parseGeneratedDecorationPosition(value);
          break;
        default:
          handleUnknownArg('decorated_box', name);
          break;
      }
    }
    if (config.decoration == null) {
      throw Exception('decorated_box tag requires "decoration"');
    }
    return config;
  }
}

class _GeneratedDecoratedBoxTagConfig {
  Decoration? decoration;
  Key? key;
  DecorationPosition? position;
}

DecoratedBox _buildGeneratedDecoratedBoxTagWidget(_GeneratedDecoratedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return DecoratedBox(
    decoration: config.decoration!,
    key: config.key,
    position: config.position ?? DecorationPosition.background,
    child: child,
  );
}


class GeneratedDefaultTabControllerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedDefaultTabControllerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedDefaultTabControllerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedDefaultTabControllerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('default_tab_controller').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('enddefault_tab_controller').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'default_tab_controller',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedDefaultTabControllerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDefaultTabControllerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'animationDuration':
          config.animationDuration = parseGeneratedDuration(value);
          break;
        case 'initialIndex':
          config.initialIndex = toInt(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'length':
          config.length = toInt(value);
          break;
        default:
          handleUnknownArg('default_tab_controller', name);
          break;
      }
    }
    if (config.length == null) {
      throw Exception('default_tab_controller tag requires "length"');
    }
    return config;
  }
}

class _GeneratedDefaultTabControllerTagConfig {
  Duration? animationDuration;
  int? initialIndex;
  Key? key;
  int? length;
}

DefaultTabController _buildGeneratedDefaultTabControllerTagWidget(_GeneratedDefaultTabControllerTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return DefaultTabController(
    animationDuration: config.animationDuration,
    initialIndex: config.initialIndex ?? 0,
    key: config.key,
    length: config.length!,
    child: child,
  );
}


class GeneratedDefaultTextStyleTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedDefaultTextStyleTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedDefaultTextStyleTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedDefaultTextStyleTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('default_text_style').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('enddefault_text_style').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'default_text_style',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedDefaultTextStyleTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDefaultTextStyleTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'maxLines':
          config.maxLines = toInt(value);
          break;
        case 'overflow':
          config.overflow = parseGeneratedTextOverflow(value);
          break;
        case 'softWrap':
          config.softWrap = toBool(value);
          break;
        case 'style':
          config.style = parseGeneratedTextStyle(value);
          break;
        case 'textAlign':
          config.textAlign = parseGeneratedTextAlign(value);
          break;
        case 'textHeightBehavior':
          config.textHeightBehavior = parseGeneratedTextHeightBehavior(value);
          break;
        case 'textWidthBasis':
          config.textWidthBasis = parseGeneratedTextWidthBasis(value);
          break;
        default:
          handleUnknownArg('default_text_style', name);
          break;
      }
    }
    if (config.style == null) {
      throw Exception('default_text_style tag requires "style"');
    }
    return config;
  }
}

class _GeneratedDefaultTextStyleTagConfig {
  Key? key;
  int? maxLines;
  TextOverflow? overflow;
  bool? softWrap;
  TextStyle? style;
  TextAlign? textAlign;
  TextHeightBehavior? textHeightBehavior;
  TextWidthBasis? textWidthBasis;
}

DefaultTextStyle _buildGeneratedDefaultTextStyleTagWidget(_GeneratedDefaultTextStyleTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return DefaultTextStyle(
    key: config.key,
    maxLines: config.maxLines,
    overflow: config.overflow ?? TextOverflow.clip,
    softWrap: config.softWrap ?? true,
    style: config.style!,
    textAlign: config.textAlign,
    textHeightBehavior: config.textHeightBehavior,
    textWidthBasis: config.textWidthBasis ?? TextWidthBasis.parent,
    child: child,
  );
}


class GeneratedDismissibleTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedDismissibleTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedDismissibleTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedDismissibleTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('dismissible').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('enddismissible').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'dismissible',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedDismissibleTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDismissibleTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'background':
          config.background = resolveWidget(value);
          break;
        case 'behavior':
          config.behavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'confirmDismiss':
          config.confirmDismiss = (value is ConfirmDismissCallback ? value : resolveFutureBoolCallback1(evaluator, value) as ConfirmDismissCallback?);
          break;
        case 'crossAxisEndOffset':
          config.crossAxisEndOffset = toDouble(value);
          break;
        case 'direction':
          config.direction = parseGeneratedDismissDirection(value);
          break;
        case 'dismissThresholds':
          config.dismissThresholds = parseDismissThresholds(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'movementDuration':
          config.movementDuration = parseGeneratedDuration(value);
          break;
        case 'onDismissed':
          config.onDismissed = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onResize':
          config.onResize = resolveActionCallback(evaluator, value);
          break;
        case 'onUpdate':
          config.onUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'resizeDuration':
          config.resizeDuration = parseGeneratedDuration(value);
          break;
        case 'secondaryBackground':
          config.secondaryBackground = resolveWidget(value);
          break;
        default:
          handleUnknownArg('dismissible', name);
          break;
      }
    }
    if (config.key == null) {
      throw Exception('dismissible tag requires "key"');
    }
    return config;
  }
}

class _GeneratedDismissibleTagConfig {
  Widget? background;
  HitTestBehavior? behavior;
  ConfirmDismissCallback? confirmDismiss;
  double? crossAxisEndOffset;
  DismissDirection? direction;
  Map<DismissDirection, double>? dismissThresholds;
  DragStartBehavior? dragStartBehavior;
  Key? key;
  Duration? movementDuration;
  DismissDirectionCallback? onDismissed;
  VoidCallback? onResize;
  DismissUpdateCallback? onUpdate;
  Duration? resizeDuration;
  Widget? secondaryBackground;
}

Dismissible _buildGeneratedDismissibleTagWidget(_GeneratedDismissibleTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return Dismissible(
    background: config.background,
    behavior: config.behavior ?? HitTestBehavior.opaque,
    confirmDismiss: config.confirmDismiss,
    crossAxisEndOffset: config.crossAxisEndOffset ?? 0.0,
    direction: config.direction ?? DismissDirection.horizontal,
    dismissThresholds: config.dismissThresholds ?? const <DismissDirection, double>{},
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    key: config.key!,
    movementDuration: config.movementDuration ?? const Duration(milliseconds: 200),
    onDismissed: config.onDismissed,
    onResize: config.onResize,
    onUpdate: config.onUpdate,
    resizeDuration: config.resizeDuration ?? const Duration(milliseconds: 300),
    secondaryBackground: config.secondaryBackground,
    child: child,
  );
}


class GeneratedDividerTag extends WidgetTagBase with AsyncTag {
  GeneratedDividerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDividerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDividerTagWidget(config, children));
  }

  _GeneratedDividerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDividerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'endIndent':
          config.endIndent = toDouble(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'indent':
          config.indent = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'radius':
          config.radius = parseGeneratedBorderRadiusGeometry(value);
          break;
        case 'thickness':
          config.thickness = toDouble(value);
          break;
        default:
          handleUnknownArg('divider', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedDividerTagConfig {
  Color? color;
  double? endIndent;
  double? height;
  double? indent;
  Key? key;
  BorderRadiusGeometry? radius;
  double? thickness;
}

Divider _buildGeneratedDividerTagWidget(_GeneratedDividerTagConfig config, List<Widget> children) {
  return Divider(
    color: config.color,
    endIndent: config.endIndent,
    height: config.height,
    indent: config.indent,
    key: config.key,
    radius: config.radius,
    thickness: config.thickness,
  );
}


class GeneratedDrawerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedDrawerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedDrawerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedDrawerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('drawer').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('enddrawer').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'drawer',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedDrawerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDrawerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'semanticLabel':
          config.semanticLabel = toStringValue(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('drawer', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedDrawerTagConfig {
  Color? backgroundColor;
  Clip? clipBehavior;
  double? elevation;
  Key? key;
  String? semanticLabel;
  Color? shadowColor;
  ShapeBorder? shape;
  Color? surfaceTintColor;
  double? width;
}

Drawer _buildGeneratedDrawerTagWidget(_GeneratedDrawerTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Drawer(
    backgroundColor: config.backgroundColor,
    clipBehavior: config.clipBehavior,
    elevation: config.elevation,
    key: config.key,
    semanticLabel: config.semanticLabel,
    shadowColor: config.shadowColor,
    shape: config.shape,
    surfaceTintColor: config.surfaceTintColor,
    width: config.width,
    child: child,
  );
}


class GeneratedDrawerHeaderTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedDrawerHeaderTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedDrawerHeaderTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedDrawerHeaderTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('drawer_header').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('enddrawer_header').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'drawer_header',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedDrawerHeaderTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDrawerHeaderTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'curve':
          config.curve = parseGeneratedCurve(value);
          break;
        case 'decoration':
          config.decoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        default:
          handleUnknownArg('drawer_header', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedDrawerHeaderTagConfig {
  Curve? curve;
  Decoration? decoration;
  Duration? duration;
  Key? key;
  EdgeInsetsGeometry? margin;
  EdgeInsetsGeometry? padding;
}

DrawerHeader _buildGeneratedDrawerHeaderTagWidget(_GeneratedDrawerHeaderTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return DrawerHeader(
    curve: config.curve ?? Curves.fastOutSlowIn,
    decoration: config.decoration,
    duration: config.duration ?? const Duration(milliseconds: 250),
    key: config.key,
    margin: config.margin ?? const EdgeInsets.only(bottom: 8.0),
    padding: config.padding ?? const EdgeInsets.fromLTRB(16.0, 16.0, 16.0, 8.0),
    child: child,
  );
}


class GeneratedDropdownButtonTag extends WidgetTagBase with AsyncTag {
  GeneratedDropdownButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDropdownButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedDropdownButtonTagWidget(config, children));
  }

  _GeneratedDropdownButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedDropdownButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'barrierDismissible':
          config.barrierDismissible = toBool(value);
          break;
        case 'borderRadius':
          config.borderRadius = parseGeneratedBorderRadius(value);
          break;
        case 'disabledHint':
          config.disabledHint = resolveWidget(value);
          break;
        case 'dropdownColor':
          config.dropdownColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toInt(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'focusColor':
          config.focusColor = parseGeneratedColor(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'hint':
          config.hint = resolveWidget(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'iconDisabledColor':
          config.iconDisabledColor = parseGeneratedColor(value);
          break;
        case 'iconEnabledColor':
          config.iconEnabledColor = parseGeneratedColor(value);
          break;
        case 'iconSize':
          config.iconSize = toDouble(value);
          break;
        case 'isDense':
          config.isDense = toBool(value);
          break;
        case 'isExpanded':
          config.isExpanded = toBool(value);
          break;
        case 'itemHeight':
          config.itemHeight = toDouble(value);
          break;
        case 'items':
          config.items = parseGeneratedListOfDropdownMenuItemObject(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'menuMaxHeight':
          config.menuMaxHeight = toDouble(value);
          break;
        case 'menuWidth':
          config.menuWidth = toDouble(value);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<Object?> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<Object?>?);
          break;
        case 'onTap':
          config.onTap = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'selectedItemBuilder':
          config.selectedItemBuilder = resolveWidgetListBuilderCallback(evaluator, value);
          break;
        case 'style':
          config.style = parseGeneratedTextStyle(value);
          break;
        case 'underline':
          config.underline = resolveWidget(value);
          break;
        case 'value':
          config.value = parseGeneratedObject(evaluator, value);
          break;
        default:
          handleUnknownArg('dropdown_button', name);
          break;
      }
    }
    if (config.items == null) {
      throw Exception('dropdown_button tag requires "items"');
    }
    if (config.onChanged == null) {
      throw Exception('dropdown_button tag requires "onChanged"');
    }
    return config;
  }
}

class _GeneratedDropdownButtonTagConfig {
  AlignmentGeometry? alignment;
  bool? autofocus;
  bool? barrierDismissible;
  BorderRadius? borderRadius;
  Widget? disabledHint;
  Color? dropdownColor;
  int? elevation;
  bool? enableFeedback;
  Color? focusColor;
  FocusNode? focusNode;
  Widget? hint;
  Widget? icon;
  Color? iconDisabledColor;
  Color? iconEnabledColor;
  double? iconSize;
  bool? isDense;
  bool? isExpanded;
  double? itemHeight;
  List<DropdownMenuItem<Object?>>? items;
  Key? key;
  double? menuMaxHeight;
  double? menuWidth;
  ValueChanged<Object?>? onChanged;
  VoidCallback? onTap;
  EdgeInsetsGeometry? padding;
  DropdownButtonBuilder? selectedItemBuilder;
  TextStyle? style;
  Widget? underline;
  Object? value;
}

DropdownButton _buildGeneratedDropdownButtonTagWidget(_GeneratedDropdownButtonTagConfig config, List<Widget> children) {
  return DropdownButton(
    alignment: config.alignment ?? AlignmentDirectional.centerStart,
    autofocus: config.autofocus ?? false,
    barrierDismissible: config.barrierDismissible ?? true,
    borderRadius: config.borderRadius,
    disabledHint: config.disabledHint,
    dropdownColor: config.dropdownColor,
    elevation: config.elevation ?? 8,
    enableFeedback: config.enableFeedback,
    focusColor: config.focusColor,
    focusNode: config.focusNode,
    hint: config.hint,
    icon: config.icon,
    iconDisabledColor: config.iconDisabledColor,
    iconEnabledColor: config.iconEnabledColor,
    iconSize: config.iconSize ?? 24.0,
    isDense: config.isDense ?? false,
    isExpanded: config.isExpanded ?? false,
    itemHeight: config.itemHeight ?? kMinInteractiveDimension,
    items: config.items,
    key: config.key,
    menuMaxHeight: config.menuMaxHeight,
    menuWidth: config.menuWidth,
    onChanged: config.onChanged,
    onTap: config.onTap,
    padding: config.padding,
    selectedItemBuilder: config.selectedItemBuilder,
    style: config.style,
    underline: config.underline,
    value: config.value,
  );
}


class GeneratedElevatedButtonTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedElevatedButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedElevatedButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedElevatedButtonTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('elevated_button').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endelevated_button').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'elevated_button',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedElevatedButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedElevatedButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onHover':
          config.onHover = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onLongPress':
          config.onLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'style':
          config.style = parseGeneratedButtonStyle(evaluator, value);
          break;
        default:
          handleUnknownArg('elevated_button', name);
          break;
      }
    }
    if (config.onPressed == null) {
      throw Exception('elevated_button tag requires "onPressed"');
    }
    return config;
  }
}

class _GeneratedElevatedButtonTagConfig {
  bool? autofocus;
  Clip? clipBehavior;
  FocusNode? focusNode;
  Key? key;
  ValueChanged<bool>? onFocusChange;
  ValueChanged<bool>? onHover;
  VoidCallback? onLongPress;
  VoidCallback? onPressed;
  MaterialStatesController? statesController;
  ButtonStyle? style;
}

ElevatedButton _buildGeneratedElevatedButtonTagWidget(_GeneratedElevatedButtonTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ElevatedButton(
    autofocus: config.autofocus ?? false,
    clipBehavior: config.clipBehavior,
    focusNode: config.focusNode,
    key: config.key,
    onFocusChange: config.onFocusChange,
    onHover: config.onHover,
    onLongPress: config.onLongPress,
    onPressed: config.onPressed,
    statesController: config.statesController,
    style: config.style,
    child: child,
  );
}


class GeneratedExpandedTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedExpandedTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedExpandedTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedExpandedTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('expanded').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endexpanded').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'expanded',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedExpandedTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedExpandedTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'flex':
          config.flex = toInt(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('expanded', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedExpandedTagConfig {
  int? flex;
  Key? key;
}

Expanded _buildGeneratedExpandedTagWidget(_GeneratedExpandedTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return Expanded(
    flex: config.flex ?? 1,
    key: config.key,
    child: child,
  );
}


class GeneratedExpansionTileTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedExpansionTileTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedExpansionTileTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedExpansionTileTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('expansion_tile').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endexpansion_tile').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'expansion_tile',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedExpansionTileTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedExpansionTileTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'childrenPadding':
          config.childrenPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'collapsedBackgroundColor':
          config.collapsedBackgroundColor = parseGeneratedColor(value);
          break;
        case 'collapsedIconColor':
          config.collapsedIconColor = parseGeneratedColor(value);
          break;
        case 'collapsedShape':
          config.collapsedShape = parseGeneratedShapeBorder(value);
          break;
        case 'collapsedTextColor':
          config.collapsedTextColor = parseGeneratedColor(value);
          break;
        case 'controlAffinity':
          config.controlAffinity = parseGeneratedListTileControlAffinity(value);
          break;
        case 'controller':
          config.controller = parseGeneratedExpansibleController(value);
          break;
        case 'dense':
          config.dense = toBool(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'expandedAlignment':
          config.expandedAlignment = parseGeneratedAlignment(value);
          break;
        case 'expandedCrossAxisAlignment':
          config.expandedCrossAxisAlignment = parseGeneratedCrossAxisAlignment(value);
          break;
        case 'expansionAnimationStyle':
          config.expansionAnimationStyle = parseGeneratedAnimationStyle(value);
          break;
        case 'iconColor':
          config.iconColor = parseGeneratedColor(value);
          break;
        case 'initiallyExpanded':
          config.initiallyExpanded = toBool(value);
          break;
        case 'internalAddSemanticForOnTap':
          config.internalAddSemanticForOnTap = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'leading':
          config.leading = resolveWidget(value);
          break;
        case 'maintainState':
          config.maintainState = toBool(value);
          break;
        case 'minTileHeight':
          config.minTileHeight = toDouble(value);
          break;
        case 'onExpansionChanged':
          config.onExpansionChanged = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'showTrailingIcon':
          config.showTrailingIcon = toBool(value);
          break;
        case 'splashColor':
          config.splashColor = parseGeneratedColor(value);
          break;
        case 'subtitle':
          config.subtitle = resolveWidget(value);
          break;
        case 'textColor':
          config.textColor = parseGeneratedColor(value);
          break;
        case 'tilePadding':
          config.tilePadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'trailing':
          config.trailing = resolveWidget(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('expansion_tile', name);
          break;
      }
    }
    if (config.title == null) {
      throw Exception('expansion_tile tag requires "title"');
    }
    return config;
  }
}

class _GeneratedExpansionTileTagConfig {
  Color? backgroundColor;
  EdgeInsetsGeometry? childrenPadding;
  Clip? clipBehavior;
  Color? collapsedBackgroundColor;
  Color? collapsedIconColor;
  ShapeBorder? collapsedShape;
  Color? collapsedTextColor;
  ListTileControlAffinity? controlAffinity;
  ExpansibleController? controller;
  bool? dense;
  bool? enableFeedback;
  bool? enabled;
  Alignment? expandedAlignment;
  CrossAxisAlignment? expandedCrossAxisAlignment;
  AnimationStyle? expansionAnimationStyle;
  Color? iconColor;
  bool? initiallyExpanded;
  bool? internalAddSemanticForOnTap;
  Key? key;
  Widget? leading;
  bool? maintainState;
  double? minTileHeight;
  ValueChanged<bool>? onExpansionChanged;
  ShapeBorder? shape;
  bool? showTrailingIcon;
  Color? splashColor;
  Widget? subtitle;
  Color? textColor;
  EdgeInsetsGeometry? tilePadding;
  Widget? title;
  Widget? trailing;
  VisualDensity? visualDensity;
}

ExpansionTile _buildGeneratedExpansionTileTagWidget(_GeneratedExpansionTileTagConfig config, List<Widget> children) {
  return ExpansionTile(
    backgroundColor: config.backgroundColor,
    childrenPadding: config.childrenPadding,
    clipBehavior: config.clipBehavior,
    collapsedBackgroundColor: config.collapsedBackgroundColor,
    collapsedIconColor: config.collapsedIconColor,
    collapsedShape: config.collapsedShape,
    collapsedTextColor: config.collapsedTextColor,
    controlAffinity: config.controlAffinity,
    controller: config.controller,
    dense: config.dense,
    enableFeedback: config.enableFeedback ?? true,
    enabled: config.enabled ?? true,
    expandedAlignment: config.expandedAlignment,
    expandedCrossAxisAlignment: config.expandedCrossAxisAlignment,
    expansionAnimationStyle: config.expansionAnimationStyle,
    iconColor: config.iconColor,
    initiallyExpanded: config.initiallyExpanded ?? false,
    internalAddSemanticForOnTap: config.internalAddSemanticForOnTap ?? false,
    key: config.key,
    leading: config.leading,
    maintainState: config.maintainState ?? false,
    minTileHeight: config.minTileHeight,
    onExpansionChanged: config.onExpansionChanged,
    shape: config.shape,
    showTrailingIcon: config.showTrailingIcon ?? true,
    splashColor: config.splashColor,
    subtitle: config.subtitle,
    textColor: config.textColor,
    tilePadding: config.tilePadding,
    title: config.title!,
    trailing: config.trailing,
    visualDensity: config.visualDensity,
    children: children,
  );
}


class GeneratedFadeTransitionTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFadeTransitionTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFadeTransitionTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFadeTransitionTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('fade_transition').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endfade_transition').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'fade_transition',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFadeTransitionTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFadeTransitionTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alwaysIncludeSemantics':
          config.alwaysIncludeSemantics = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'opacity':
          config.opacity = parseGeneratedAnimationOfDouble(value);
          break;
        default:
          handleUnknownArg('fade_transition', name);
          break;
      }
    }
    if (config.opacity == null) {
      throw Exception('fade_transition tag requires "opacity"');
    }
    return config;
  }
}

class _GeneratedFadeTransitionTagConfig {
  bool? alwaysIncludeSemantics;
  Key? key;
  Animation<double>? opacity;
}

FadeTransition _buildGeneratedFadeTransitionTagWidget(_GeneratedFadeTransitionTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return FadeTransition(
    alwaysIncludeSemantics: config.alwaysIncludeSemantics ?? false,
    key: config.key,
    opacity: config.opacity!,
    child: child,
  );
}


class GeneratedFilledButtonTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFilledButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFilledButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFilledButtonTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('filled_button').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endfilled_button').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'filled_button',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFilledButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFilledButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onHover':
          config.onHover = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onLongPress':
          config.onLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'style':
          config.style = parseGeneratedButtonStyle(evaluator, value);
          break;
        default:
          handleUnknownArg('filled_button', name);
          break;
      }
    }
    if (config.onPressed == null) {
      throw Exception('filled_button tag requires "onPressed"');
    }
    return config;
  }
}

class _GeneratedFilledButtonTagConfig {
  bool? autofocus;
  Clip? clipBehavior;
  FocusNode? focusNode;
  Key? key;
  ValueChanged<bool>? onFocusChange;
  ValueChanged<bool>? onHover;
  VoidCallback? onLongPress;
  VoidCallback? onPressed;
  MaterialStatesController? statesController;
  ButtonStyle? style;
}

FilledButton _buildGeneratedFilledButtonTagWidget(_GeneratedFilledButtonTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return FilledButton(
    autofocus: config.autofocus ?? false,
    clipBehavior: config.clipBehavior ?? Clip.none,
    focusNode: config.focusNode,
    key: config.key,
    onFocusChange: config.onFocusChange,
    onHover: config.onHover,
    onLongPress: config.onLongPress,
    onPressed: config.onPressed,
    statesController: config.statesController,
    style: config.style,
    child: child,
  );
}


class GeneratedFilterChipTag extends WidgetTagBase with AsyncTag {
  GeneratedFilterChipTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedFilterChipTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedFilterChipTagWidget(config, children));
  }

  _GeneratedFilterChipTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFilterChipTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'avatar':
          config.avatar = resolveWidget(value);
          break;
        case 'avatarBorder':
          config.avatarBorder = parseGeneratedShapeBorder(value);
          break;
        case 'avatarBoxConstraints':
          config.avatarBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'checkmarkColor':
          config.checkmarkColor = parseGeneratedColor(value);
          break;
        case 'chipAnimationStyle':
          config.chipAnimationStyle = parseGeneratedChipAnimationStyle(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'deleteButtonTooltipMessage':
          config.deleteButtonTooltipMessage = toStringValue(value);
          break;
        case 'deleteIcon':
          config.deleteIcon = resolveWidget(value);
          break;
        case 'deleteIconBoxConstraints':
          config.deleteIconBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'deleteIconColor':
          config.deleteIconColor = parseGeneratedColor(value);
          break;
        case 'disabledColor':
          config.disabledColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'iconTheme':
          config.iconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'labelPadding':
          config.labelPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'labelStyle':
          config.labelStyle = parseGeneratedTextStyle(value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onDeleted':
          config.onDeleted = resolveActionCallback(evaluator, value);
          break;
        case 'onSelected':
          config.onSelected = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'pressElevation':
          config.pressElevation = toDouble(value);
          break;
        case 'selected':
          config.selected = toBool(value);
          break;
        case 'selectedColor':
          config.selectedColor = parseGeneratedColor(value);
          break;
        case 'selectedShadowColor':
          config.selectedShadowColor = parseGeneratedColor(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedOutlinedBorder(value);
          break;
        case 'showCheckmark':
          config.showCheckmark = toBool(value);
          break;
        case 'side':
          config.side = parseGeneratedBorderSide(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('filter_chip', name);
          break;
      }
    }
    if (config.label == null) {
      throw Exception('filter_chip tag requires "label"');
    }
    if (config.onSelected == null) {
      throw Exception('filter_chip tag requires "onSelected"');
    }
    return config;
  }
}

class _GeneratedFilterChipTagConfig {
  bool? autofocus;
  Widget? avatar;
  ShapeBorder? avatarBorder;
  BoxConstraints? avatarBoxConstraints;
  Color? backgroundColor;
  Color? checkmarkColor;
  ChipAnimationStyle? chipAnimationStyle;
  Clip? clipBehavior;
  WidgetStateProperty<Color?>? color;
  String? deleteButtonTooltipMessage;
  Widget? deleteIcon;
  BoxConstraints? deleteIconBoxConstraints;
  Color? deleteIconColor;
  Color? disabledColor;
  double? elevation;
  FocusNode? focusNode;
  IconThemeData? iconTheme;
  Key? key;
  Widget? label;
  EdgeInsetsGeometry? labelPadding;
  TextStyle? labelStyle;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  VoidCallback? onDeleted;
  ValueChanged<bool>? onSelected;
  EdgeInsetsGeometry? padding;
  double? pressElevation;
  bool? selected;
  Color? selectedColor;
  Color? selectedShadowColor;
  Color? shadowColor;
  OutlinedBorder? shape;
  bool? showCheckmark;
  BorderSide? side;
  Color? surfaceTintColor;
  String? tooltip;
  VisualDensity? visualDensity;
}

FilterChip _buildGeneratedFilterChipTagWidget(_GeneratedFilterChipTagConfig config, List<Widget> children) {
  return FilterChip(
    autofocus: config.autofocus ?? false,
    avatar: config.avatar,
    avatarBorder: config.avatarBorder ?? const CircleBorder(),
    avatarBoxConstraints: config.avatarBoxConstraints,
    backgroundColor: config.backgroundColor,
    checkmarkColor: config.checkmarkColor,
    chipAnimationStyle: config.chipAnimationStyle,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    deleteButtonTooltipMessage: config.deleteButtonTooltipMessage,
    deleteIcon: config.deleteIcon,
    deleteIconBoxConstraints: config.deleteIconBoxConstraints,
    deleteIconColor: config.deleteIconColor,
    disabledColor: config.disabledColor,
    elevation: config.elevation,
    focusNode: config.focusNode,
    iconTheme: config.iconTheme,
    key: config.key,
    label: config.label!,
    labelPadding: config.labelPadding,
    labelStyle: config.labelStyle,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onDeleted: config.onDeleted,
    onSelected: config.onSelected,
    padding: config.padding,
    pressElevation: config.pressElevation,
    selected: config.selected ?? false,
    selectedColor: config.selectedColor,
    selectedShadowColor: config.selectedShadowColor,
    shadowColor: config.shadowColor,
    shape: config.shape,
    showCheckmark: config.showCheckmark,
    side: config.side,
    surfaceTintColor: config.surfaceTintColor,
    tooltip: config.tooltip,
    visualDensity: config.visualDensity,
  );
}


class GeneratedFittedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFittedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFittedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFittedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('fitted_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endfitted_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'fitted_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFittedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFittedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'fit':
          config.fit = parseGeneratedBoxFit(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('fitted_box', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedFittedBoxTagConfig {
  AlignmentGeometry? alignment;
  Clip? clipBehavior;
  BoxFit? fit;
  Key? key;
}

FittedBox _buildGeneratedFittedBoxTagWidget(_GeneratedFittedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return FittedBox(
    alignment: config.alignment ?? Alignment.center,
    clipBehavior: config.clipBehavior ?? Clip.none,
    fit: config.fit ?? BoxFit.contain,
    key: config.key,
    child: child,
  );
}


class GeneratedFlexTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFlexTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFlexTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFlexTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('flex').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endflex').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'flex',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFlexTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFlexTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'crossAxisAlignment':
          config.crossAxisAlignment = parseGeneratedCrossAxisAlignment(value);
          break;
        case 'direction':
          config.direction = parseGeneratedAxis(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'mainAxisAlignment':
          config.mainAxisAlignment = parseGeneratedMainAxisAlignment(value);
          break;
        case 'mainAxisSize':
          config.mainAxisSize = parseGeneratedMainAxisSize(value);
          break;
        case 'spacing':
          config.spacing = toDouble(value);
          break;
        case 'textBaseline':
          config.textBaseline = parseGeneratedTextBaseline(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'verticalDirection':
          config.verticalDirection = parseGeneratedVerticalDirection(value);
          break;
        default:
          handleUnknownArg('flex', name);
          break;
      }
    }
    if (config.direction == null) {
      throw Exception('flex tag requires "direction"');
    }
    return config;
  }
}

class _GeneratedFlexTagConfig {
  Clip? clipBehavior;
  CrossAxisAlignment? crossAxisAlignment;
  Axis? direction;
  Key? key;
  MainAxisAlignment? mainAxisAlignment;
  MainAxisSize? mainAxisSize;
  double? spacing;
  TextBaseline? textBaseline;
  TextDirection? textDirection;
  VerticalDirection? verticalDirection;
}

Flex _buildGeneratedFlexTagWidget(_GeneratedFlexTagConfig config, List<Widget> children) {
  return Flex(
    clipBehavior: config.clipBehavior ?? Clip.none,
    crossAxisAlignment: config.crossAxisAlignment ?? CrossAxisAlignment.center,
    direction: config.direction!,
    key: config.key,
    mainAxisAlignment: config.mainAxisAlignment ?? MainAxisAlignment.start,
    mainAxisSize: config.mainAxisSize ?? MainAxisSize.max,
    spacing: config.spacing ?? 0.0,
    textBaseline: config.textBaseline,
    textDirection: config.textDirection,
    verticalDirection: config.verticalDirection ?? VerticalDirection.down,
    children: children,
  );
}


class GeneratedFlexibleTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFlexibleTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFlexibleTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFlexibleTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('flexible').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endflexible').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'flexible',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFlexibleTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFlexibleTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'fit':
          config.fit = parseGeneratedFlexFit(value);
          break;
        case 'flex':
          config.flex = toInt(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('flexible', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedFlexibleTagConfig {
  FlexFit? fit;
  int? flex;
  Key? key;
}

Flexible _buildGeneratedFlexibleTagWidget(_GeneratedFlexibleTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return Flexible(
    fit: config.fit ?? FlexFit.loose,
    flex: config.flex ?? 1,
    key: config.key,
    child: child,
  );
}


class GeneratedFloatingActionButtonTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFloatingActionButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFloatingActionButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFloatingActionButtonTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('floating_action_button').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endfloating_action_button').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'floating_action_button',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFloatingActionButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFloatingActionButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'disabledElevation':
          config.disabledElevation = toDouble(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'focusColor':
          config.focusColor = parseGeneratedColor(value);
          break;
        case 'focusElevation':
          config.focusElevation = toDouble(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'foregroundColor':
          config.foregroundColor = parseGeneratedColor(value);
          break;
        case 'heroTag':
          config.heroTag = parseGeneratedObject(evaluator, value);
          break;
        case 'highlightElevation':
          config.highlightElevation = toDouble(value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'hoverElevation':
          config.hoverElevation = toDouble(value);
          break;
        case 'isExtended':
          config.isExtended = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mini':
          config.mini = toBool(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'splashColor':
          config.splashColor = parseGeneratedColor(value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        default:
          handleUnknownArg('floating_action_button', name);
          break;
      }
    }
    if (config.onPressed == null) {
      throw Exception('floating_action_button tag requires "onPressed"');
    }
    return config;
  }
}

class _GeneratedFloatingActionButtonTagConfig {
  bool? autofocus;
  Color? backgroundColor;
  Clip? clipBehavior;
  double? disabledElevation;
  double? elevation;
  bool? enableFeedback;
  Color? focusColor;
  double? focusElevation;
  FocusNode? focusNode;
  Color? foregroundColor;
  Object? heroTag;
  double? highlightElevation;
  Color? hoverColor;
  double? hoverElevation;
  bool? isExtended;
  Key? key;
  MaterialTapTargetSize? materialTapTargetSize;
  bool? mini;
  MouseCursor? mouseCursor;
  VoidCallback? onPressed;
  ShapeBorder? shape;
  Color? splashColor;
  String? tooltip;
}

FloatingActionButton _buildGeneratedFloatingActionButtonTagWidget(_GeneratedFloatingActionButtonTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return FloatingActionButton(
    autofocus: config.autofocus ?? false,
    backgroundColor: config.backgroundColor,
    clipBehavior: config.clipBehavior ?? Clip.none,
    disabledElevation: config.disabledElevation,
    elevation: config.elevation,
    enableFeedback: config.enableFeedback,
    focusColor: config.focusColor,
    focusElevation: config.focusElevation,
    focusNode: config.focusNode,
    foregroundColor: config.foregroundColor,
    heroTag: config.heroTag,
    highlightElevation: config.highlightElevation,
    hoverColor: config.hoverColor,
    hoverElevation: config.hoverElevation,
    isExtended: config.isExtended ?? false,
    key: config.key,
    materialTapTargetSize: config.materialTapTargetSize,
    mini: config.mini ?? false,
    mouseCursor: config.mouseCursor,
    onPressed: config.onPressed,
    shape: config.shape,
    splashColor: config.splashColor,
    tooltip: config.tooltip,
    child: child,
  );
}


class GeneratedFormTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFormTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFormTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFormTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('form').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endform').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'form',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFormTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFormTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autovalidateMode':
          config.autovalidateMode = parseGeneratedAutovalidateMode(value);
          break;
        case 'canPop':
          config.canPop = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onChanged':
          config.onChanged = resolveActionCallback(evaluator, value);
          break;
        case 'onPopInvoked':
          config.onPopInvoked = resolveBoolActionCallback(evaluator, value);
          break;
        case 'onPopInvokedWithResult':
          config.onPopInvokedWithResult = (value is PopInvokedWithResultCallback<Object?> ? value : resolveGenericActionCallback2(evaluator, value) as PopInvokedWithResultCallback<Object?>?);
          break;
        case 'onWillPop':
          config.onWillPop = (value is WillPopCallback ? value : resolveFutureBoolCallback0(evaluator, value) as WillPopCallback?);
          break;
        default:
          handleUnknownArg('form', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedFormTagConfig {
  AutovalidateMode? autovalidateMode;
  bool? canPop;
  Key? key;
  VoidCallback? onChanged;
  PopInvokedCallback? onPopInvoked;
  PopInvokedWithResultCallback<Object?>? onPopInvokedWithResult;
  WillPopCallback? onWillPop;
}

Form _buildGeneratedFormTagWidget(_GeneratedFormTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return Form(
    autovalidateMode: config.autovalidateMode,
    canPop: config.canPop,
    key: config.key,
    onChanged: config.onChanged,
    onPopInvoked: config.onPopInvoked,
    onPopInvokedWithResult: config.onPopInvokedWithResult,
    onWillPop: config.onWillPop,
    child: child,
  );
}


class GeneratedFormFieldTag extends WidgetTagBase with AsyncTag {
  GeneratedFormFieldTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedFormFieldTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedFormFieldTagWidget(config, children));
  }

  _GeneratedFormFieldTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFormFieldTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autovalidateMode':
          config.autovalidateMode = parseGeneratedAutovalidateMode(value);
          break;
        case 'builder':
          config.builder = (value is FormFieldBuilder<Object?> ? value : resolveGenericCallback1(evaluator, value) as FormFieldBuilder<Object?>?);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'errorBuilder':
          config.errorBuilder = (value is FormFieldErrorBuilder ? value : resolveWidgetBuilder2Callback(evaluator, value) as FormFieldErrorBuilder?);
          break;
        case 'forceErrorText':
          config.forceErrorText = toStringValue(value);
          break;
        case 'initialValue':
          config.initialValue = parseGeneratedObject(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onReset':
          config.onReset = resolveActionCallback(evaluator, value);
          break;
        case 'onSaved':
          config.onSaved = (value is FormFieldSetter<Object?> ? value : resolveGenericValueChanged(evaluator, value) as FormFieldSetter<Object?>?);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'validator':
          config.validator = (value is FormFieldValidator<Object?> ? value : resolveGenericCallback1(evaluator, value) as FormFieldValidator<Object?>?);
          break;
        default:
          handleUnknownArg('form_field', name);
          break;
      }
    }
    if (config.builder == null) {
      throw Exception('form_field tag requires "builder"');
    }
    return config;
  }
}

class _GeneratedFormFieldTagConfig {
  AutovalidateMode? autovalidateMode;
  FormFieldBuilder<Object?>? builder;
  bool? enabled;
  FormFieldErrorBuilder? errorBuilder;
  String? forceErrorText;
  Object? initialValue;
  Key? key;
  VoidCallback? onReset;
  FormFieldSetter<Object?>? onSaved;
  String? restorationId;
  FormFieldValidator<Object?>? validator;
}

FormField _buildGeneratedFormFieldTagWidget(_GeneratedFormFieldTagConfig config, List<Widget> children) {
  return FormField(
    autovalidateMode: config.autovalidateMode,
    builder: config.builder!,
    enabled: config.enabled ?? true,
    errorBuilder: config.errorBuilder,
    forceErrorText: config.forceErrorText,
    initialValue: config.initialValue,
    key: config.key,
    onReset: config.onReset,
    onSaved: config.onSaved,
    restorationId: config.restorationId,
    validator: config.validator,
  );
}


class GeneratedFractionalTranslationTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFractionalTranslationTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFractionalTranslationTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFractionalTranslationTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('fractional_translation').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endfractional_translation').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'fractional_translation',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFractionalTranslationTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFractionalTranslationTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'transformHitTests':
          config.transformHitTests = toBool(value);
          break;
        case 'translation':
          config.translation = parseGeneratedOffset(value);
          break;
        default:
          handleUnknownArg('fractional_translation', name);
          break;
      }
    }
    if (config.translation == null) {
      throw Exception('fractional_translation tag requires "translation"');
    }
    return config;
  }
}

class _GeneratedFractionalTranslationTagConfig {
  Key? key;
  bool? transformHitTests;
  Offset? translation;
}

FractionalTranslation _buildGeneratedFractionalTranslationTagWidget(_GeneratedFractionalTranslationTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return FractionalTranslation(
    key: config.key,
    transformHitTests: config.transformHitTests ?? true,
    translation: config.translation!,
    child: child,
  );
}


class GeneratedFractionallySizedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedFractionallySizedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedFractionallySizedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedFractionallySizedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('fractionally_sized_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endfractionally_sized_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'fractionally_sized_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedFractionallySizedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedFractionallySizedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'heightFactor':
          config.heightFactor = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'widthFactor':
          config.widthFactor = toDouble(value);
          break;
        default:
          handleUnknownArg('fractionally_sized_box', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedFractionallySizedBoxTagConfig {
  AlignmentGeometry? alignment;
  double? heightFactor;
  Key? key;
  double? widthFactor;
}

FractionallySizedBox _buildGeneratedFractionallySizedBoxTagWidget(_GeneratedFractionallySizedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return FractionallySizedBox(
    alignment: config.alignment ?? Alignment.center,
    heightFactor: config.heightFactor,
    key: config.key,
    widthFactor: config.widthFactor,
    child: child,
  );
}


class GeneratedGestureDetectorTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedGestureDetectorTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedGestureDetectorTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedGestureDetectorTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('gesture_detector').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endgesture_detector').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'gesture_detector',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedGestureDetectorTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedGestureDetectorTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'behavior':
          config.behavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'excludeFromSemantics':
          config.excludeFromSemantics = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onDoubleTap':
          config.onDoubleTap = resolveActionCallback(evaluator, value);
          break;
        case 'onDoubleTapCancel':
          config.onDoubleTapCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onDoubleTapDown':
          config.onDoubleTapDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onForcePressEnd':
          config.onForcePressEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onForcePressPeak':
          config.onForcePressPeak = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onForcePressStart':
          config.onForcePressStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onForcePressUpdate':
          config.onForcePressUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onHorizontalDragCancel':
          config.onHorizontalDragCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onHorizontalDragDown':
          config.onHorizontalDragDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onHorizontalDragEnd':
          config.onHorizontalDragEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onHorizontalDragStart':
          config.onHorizontalDragStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onHorizontalDragUpdate':
          config.onHorizontalDragUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onLongPress':
          config.onLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onLongPressCancel':
          config.onLongPressCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onLongPressDown':
          config.onLongPressDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onLongPressEnd':
          config.onLongPressEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onLongPressMoveUpdate':
          config.onLongPressMoveUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onLongPressStart':
          config.onLongPressStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onLongPressUp':
          config.onLongPressUp = resolveActionCallback(evaluator, value);
          break;
        case 'onPanCancel':
          config.onPanCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onPanDown':
          config.onPanDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPanEnd':
          config.onPanEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPanStart':
          config.onPanStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPanUpdate':
          config.onPanUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onScaleEnd':
          config.onScaleEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onScaleStart':
          config.onScaleStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onScaleUpdate':
          config.onScaleUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onSecondaryLongPress':
          config.onSecondaryLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onSecondaryLongPressCancel':
          config.onSecondaryLongPressCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onSecondaryLongPressDown':
          config.onSecondaryLongPressDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onSecondaryLongPressEnd':
          config.onSecondaryLongPressEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onSecondaryLongPressMoveUpdate':
          config.onSecondaryLongPressMoveUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onSecondaryLongPressStart':
          config.onSecondaryLongPressStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onSecondaryLongPressUp':
          config.onSecondaryLongPressUp = resolveActionCallback(evaluator, value);
          break;
        case 'onSecondaryTap':
          config.onSecondaryTap = resolveActionCallback(evaluator, value);
          break;
        case 'onSecondaryTapCancel':
          config.onSecondaryTapCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onSecondaryTapDown':
          config.onSecondaryTapDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onSecondaryTapUp':
          config.onSecondaryTapUp = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTap':
          config.onTap = resolveActionCallback(evaluator, value);
          break;
        case 'onTapCancel':
          config.onTapCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onTapDown':
          config.onTapDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTapMove':
          config.onTapMove = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTapUp':
          config.onTapUp = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTertiaryLongPress':
          config.onTertiaryLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onTertiaryLongPressCancel':
          config.onTertiaryLongPressCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onTertiaryLongPressDown':
          config.onTertiaryLongPressDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTertiaryLongPressEnd':
          config.onTertiaryLongPressEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTertiaryLongPressMoveUpdate':
          config.onTertiaryLongPressMoveUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTertiaryLongPressStart':
          config.onTertiaryLongPressStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTertiaryLongPressUp':
          config.onTertiaryLongPressUp = resolveActionCallback(evaluator, value);
          break;
        case 'onTertiaryTapCancel':
          config.onTertiaryTapCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onTertiaryTapDown':
          config.onTertiaryTapDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTertiaryTapUp':
          config.onTertiaryTapUp = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onVerticalDragCancel':
          config.onVerticalDragCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onVerticalDragDown':
          config.onVerticalDragDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onVerticalDragEnd':
          config.onVerticalDragEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onVerticalDragStart':
          config.onVerticalDragStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onVerticalDragUpdate':
          config.onVerticalDragUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'supportedDevices':
          config.supportedDevices = parseGeneratedSetOfPointerDeviceKind(value);
          break;
        case 'trackpadScrollCausesScale':
          config.trackpadScrollCausesScale = toBool(value);
          break;
        case 'trackpadScrollToScaleFactor':
          config.trackpadScrollToScaleFactor = parseGeneratedOffset(value);
          break;
        default:
          handleUnknownArg('gesture_detector', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedGestureDetectorTagConfig {
  HitTestBehavior? behavior;
  DragStartBehavior? dragStartBehavior;
  bool? excludeFromSemantics;
  Key? key;
  GestureTapCallback? onDoubleTap;
  GestureTapCancelCallback? onDoubleTapCancel;
  GestureTapDownCallback? onDoubleTapDown;
  GestureForcePressEndCallback? onForcePressEnd;
  GestureForcePressPeakCallback? onForcePressPeak;
  GestureForcePressStartCallback? onForcePressStart;
  GestureForcePressUpdateCallback? onForcePressUpdate;
  GestureDragCancelCallback? onHorizontalDragCancel;
  GestureDragDownCallback? onHorizontalDragDown;
  GestureDragEndCallback? onHorizontalDragEnd;
  GestureDragStartCallback? onHorizontalDragStart;
  GestureDragUpdateCallback? onHorizontalDragUpdate;
  GestureLongPressCallback? onLongPress;
  GestureLongPressCancelCallback? onLongPressCancel;
  GestureLongPressDownCallback? onLongPressDown;
  GestureLongPressEndCallback? onLongPressEnd;
  GestureLongPressMoveUpdateCallback? onLongPressMoveUpdate;
  GestureLongPressStartCallback? onLongPressStart;
  GestureLongPressUpCallback? onLongPressUp;
  GestureDragCancelCallback? onPanCancel;
  GestureDragDownCallback? onPanDown;
  GestureDragEndCallback? onPanEnd;
  GestureDragStartCallback? onPanStart;
  GestureDragUpdateCallback? onPanUpdate;
  GestureScaleEndCallback? onScaleEnd;
  GestureScaleStartCallback? onScaleStart;
  GestureScaleUpdateCallback? onScaleUpdate;
  GestureLongPressCallback? onSecondaryLongPress;
  GestureLongPressCancelCallback? onSecondaryLongPressCancel;
  GestureLongPressDownCallback? onSecondaryLongPressDown;
  GestureLongPressEndCallback? onSecondaryLongPressEnd;
  GestureLongPressMoveUpdateCallback? onSecondaryLongPressMoveUpdate;
  GestureLongPressStartCallback? onSecondaryLongPressStart;
  GestureLongPressUpCallback? onSecondaryLongPressUp;
  GestureTapCallback? onSecondaryTap;
  GestureTapCancelCallback? onSecondaryTapCancel;
  GestureTapDownCallback? onSecondaryTapDown;
  GestureTapUpCallback? onSecondaryTapUp;
  GestureTapCallback? onTap;
  GestureTapCancelCallback? onTapCancel;
  GestureTapDownCallback? onTapDown;
  GestureTapMoveCallback? onTapMove;
  GestureTapUpCallback? onTapUp;
  GestureLongPressCallback? onTertiaryLongPress;
  GestureLongPressCancelCallback? onTertiaryLongPressCancel;
  GestureLongPressDownCallback? onTertiaryLongPressDown;
  GestureLongPressEndCallback? onTertiaryLongPressEnd;
  GestureLongPressMoveUpdateCallback? onTertiaryLongPressMoveUpdate;
  GestureLongPressStartCallback? onTertiaryLongPressStart;
  GestureLongPressUpCallback? onTertiaryLongPressUp;
  GestureTapCancelCallback? onTertiaryTapCancel;
  GestureTapDownCallback? onTertiaryTapDown;
  GestureTapUpCallback? onTertiaryTapUp;
  GestureDragCancelCallback? onVerticalDragCancel;
  GestureDragDownCallback? onVerticalDragDown;
  GestureDragEndCallback? onVerticalDragEnd;
  GestureDragStartCallback? onVerticalDragStart;
  GestureDragUpdateCallback? onVerticalDragUpdate;
  Set<PointerDeviceKind>? supportedDevices;
  bool? trackpadScrollCausesScale;
  Offset? trackpadScrollToScaleFactor;
}

GestureDetector _buildGeneratedGestureDetectorTagWidget(_GeneratedGestureDetectorTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return GestureDetector(
    behavior: config.behavior,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    excludeFromSemantics: config.excludeFromSemantics ?? false,
    key: config.key,
    onDoubleTap: config.onDoubleTap,
    onDoubleTapCancel: config.onDoubleTapCancel,
    onDoubleTapDown: config.onDoubleTapDown,
    onForcePressEnd: config.onForcePressEnd,
    onForcePressPeak: config.onForcePressPeak,
    onForcePressStart: config.onForcePressStart,
    onForcePressUpdate: config.onForcePressUpdate,
    onHorizontalDragCancel: config.onHorizontalDragCancel,
    onHorizontalDragDown: config.onHorizontalDragDown,
    onHorizontalDragEnd: config.onHorizontalDragEnd,
    onHorizontalDragStart: config.onHorizontalDragStart,
    onHorizontalDragUpdate: config.onHorizontalDragUpdate,
    onLongPress: config.onLongPress,
    onLongPressCancel: config.onLongPressCancel,
    onLongPressDown: config.onLongPressDown,
    onLongPressEnd: config.onLongPressEnd,
    onLongPressMoveUpdate: config.onLongPressMoveUpdate,
    onLongPressStart: config.onLongPressStart,
    onLongPressUp: config.onLongPressUp,
    onPanCancel: config.onPanCancel,
    onPanDown: config.onPanDown,
    onPanEnd: config.onPanEnd,
    onPanStart: config.onPanStart,
    onPanUpdate: config.onPanUpdate,
    onScaleEnd: config.onScaleEnd,
    onScaleStart: config.onScaleStart,
    onScaleUpdate: config.onScaleUpdate,
    onSecondaryLongPress: config.onSecondaryLongPress,
    onSecondaryLongPressCancel: config.onSecondaryLongPressCancel,
    onSecondaryLongPressDown: config.onSecondaryLongPressDown,
    onSecondaryLongPressEnd: config.onSecondaryLongPressEnd,
    onSecondaryLongPressMoveUpdate: config.onSecondaryLongPressMoveUpdate,
    onSecondaryLongPressStart: config.onSecondaryLongPressStart,
    onSecondaryLongPressUp: config.onSecondaryLongPressUp,
    onSecondaryTap: config.onSecondaryTap,
    onSecondaryTapCancel: config.onSecondaryTapCancel,
    onSecondaryTapDown: config.onSecondaryTapDown,
    onSecondaryTapUp: config.onSecondaryTapUp,
    onTap: config.onTap,
    onTapCancel: config.onTapCancel,
    onTapDown: config.onTapDown,
    onTapMove: config.onTapMove,
    onTapUp: config.onTapUp,
    onTertiaryLongPress: config.onTertiaryLongPress,
    onTertiaryLongPressCancel: config.onTertiaryLongPressCancel,
    onTertiaryLongPressDown: config.onTertiaryLongPressDown,
    onTertiaryLongPressEnd: config.onTertiaryLongPressEnd,
    onTertiaryLongPressMoveUpdate: config.onTertiaryLongPressMoveUpdate,
    onTertiaryLongPressStart: config.onTertiaryLongPressStart,
    onTertiaryLongPressUp: config.onTertiaryLongPressUp,
    onTertiaryTapCancel: config.onTertiaryTapCancel,
    onTertiaryTapDown: config.onTertiaryTapDown,
    onTertiaryTapUp: config.onTertiaryTapUp,
    onVerticalDragCancel: config.onVerticalDragCancel,
    onVerticalDragDown: config.onVerticalDragDown,
    onVerticalDragEnd: config.onVerticalDragEnd,
    onVerticalDragStart: config.onVerticalDragStart,
    onVerticalDragUpdate: config.onVerticalDragUpdate,
    supportedDevices: config.supportedDevices,
    trackpadScrollCausesScale: config.trackpadScrollCausesScale ?? false,
    trackpadScrollToScaleFactor: config.trackpadScrollToScaleFactor ?? kDefaultTrackpadScrollToScaleFactor,
    child: child,
  );
}


class GeneratedGridViewTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedGridViewTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedGridViewTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedGridViewTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('grid_view').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endgrid_view').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'grid_view',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedGridViewTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedGridViewTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'addAutomaticKeepAlives':
          config.addAutomaticKeepAlives = toBool(value);
          break;
        case 'addRepaintBoundaries':
          config.addRepaintBoundaries = toBool(value);
          break;
        case 'addSemanticIndexes':
          config.addSemanticIndexes = toBool(value);
          break;
        case 'cacheExtent':
          config.cacheExtent = toDouble(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'controller':
          config.controller = parseGeneratedScrollController(evaluator, value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'gridDelegate':
          config.gridDelegate = parseGeneratedSliverGridDelegate(value);
          break;
        case 'hitTestBehavior':
          config.hitTestBehavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardDismissBehavior':
          config.keyboardDismissBehavior = parseGeneratedScrollViewKeyboardDismissBehavior(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'reverse':
          config.reverse = toBool(value);
          break;
        case 'scrollDirection':
          config.scrollDirection = parseGeneratedAxis(value);
          break;
        case 'semanticChildCount':
          config.semanticChildCount = toInt(value);
          break;
        case 'shrinkWrap':
          config.shrinkWrap = toBool(value);
          break;
        default:
          handleUnknownArg('grid_view', name);
          break;
      }
    }
    if (config.gridDelegate == null) {
      throw Exception('grid_view tag requires "gridDelegate"');
    }
    return config;
  }
}

class _GeneratedGridViewTagConfig {
  bool? addAutomaticKeepAlives;
  bool? addRepaintBoundaries;
  bool? addSemanticIndexes;
  double? cacheExtent;
  Clip? clipBehavior;
  ScrollController? controller;
  DragStartBehavior? dragStartBehavior;
  SliverGridDelegate? gridDelegate;
  HitTestBehavior? hitTestBehavior;
  Key? key;
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
  EdgeInsetsGeometry? padding;
  ScrollPhysics? physics;
  bool? primary;
  String? restorationId;
  bool? reverse;
  Axis? scrollDirection;
  int? semanticChildCount;
  bool? shrinkWrap;
}

GridView _buildGeneratedGridViewTagWidget(_GeneratedGridViewTagConfig config, List<Widget> children) {
  return GridView(
    addAutomaticKeepAlives: config.addAutomaticKeepAlives ?? true,
    addRepaintBoundaries: config.addRepaintBoundaries ?? true,
    addSemanticIndexes: config.addSemanticIndexes ?? true,
    cacheExtent: config.cacheExtent,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    controller: config.controller,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    gridDelegate: config.gridDelegate!,
    hitTestBehavior: config.hitTestBehavior ?? HitTestBehavior.opaque,
    key: config.key,
    keyboardDismissBehavior: config.keyboardDismissBehavior,
    padding: config.padding,
    physics: config.physics,
    primary: config.primary,
    restorationId: config.restorationId,
    reverse: config.reverse ?? false,
    scrollDirection: config.scrollDirection ?? Axis.vertical,
    semanticChildCount: config.semanticChildCount,
    shrinkWrap: config.shrinkWrap ?? false,
    children: children,
  );
}


class GeneratedHeroTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedHeroTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedHeroTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedHeroTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('hero').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endhero').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'hero',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedHeroTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedHeroTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'createRectTween':
          config.createRectTween = (value is CreateRectTween ? value : resolveGenericCallback2(evaluator, value) as CreateRectTween?);
          break;
        case 'flightShuttleBuilder':
          config.flightShuttleBuilder = (value is HeroFlightShuttleBuilder ? value : resolveCallbackValue(evaluator, value) as HeroFlightShuttleBuilder?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'placeholderBuilder':
          config.placeholderBuilder = (value is HeroPlaceholderBuilder ? value : resolveCallbackValue(evaluator, value) as HeroPlaceholderBuilder?);
          break;
        case 'tag':
          config.tag = parseGeneratedObject(evaluator, value);
          break;
        case 'transitionOnUserGestures':
          config.transitionOnUserGestures = toBool(value);
          break;
        default:
          handleUnknownArg('hero', name);
          break;
      }
    }
    if (config.tag == null) {
      throw Exception('hero tag requires "tag"');
    }
    return config;
  }
}

class _GeneratedHeroTagConfig {
  CreateRectTween? createRectTween;
  HeroFlightShuttleBuilder? flightShuttleBuilder;
  Key? key;
  HeroPlaceholderBuilder? placeholderBuilder;
  Object? tag;
  bool? transitionOnUserGestures;
}

Hero _buildGeneratedHeroTagWidget(_GeneratedHeroTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return Hero(
    createRectTween: config.createRectTween,
    flightShuttleBuilder: config.flightShuttleBuilder,
    key: config.key,
    placeholderBuilder: config.placeholderBuilder,
    tag: config.tag!,
    transitionOnUserGestures: config.transitionOnUserGestures ?? false,
    child: child,
  );
}


class GeneratedIconTag extends WidgetTagBase with AsyncTag {
  GeneratedIconTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedIconTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedIconTagWidget(config, children));
  }

  _GeneratedIconTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedIconTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'applyTextScaling':
          config.applyTextScaling = toBool(value);
          break;
        case 'blendMode':
          config.blendMode = parseGeneratedBlendMode(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'fill':
          config.fill = toDouble(value);
          break;
        case 'fontWeight':
          config.fontWeight = parseGeneratedFontWeight(value);
          break;
        case 'grade':
          config.grade = toDouble(value);
          break;
        case 'icon':
          config.icon = parseGeneratedIconData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'opticalSize':
          config.opticalSize = toDouble(value);
          break;
        case 'semanticLabel':
          config.semanticLabel = toStringValue(value);
          break;
        case 'shadows':
          config.shadows = parseGeneratedListOfShadow(value);
          break;
        case 'size':
          config.size = toDouble(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'weight':
          config.weight = toDouble(value);
          break;
        default:
          handleUnknownArg('icon', name);
          break;
      }
    }
    if (config.icon == null) {
      throw Exception('icon tag requires "icon"');
    }
    return config;
  }
}

class _GeneratedIconTagConfig {
  bool? applyTextScaling;
  BlendMode? blendMode;
  Color? color;
  double? fill;
  FontWeight? fontWeight;
  double? grade;
  IconData? icon;
  Key? key;
  double? opticalSize;
  String? semanticLabel;
  List<Shadow>? shadows;
  double? size;
  TextDirection? textDirection;
  double? weight;
}

Icon _buildGeneratedIconTagWidget(_GeneratedIconTagConfig config, List<Widget> children) {
  return Icon(
    config.icon,
    applyTextScaling: config.applyTextScaling,
    blendMode: config.blendMode,
    color: config.color,
    fill: config.fill,
    fontWeight: config.fontWeight,
    grade: config.grade,
    key: config.key,
    opticalSize: config.opticalSize,
    semanticLabel: config.semanticLabel,
    shadows: config.shadows,
    size: config.size,
    textDirection: config.textDirection,
    weight: config.weight,
  );
}


class GeneratedIconButtonTag extends WidgetTagBase with AsyncTag {
  GeneratedIconButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedIconButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedIconButtonTagWidget(config, children));
  }

  _GeneratedIconButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedIconButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'disabledColor':
          config.disabledColor = parseGeneratedColor(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'focusColor':
          config.focusColor = parseGeneratedColor(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'highlightColor':
          config.highlightColor = parseGeneratedColor(value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'iconSize':
          config.iconSize = toDouble(value);
          break;
        case 'isSelected':
          config.isSelected = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onHover':
          config.onHover = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onLongPress':
          config.onLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'selectedIcon':
          config.selectedIcon = resolveWidget(value);
          break;
        case 'splashColor':
          config.splashColor = parseGeneratedColor(value);
          break;
        case 'splashRadius':
          config.splashRadius = toDouble(value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'style':
          config.style = parseGeneratedButtonStyle(evaluator, value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('icon_button', name);
          break;
      }
    }
    if (config.icon == null) {
      throw Exception('icon_button tag requires "icon"');
    }
    if (config.onPressed == null) {
      throw Exception('icon_button tag requires "onPressed"');
    }
    return config;
  }
}

class _GeneratedIconButtonTagConfig {
  AlignmentGeometry? alignment;
  bool? autofocus;
  Color? color;
  BoxConstraints? constraints;
  Color? disabledColor;
  bool? enableFeedback;
  Color? focusColor;
  FocusNode? focusNode;
  Color? highlightColor;
  Color? hoverColor;
  Widget? icon;
  double? iconSize;
  bool? isSelected;
  Key? key;
  MouseCursor? mouseCursor;
  ValueChanged<bool>? onHover;
  VoidCallback? onLongPress;
  VoidCallback? onPressed;
  EdgeInsetsGeometry? padding;
  Widget? selectedIcon;
  Color? splashColor;
  double? splashRadius;
  MaterialStatesController? statesController;
  ButtonStyle? style;
  String? tooltip;
  VisualDensity? visualDensity;
}

IconButton _buildGeneratedIconButtonTagWidget(_GeneratedIconButtonTagConfig config, List<Widget> children) {
  return IconButton(
    alignment: config.alignment,
    autofocus: config.autofocus ?? false,
    color: config.color,
    constraints: config.constraints,
    disabledColor: config.disabledColor,
    enableFeedback: config.enableFeedback,
    focusColor: config.focusColor,
    focusNode: config.focusNode,
    highlightColor: config.highlightColor,
    hoverColor: config.hoverColor,
    icon: config.icon!,
    iconSize: config.iconSize,
    isSelected: config.isSelected,
    key: config.key,
    mouseCursor: config.mouseCursor,
    onHover: config.onHover,
    onLongPress: config.onLongPress,
    onPressed: config.onPressed,
    padding: config.padding,
    selectedIcon: config.selectedIcon,
    splashColor: config.splashColor,
    splashRadius: config.splashRadius,
    statesController: config.statesController,
    style: config.style,
    tooltip: config.tooltip,
    visualDensity: config.visualDensity,
  );
}


class GeneratedIconThemeTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedIconThemeTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedIconThemeTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedIconThemeTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('icon_theme').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endicon_theme').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'icon_theme',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedIconThemeTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedIconThemeTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'data':
          config.data = parseGeneratedIconThemeData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('icon_theme', name);
          break;
      }
    }
    if (config.data == null) {
      throw Exception('icon_theme tag requires "data"');
    }
    return config;
  }
}

class _GeneratedIconThemeTagConfig {
  IconThemeData? data;
  Key? key;
}

IconTheme _buildGeneratedIconThemeTagWidget(_GeneratedIconThemeTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return IconTheme(
    data: config.data!,
    key: config.key,
    child: child,
  );
}


class GeneratedIgnorePointerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedIgnorePointerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedIgnorePointerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedIgnorePointerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('ignore_pointer').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endignore_pointer').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'ignore_pointer',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedIgnorePointerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedIgnorePointerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'ignoring':
          config.ignoring = toBool(value);
          break;
        case 'ignoringSemantics':
          config.ignoringSemantics = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('ignore_pointer', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedIgnorePointerTagConfig {
  bool? ignoring;
  bool? ignoringSemantics;
  Key? key;
}

IgnorePointer _buildGeneratedIgnorePointerTagWidget(_GeneratedIgnorePointerTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return IgnorePointer(
    ignoring: config.ignoring ?? true,
    ignoringSemantics: config.ignoringSemantics,
    key: config.key,
    child: child,
  );
}


class GeneratedImageTag extends WidgetTagBase with AsyncTag {
  GeneratedImageTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedImageTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedImageTagWidget(config, children));
  }

  _GeneratedImageTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedImageTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'centerSlice':
          config.centerSlice = parseGeneratedRect(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'colorBlendMode':
          config.colorBlendMode = parseGeneratedBlendMode(value);
          break;
        case 'errorBuilder':
          config.errorBuilder = (value is ImageErrorWidgetBuilder ? value : resolveCallbackValue(evaluator, value) as ImageErrorWidgetBuilder?);
          break;
        case 'excludeFromSemantics':
          config.excludeFromSemantics = toBool(value);
          break;
        case 'filterQuality':
          config.filterQuality = parseGeneratedFilterQuality(value);
          break;
        case 'fit':
          config.fit = parseGeneratedBoxFit(value);
          break;
        case 'frameBuilder':
          config.frameBuilder = (value is ImageFrameBuilder ? value : resolveCallbackValue(evaluator, value) as ImageFrameBuilder?);
          break;
        case 'gaplessPlayback':
          config.gaplessPlayback = toBool(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'image':
          config.image = (value is ImageProvider<Object> ? value : parseGeneratedImageProvider(value) as ImageProvider<Object>?);
          break;
        case 'isAntiAlias':
          config.isAntiAlias = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'loadingBuilder':
          config.loadingBuilder = (value is ImageLoadingBuilder ? value : resolveCallbackValue(evaluator, value) as ImageLoadingBuilder?);
          break;
        case 'matchTextDirection':
          config.matchTextDirection = toBool(value);
          break;
        case 'opacity':
          config.opacity = parseGeneratedAnimationOfDouble(value);
          break;
        case 'repeat':
          config.repeat = parseGeneratedImageRepeat(value);
          break;
        case 'semanticLabel':
          config.semanticLabel = toStringValue(value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('image', name);
          break;
      }
    }
    if (config.image == null) {
      throw Exception('image tag requires "image"');
    }
    return config;
  }
}

class _GeneratedImageTagConfig {
  AlignmentGeometry? alignment;
  Rect? centerSlice;
  Color? color;
  BlendMode? colorBlendMode;
  ImageErrorWidgetBuilder? errorBuilder;
  bool? excludeFromSemantics;
  FilterQuality? filterQuality;
  BoxFit? fit;
  ImageFrameBuilder? frameBuilder;
  bool? gaplessPlayback;
  double? height;
  ImageProvider<Object>? image;
  bool? isAntiAlias;
  Key? key;
  ImageLoadingBuilder? loadingBuilder;
  bool? matchTextDirection;
  Animation<double>? opacity;
  ImageRepeat? repeat;
  String? semanticLabel;
  double? width;
}

Image _buildGeneratedImageTagWidget(_GeneratedImageTagConfig config, List<Widget> children) {
  return Image(
    alignment: config.alignment ?? Alignment.center,
    centerSlice: config.centerSlice,
    color: config.color,
    colorBlendMode: config.colorBlendMode,
    errorBuilder: config.errorBuilder,
    excludeFromSemantics: config.excludeFromSemantics ?? false,
    filterQuality: config.filterQuality ?? FilterQuality.medium,
    fit: config.fit,
    frameBuilder: config.frameBuilder,
    gaplessPlayback: config.gaplessPlayback ?? false,
    height: config.height,
    image: config.image!,
    isAntiAlias: config.isAntiAlias ?? false,
    key: config.key,
    loadingBuilder: config.loadingBuilder,
    matchTextDirection: config.matchTextDirection ?? false,
    opacity: config.opacity,
    repeat: config.repeat ?? ImageRepeat.noRepeat,
    semanticLabel: config.semanticLabel,
    width: config.width,
  );
}


class GeneratedIndexedStackTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedIndexedStackTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedIndexedStackTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedIndexedStackTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('indexed_stack').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endindexed_stack').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'indexed_stack',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedIndexedStackTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedIndexedStackTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'index':
          config.index = toInt(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'sizing':
          config.sizing = parseGeneratedStackFit(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        default:
          handleUnknownArg('indexed_stack', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedIndexedStackTagConfig {
  AlignmentGeometry? alignment;
  Clip? clipBehavior;
  int? index;
  Key? key;
  StackFit? sizing;
  TextDirection? textDirection;
}

IndexedStack _buildGeneratedIndexedStackTagWidget(_GeneratedIndexedStackTagConfig config, List<Widget> children) {
  return IndexedStack(
    alignment: config.alignment ?? AlignmentDirectional.topStart,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    index: config.index ?? 0,
    key: config.key,
    sizing: config.sizing ?? StackFit.loose,
    textDirection: config.textDirection,
    children: children,
  );
}


class GeneratedInputChipTag extends WidgetTagBase with AsyncTag {
  GeneratedInputChipTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedInputChipTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedInputChipTagWidget(config, children));
  }

  _GeneratedInputChipTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedInputChipTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'avatar':
          config.avatar = resolveWidget(value);
          break;
        case 'avatarBorder':
          config.avatarBorder = parseGeneratedShapeBorder(value);
          break;
        case 'avatarBoxConstraints':
          config.avatarBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'checkmarkColor':
          config.checkmarkColor = parseGeneratedColor(value);
          break;
        case 'chipAnimationStyle':
          config.chipAnimationStyle = parseGeneratedChipAnimationStyle(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'deleteButtonTooltipMessage':
          config.deleteButtonTooltipMessage = toStringValue(value);
          break;
        case 'deleteIcon':
          config.deleteIcon = resolveWidget(value);
          break;
        case 'deleteIconBoxConstraints':
          config.deleteIconBoxConstraints = parseGeneratedBoxConstraints(value);
          break;
        case 'deleteIconColor':
          config.deleteIconColor = parseGeneratedColor(value);
          break;
        case 'disabledColor':
          config.disabledColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'iconTheme':
          config.iconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'isEnabled':
          config.isEnabled = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'labelPadding':
          config.labelPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'labelStyle':
          config.labelStyle = parseGeneratedTextStyle(value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onDeleted':
          config.onDeleted = resolveActionCallback(evaluator, value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'onSelected':
          config.onSelected = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'pressElevation':
          config.pressElevation = toDouble(value);
          break;
        case 'selected':
          config.selected = toBool(value);
          break;
        case 'selectedColor':
          config.selectedColor = parseGeneratedColor(value);
          break;
        case 'selectedShadowColor':
          config.selectedShadowColor = parseGeneratedColor(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedOutlinedBorder(value);
          break;
        case 'showCheckmark':
          config.showCheckmark = toBool(value);
          break;
        case 'side':
          config.side = parseGeneratedBorderSide(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('input_chip', name);
          break;
      }
    }
    if (config.label == null) {
      throw Exception('input_chip tag requires "label"');
    }
    return config;
  }
}

class _GeneratedInputChipTagConfig {
  bool? autofocus;
  Widget? avatar;
  ShapeBorder? avatarBorder;
  BoxConstraints? avatarBoxConstraints;
  Color? backgroundColor;
  Color? checkmarkColor;
  ChipAnimationStyle? chipAnimationStyle;
  Clip? clipBehavior;
  WidgetStateProperty<Color?>? color;
  String? deleteButtonTooltipMessage;
  Widget? deleteIcon;
  BoxConstraints? deleteIconBoxConstraints;
  Color? deleteIconColor;
  Color? disabledColor;
  double? elevation;
  FocusNode? focusNode;
  IconThemeData? iconTheme;
  bool? isEnabled;
  Key? key;
  Widget? label;
  EdgeInsetsGeometry? labelPadding;
  TextStyle? labelStyle;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  VoidCallback? onDeleted;
  VoidCallback? onPressed;
  ValueChanged<bool>? onSelected;
  EdgeInsetsGeometry? padding;
  double? pressElevation;
  bool? selected;
  Color? selectedColor;
  Color? selectedShadowColor;
  Color? shadowColor;
  OutlinedBorder? shape;
  bool? showCheckmark;
  BorderSide? side;
  Color? surfaceTintColor;
  String? tooltip;
  VisualDensity? visualDensity;
}

InputChip _buildGeneratedInputChipTagWidget(_GeneratedInputChipTagConfig config, List<Widget> children) {
  return InputChip(
    autofocus: config.autofocus ?? false,
    avatar: config.avatar,
    avatarBorder: config.avatarBorder ?? const CircleBorder(),
    avatarBoxConstraints: config.avatarBoxConstraints,
    backgroundColor: config.backgroundColor,
    checkmarkColor: config.checkmarkColor,
    chipAnimationStyle: config.chipAnimationStyle,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    deleteButtonTooltipMessage: config.deleteButtonTooltipMessage,
    deleteIcon: config.deleteIcon,
    deleteIconBoxConstraints: config.deleteIconBoxConstraints,
    deleteIconColor: config.deleteIconColor,
    disabledColor: config.disabledColor,
    elevation: config.elevation,
    focusNode: config.focusNode,
    iconTheme: config.iconTheme,
    isEnabled: config.isEnabled ?? true,
    key: config.key,
    label: config.label!,
    labelPadding: config.labelPadding,
    labelStyle: config.labelStyle,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onDeleted: config.onDeleted,
    onPressed: config.onPressed,
    onSelected: config.onSelected,
    padding: config.padding,
    pressElevation: config.pressElevation,
    selected: config.selected ?? false,
    selectedColor: config.selectedColor,
    selectedShadowColor: config.selectedShadowColor,
    shadowColor: config.shadowColor,
    shape: config.shape,
    showCheckmark: config.showCheckmark,
    side: config.side,
    surfaceTintColor: config.surfaceTintColor,
    tooltip: config.tooltip,
    visualDensity: config.visualDensity,
  );
}


class GeneratedIntrinsicHeightTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedIntrinsicHeightTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedIntrinsicHeightTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedIntrinsicHeightTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('intrinsic_height').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endintrinsic_height').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'intrinsic_height',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedIntrinsicHeightTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedIntrinsicHeightTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('intrinsic_height', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedIntrinsicHeightTagConfig {
  Key? key;
}

IntrinsicHeight _buildGeneratedIntrinsicHeightTagWidget(_GeneratedIntrinsicHeightTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return IntrinsicHeight(
    key: config.key,
    child: child,
  );
}


class GeneratedIntrinsicWidthTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedIntrinsicWidthTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedIntrinsicWidthTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedIntrinsicWidthTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('intrinsic_width').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endintrinsic_width').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'intrinsic_width',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedIntrinsicWidthTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedIntrinsicWidthTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'stepHeight':
          config.stepHeight = toDouble(value);
          break;
        case 'stepWidth':
          config.stepWidth = toDouble(value);
          break;
        default:
          handleUnknownArg('intrinsic_width', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedIntrinsicWidthTagConfig {
  Key? key;
  double? stepHeight;
  double? stepWidth;
}

IntrinsicWidth _buildGeneratedIntrinsicWidthTagWidget(_GeneratedIntrinsicWidthTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return IntrinsicWidth(
    key: config.key,
    stepHeight: config.stepHeight,
    stepWidth: config.stepWidth,
    child: child,
  );
}


class GeneratedLayoutBuilderTag extends WidgetTagBase with AsyncTag {
  GeneratedLayoutBuilderTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedLayoutBuilderTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedLayoutBuilderTagWidget(config, children));
  }

  _GeneratedLayoutBuilderTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedLayoutBuilderTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'builder':
          config.builder = (value is Widget Function(BuildContext, BoxConstraints) ? value : resolveWidgetBuilder2Callback(evaluator, value) as Widget Function(BuildContext, BoxConstraints)?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('layout_builder', name);
          break;
      }
    }
    if (config.builder == null) {
      throw Exception('layout_builder tag requires "builder"');
    }
    return config;
  }
}

class _GeneratedLayoutBuilderTagConfig {
  Widget Function(BuildContext, BoxConstraints)? builder;
  Key? key;
}

LayoutBuilder _buildGeneratedLayoutBuilderTagWidget(_GeneratedLayoutBuilderTagConfig config, List<Widget> children) {
  return LayoutBuilder(
    builder: config.builder!,
    key: config.key,
  );
}


class GeneratedLimitedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedLimitedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedLimitedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedLimitedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('limited_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endlimited_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'limited_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedLimitedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedLimitedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'maxHeight':
          config.maxHeight = toDouble(value);
          break;
        case 'maxWidth':
          config.maxWidth = toDouble(value);
          break;
        default:
          handleUnknownArg('limited_box', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedLimitedBoxTagConfig {
  Key? key;
  double? maxHeight;
  double? maxWidth;
}

LimitedBox _buildGeneratedLimitedBoxTagWidget(_GeneratedLimitedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return LimitedBox(
    key: config.key,
    maxHeight: config.maxHeight ?? double.infinity,
    maxWidth: config.maxWidth ?? double.infinity,
    child: child,
  );
}


class GeneratedLinearProgressIndicatorTag extends WidgetTagBase with AsyncTag {
  GeneratedLinearProgressIndicatorTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedLinearProgressIndicatorTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedLinearProgressIndicatorTagWidget(config, children));
  }

  _GeneratedLinearProgressIndicatorTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedLinearProgressIndicatorTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'borderRadius':
          config.borderRadius = parseGeneratedBorderRadiusGeometry(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'controller':
          config.controller = parseGeneratedAnimationController(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'minHeight':
          config.minHeight = toDouble(value);
          break;
        case 'semanticsLabel':
          config.semanticsLabel = toStringValue(value);
          break;
        case 'semanticsValue':
          config.semanticsValue = toStringValue(value);
          break;
        case 'stopIndicatorColor':
          config.stopIndicatorColor = parseGeneratedColor(value);
          break;
        case 'stopIndicatorRadius':
          config.stopIndicatorRadius = toDouble(value);
          break;
        case 'trackGap':
          config.trackGap = toDouble(value);
          break;
        case 'value':
          config.value = toDouble(value);
          break;
        case 'valueColor':
          config.valueColor = parseGeneratedAnimationOfColor(value);
          break;
        case 'year2023':
          config.year2023 = toBool(value);
          break;
        default:
          handleUnknownArg('linear_progress_indicator', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedLinearProgressIndicatorTagConfig {
  Color? backgroundColor;
  BorderRadiusGeometry? borderRadius;
  Color? color;
  AnimationController? controller;
  Key? key;
  double? minHeight;
  String? semanticsLabel;
  String? semanticsValue;
  Color? stopIndicatorColor;
  double? stopIndicatorRadius;
  double? trackGap;
  double? value;
  Animation<Color?>? valueColor;
  bool? year2023;
}

LinearProgressIndicator _buildGeneratedLinearProgressIndicatorTagWidget(_GeneratedLinearProgressIndicatorTagConfig config, List<Widget> children) {
  return LinearProgressIndicator(
    backgroundColor: config.backgroundColor,
    borderRadius: config.borderRadius,
    color: config.color,
    controller: config.controller,
    key: config.key,
    minHeight: config.minHeight,
    semanticsLabel: config.semanticsLabel,
    semanticsValue: config.semanticsValue,
    stopIndicatorColor: config.stopIndicatorColor,
    stopIndicatorRadius: config.stopIndicatorRadius,
    trackGap: config.trackGap,
    value: config.value,
    valueColor: config.valueColor,
    year2023: config.year2023,
  );
}


class GeneratedListTileTag extends WidgetTagBase with AsyncTag {
  GeneratedListTileTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedListTileTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedListTileTagWidget(config, children));
  }

  _GeneratedListTileTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedListTileTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'contentPadding':
          config.contentPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'dense':
          config.dense = toBool(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'focusColor':
          config.focusColor = parseGeneratedColor(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'horizontalTitleGap':
          config.horizontalTitleGap = toDouble(value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'iconColor':
          config.iconColor = parseGeneratedColor(value);
          break;
        case 'internalAddSemanticForOnTap':
          config.internalAddSemanticForOnTap = toBool(value);
          break;
        case 'isThreeLine':
          config.isThreeLine = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'leading':
          config.leading = resolveWidget(value);
          break;
        case 'leadingAndTrailingTextStyle':
          config.leadingAndTrailingTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'minLeadingWidth':
          config.minLeadingWidth = toDouble(value);
          break;
        case 'minTileHeight':
          config.minTileHeight = toDouble(value);
          break;
        case 'minVerticalPadding':
          config.minVerticalPadding = toDouble(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onLongPress':
          config.onLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onTap':
          config.onTap = resolveActionCallback(evaluator, value);
          break;
        case 'selected':
          config.selected = toBool(value);
          break;
        case 'selectedColor':
          config.selectedColor = parseGeneratedColor(value);
          break;
        case 'selectedTileColor':
          config.selectedTileColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'splashColor':
          config.splashColor = parseGeneratedColor(value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'style':
          config.style = parseGeneratedListTileStyle(value);
          break;
        case 'subtitle':
          config.subtitle = resolveWidget(value);
          break;
        case 'subtitleTextStyle':
          config.subtitleTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'textColor':
          config.textColor = parseGeneratedColor(value);
          break;
        case 'tileColor':
          config.tileColor = parseGeneratedColor(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'titleAlignment':
          config.titleAlignment = parseGeneratedListTileTitleAlignment(value);
          break;
        case 'titleTextStyle':
          config.titleTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'trailing':
          config.trailing = resolveWidget(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('list_tile', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedListTileTagConfig {
  bool? autofocus;
  EdgeInsetsGeometry? contentPadding;
  bool? dense;
  bool? enableFeedback;
  bool? enabled;
  Color? focusColor;
  FocusNode? focusNode;
  double? horizontalTitleGap;
  Color? hoverColor;
  Color? iconColor;
  bool? internalAddSemanticForOnTap;
  bool? isThreeLine;
  Key? key;
  Widget? leading;
  TextStyle? leadingAndTrailingTextStyle;
  double? minLeadingWidth;
  double? minTileHeight;
  double? minVerticalPadding;
  MouseCursor? mouseCursor;
  ValueChanged<bool>? onFocusChange;
  GestureLongPressCallback? onLongPress;
  GestureTapCallback? onTap;
  bool? selected;
  Color? selectedColor;
  Color? selectedTileColor;
  ShapeBorder? shape;
  Color? splashColor;
  MaterialStatesController? statesController;
  ListTileStyle? style;
  Widget? subtitle;
  TextStyle? subtitleTextStyle;
  Color? textColor;
  Color? tileColor;
  Widget? title;
  ListTileTitleAlignment? titleAlignment;
  TextStyle? titleTextStyle;
  Widget? trailing;
  VisualDensity? visualDensity;
}

ListTile _buildGeneratedListTileTagWidget(_GeneratedListTileTagConfig config, List<Widget> children) {
  return ListTile(
    autofocus: config.autofocus ?? false,
    contentPadding: config.contentPadding,
    dense: config.dense,
    enableFeedback: config.enableFeedback,
    enabled: config.enabled ?? true,
    focusColor: config.focusColor,
    focusNode: config.focusNode,
    horizontalTitleGap: config.horizontalTitleGap,
    hoverColor: config.hoverColor,
    iconColor: config.iconColor,
    internalAddSemanticForOnTap: config.internalAddSemanticForOnTap ?? true,
    isThreeLine: config.isThreeLine,
    key: config.key,
    leading: config.leading,
    leadingAndTrailingTextStyle: config.leadingAndTrailingTextStyle,
    minLeadingWidth: config.minLeadingWidth,
    minTileHeight: config.minTileHeight,
    minVerticalPadding: config.minVerticalPadding,
    mouseCursor: config.mouseCursor,
    onFocusChange: config.onFocusChange,
    onLongPress: config.onLongPress,
    onTap: config.onTap,
    selected: config.selected ?? false,
    selectedColor: config.selectedColor,
    selectedTileColor: config.selectedTileColor,
    shape: config.shape,
    splashColor: config.splashColor,
    statesController: config.statesController,
    style: config.style,
    subtitle: config.subtitle,
    subtitleTextStyle: config.subtitleTextStyle,
    textColor: config.textColor,
    tileColor: config.tileColor,
    title: config.title,
    titleAlignment: config.titleAlignment,
    titleTextStyle: config.titleTextStyle,
    trailing: config.trailing,
    visualDensity: config.visualDensity,
  );
}


class GeneratedListViewTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedListViewTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedListViewTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedListViewTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('list_view').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endlist_view').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'list_view',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedListViewTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedListViewTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'addAutomaticKeepAlives':
          config.addAutomaticKeepAlives = toBool(value);
          break;
        case 'addRepaintBoundaries':
          config.addRepaintBoundaries = toBool(value);
          break;
        case 'addSemanticIndexes':
          config.addSemanticIndexes = toBool(value);
          break;
        case 'cacheExtent':
          config.cacheExtent = toDouble(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'controller':
          config.controller = parseGeneratedScrollController(evaluator, value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'hitTestBehavior':
          config.hitTestBehavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'itemExtent':
          config.itemExtent = toDouble(value);
          break;
        case 'itemExtentBuilder':
          config.itemExtentBuilder = (value is ItemExtentBuilder ? value : resolveGenericCallback2(evaluator, value) as ItemExtentBuilder?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardDismissBehavior':
          config.keyboardDismissBehavior = parseGeneratedScrollViewKeyboardDismissBehavior(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'prototypeItem':
          config.prototypeItem = resolveWidget(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'reverse':
          config.reverse = toBool(value);
          break;
        case 'scrollDirection':
          config.scrollDirection = parseGeneratedAxis(value);
          break;
        case 'semanticChildCount':
          config.semanticChildCount = toInt(value);
          break;
        case 'shrinkWrap':
          config.shrinkWrap = toBool(value);
          break;
        default:
          handleUnknownArg('list_view', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedListViewTagConfig {
  bool? addAutomaticKeepAlives;
  bool? addRepaintBoundaries;
  bool? addSemanticIndexes;
  double? cacheExtent;
  Clip? clipBehavior;
  ScrollController? controller;
  DragStartBehavior? dragStartBehavior;
  HitTestBehavior? hitTestBehavior;
  double? itemExtent;
  ItemExtentBuilder? itemExtentBuilder;
  Key? key;
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
  EdgeInsetsGeometry? padding;
  ScrollPhysics? physics;
  bool? primary;
  Widget? prototypeItem;
  String? restorationId;
  bool? reverse;
  Axis? scrollDirection;
  int? semanticChildCount;
  bool? shrinkWrap;
}

ListView _buildGeneratedListViewTagWidget(_GeneratedListViewTagConfig config, List<Widget> children) {
  return ListView(
    addAutomaticKeepAlives: config.addAutomaticKeepAlives ?? true,
    addRepaintBoundaries: config.addRepaintBoundaries ?? true,
    addSemanticIndexes: config.addSemanticIndexes ?? true,
    cacheExtent: config.cacheExtent,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    controller: config.controller,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    hitTestBehavior: config.hitTestBehavior ?? HitTestBehavior.opaque,
    itemExtent: config.itemExtent,
    itemExtentBuilder: config.itemExtentBuilder,
    key: config.key,
    keyboardDismissBehavior: config.keyboardDismissBehavior,
    padding: config.padding,
    physics: config.physics,
    primary: config.primary,
    prototypeItem: config.prototypeItem,
    restorationId: config.restorationId,
    reverse: config.reverse ?? false,
    scrollDirection: config.scrollDirection ?? Axis.vertical,
    semanticChildCount: config.semanticChildCount,
    shrinkWrap: config.shrinkWrap ?? false,
    children: children,
  );
}


class GeneratedListenerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedListenerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedListenerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedListenerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('listener').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endlistener').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'listener',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedListenerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedListenerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'behavior':
          config.behavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onPointerCancel':
          config.onPointerCancel = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerDown':
          config.onPointerDown = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerHover':
          config.onPointerHover = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerMove':
          config.onPointerMove = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerPanZoomEnd':
          config.onPointerPanZoomEnd = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerPanZoomStart':
          config.onPointerPanZoomStart = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerPanZoomUpdate':
          config.onPointerPanZoomUpdate = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerSignal':
          config.onPointerSignal = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onPointerUp':
          config.onPointerUp = resolveGenericValueChanged(evaluator, value);
          break;
        default:
          handleUnknownArg('listener', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedListenerTagConfig {
  HitTestBehavior? behavior;
  Key? key;
  PointerCancelEventListener? onPointerCancel;
  PointerDownEventListener? onPointerDown;
  PointerHoverEventListener? onPointerHover;
  PointerMoveEventListener? onPointerMove;
  PointerPanZoomEndEventListener? onPointerPanZoomEnd;
  PointerPanZoomStartEventListener? onPointerPanZoomStart;
  PointerPanZoomUpdateEventListener? onPointerPanZoomUpdate;
  PointerSignalEventListener? onPointerSignal;
  PointerUpEventListener? onPointerUp;
}

Listener _buildGeneratedListenerTagWidget(_GeneratedListenerTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Listener(
    behavior: config.behavior ?? HitTestBehavior.deferToChild,
    key: config.key,
    onPointerCancel: config.onPointerCancel,
    onPointerDown: config.onPointerDown,
    onPointerHover: config.onPointerHover,
    onPointerMove: config.onPointerMove,
    onPointerPanZoomEnd: config.onPointerPanZoomEnd,
    onPointerPanZoomStart: config.onPointerPanZoomStart,
    onPointerPanZoomUpdate: config.onPointerPanZoomUpdate,
    onPointerSignal: config.onPointerSignal,
    onPointerUp: config.onPointerUp,
    child: child,
  );
}


class GeneratedMaterialBannerTag extends WidgetTagBase with AsyncTag {
  GeneratedMaterialBannerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedMaterialBannerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedMaterialBannerTagWidget(config, children));
  }

  _GeneratedMaterialBannerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedMaterialBannerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'actions':
          config.actions = value;
          break;
        case 'animation':
          config.animation = parseGeneratedAnimationOfDouble(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'content':
          config.content = resolveWidget(value);
          break;
        case 'contentTextStyle':
          config.contentTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'dividerColor':
          config.dividerColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'forceActionsBelow':
          config.forceActionsBelow = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'leading':
          config.leading = resolveWidget(value);
          break;
        case 'leadingPadding':
          config.leadingPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'minActionBarHeight':
          config.minActionBarHeight = toDouble(value);
          break;
        case 'onVisible':
          config.onVisible = resolveActionCallback(evaluator, value);
          break;
        case 'overflowAlignment':
          config.overflowAlignment = parseGeneratedOverflowBarAlignment(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        default:
          handleUnknownArg('material_banner', name);
          break;
      }
    }
    if (config.actions == null) {
      throw Exception('material_banner tag requires "actions"');
    }
    if (config.content == null) {
      throw Exception('material_banner tag requires "content"');
    }
    return config;
  }
}

class _GeneratedMaterialBannerTagConfig {
  List<Widget>? actions;
  Animation<double>? animation;
  Color? backgroundColor;
  Widget? content;
  TextStyle? contentTextStyle;
  Color? dividerColor;
  double? elevation;
  bool? forceActionsBelow;
  Key? key;
  Widget? leading;
  EdgeInsetsGeometry? leadingPadding;
  EdgeInsetsGeometry? margin;
  double? minActionBarHeight;
  VoidCallback? onVisible;
  OverflowBarAlignment? overflowAlignment;
  EdgeInsetsGeometry? padding;
  Color? shadowColor;
  Color? surfaceTintColor;
}

MaterialBanner _buildGeneratedMaterialBannerTagWidget(_GeneratedMaterialBannerTagConfig config, List<Widget> children) {
  return MaterialBanner(
    actions: config.actions!,
    animation: config.animation,
    backgroundColor: config.backgroundColor,
    content: config.content!,
    contentTextStyle: config.contentTextStyle,
    dividerColor: config.dividerColor,
    elevation: config.elevation,
    forceActionsBelow: config.forceActionsBelow ?? false,
    key: config.key,
    leading: config.leading,
    leadingPadding: config.leadingPadding,
    margin: config.margin,
    minActionBarHeight: config.minActionBarHeight ?? 52.0,
    onVisible: config.onVisible,
    overflowAlignment: config.overflowAlignment ?? OverflowBarAlignment.end,
    padding: config.padding,
    shadowColor: config.shadowColor,
    surfaceTintColor: config.surfaceTintColor,
  );
}


class GeneratedMergeSemanticsTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedMergeSemanticsTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedMergeSemanticsTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedMergeSemanticsTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('merge_semantics').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endmerge_semantics').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'merge_semantics',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedMergeSemanticsTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedMergeSemanticsTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('merge_semantics', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedMergeSemanticsTagConfig {
  Key? key;
}

MergeSemantics _buildGeneratedMergeSemanticsTagWidget(_GeneratedMergeSemanticsTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return MergeSemantics(
    key: config.key,
    child: child,
  );
}


class GeneratedMouseRegionTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedMouseRegionTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedMouseRegionTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedMouseRegionTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('mouse_region').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endmouse_region').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'mouse_region',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedMouseRegionTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedMouseRegionTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'cursor':
          config.cursor = parseGeneratedMouseCursor(value);
          break;
        case 'hitTestBehavior':
          config.hitTestBehavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onEnter':
          config.onEnter = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onExit':
          config.onExit = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onHover':
          config.onHover = resolveGenericValueChanged(evaluator, value);
          break;
        case 'opaque':
          config.opaque = toBool(value);
          break;
        default:
          handleUnknownArg('mouse_region', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedMouseRegionTagConfig {
  MouseCursor? cursor;
  HitTestBehavior? hitTestBehavior;
  Key? key;
  PointerEnterEventListener? onEnter;
  PointerExitEventListener? onExit;
  PointerHoverEventListener? onHover;
  bool? opaque;
}

MouseRegion _buildGeneratedMouseRegionTagWidget(_GeneratedMouseRegionTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return MouseRegion(
    cursor: config.cursor ?? MouseCursor.defer,
    hitTestBehavior: config.hitTestBehavior,
    key: config.key,
    onEnter: config.onEnter,
    onExit: config.onExit,
    onHover: config.onHover,
    opaque: config.opaque ?? true,
    child: child,
  );
}


class GeneratedNavigationBarTag extends WidgetTagBase with AsyncTag {
  GeneratedNavigationBarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationBarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationBarTagWidget(config, children));
  }

  _GeneratedNavigationBarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedNavigationBarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'animationDuration':
          config.animationDuration = parseGeneratedDuration(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'destinations':
          config.destinations = value;
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'indicatorColor':
          config.indicatorColor = parseGeneratedColor(value);
          break;
        case 'indicatorShape':
          config.indicatorShape = parseGeneratedShapeBorder(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'labelBehavior':
          config.labelBehavior = parseGeneratedNavigationDestinationLabelBehavior(value);
          break;
        case 'labelPadding':
          config.labelPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'labelTextStyle':
          config.labelTextStyle = (value is WidgetStateProperty<TextStyle?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<TextStyle?>?);
          break;
        case 'maintainBottomViewPadding':
          config.maintainBottomViewPadding = toBool(value);
          break;
        case 'onDestinationSelected':
          config.onDestinationSelected = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'overlayColor':
          config.overlayColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'selectedIndex':
          config.selectedIndex = toInt(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        default:
          handleUnknownArg('navigation_bar', name);
          break;
      }
    }
    if (config.destinations == null) {
      throw Exception('navigation_bar tag requires "destinations"');
    }
    return config;
  }
}

class _GeneratedNavigationBarTagConfig {
  Duration? animationDuration;
  Color? backgroundColor;
  List<Widget>? destinations;
  double? elevation;
  double? height;
  Color? indicatorColor;
  ShapeBorder? indicatorShape;
  Key? key;
  NavigationDestinationLabelBehavior? labelBehavior;
  EdgeInsetsGeometry? labelPadding;
  WidgetStateProperty<TextStyle?>? labelTextStyle;
  bool? maintainBottomViewPadding;
  ValueChanged<int>? onDestinationSelected;
  WidgetStateProperty<Color?>? overlayColor;
  int? selectedIndex;
  Color? shadowColor;
  Color? surfaceTintColor;
}

NavigationBar _buildGeneratedNavigationBarTagWidget(_GeneratedNavigationBarTagConfig config, List<Widget> children) {
  return NavigationBar(
    animationDuration: config.animationDuration,
    backgroundColor: config.backgroundColor,
    destinations: config.destinations!,
    elevation: config.elevation,
    height: config.height,
    indicatorColor: config.indicatorColor,
    indicatorShape: config.indicatorShape,
    key: config.key,
    labelBehavior: config.labelBehavior,
    labelPadding: config.labelPadding,
    labelTextStyle: config.labelTextStyle,
    maintainBottomViewPadding: config.maintainBottomViewPadding ?? false,
    onDestinationSelected: config.onDestinationSelected,
    overlayColor: config.overlayColor,
    selectedIndex: config.selectedIndex ?? 0,
    shadowColor: config.shadowColor,
    surfaceTintColor: config.surfaceTintColor,
  );
}


class GeneratedNavigationDestinationTag extends WidgetTagBase with AsyncTag {
  GeneratedNavigationDestinationTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationDestinationTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationDestinationTagWidget(config, children));
  }

  _GeneratedNavigationDestinationTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedNavigationDestinationTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = toStringValue(value);
          break;
        case 'selectedIcon':
          config.selectedIcon = resolveWidget(value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        default:
          handleUnknownArg('navigation_destination', name);
          break;
      }
    }
    if (config.icon == null) {
      throw Exception('navigation_destination tag requires "icon"');
    }
    if (config.label == null) {
      throw Exception('navigation_destination tag requires "label"');
    }
    return config;
  }
}

class _GeneratedNavigationDestinationTagConfig {
  bool? enabled;
  Widget? icon;
  Key? key;
  String? label;
  Widget? selectedIcon;
  String? tooltip;
}

NavigationDestination _buildGeneratedNavigationDestinationTagWidget(_GeneratedNavigationDestinationTagConfig config, List<Widget> children) {
  return NavigationDestination(
    enabled: config.enabled ?? true,
    icon: config.icon!,
    key: config.key,
    label: config.label!,
    selectedIcon: config.selectedIcon,
    tooltip: config.tooltip,
  );
}


class GeneratedNavigationDrawerTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedNavigationDrawerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedNavigationDrawerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedNavigationDrawerTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('navigation_drawer').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endnavigation_drawer').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'navigation_drawer',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedNavigationDrawerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedNavigationDrawerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'footer':
          config.footer = resolveWidget(value);
          break;
        case 'header':
          config.header = resolveWidget(value);
          break;
        case 'indicatorColor':
          config.indicatorColor = parseGeneratedColor(value);
          break;
        case 'indicatorShape':
          config.indicatorShape = parseGeneratedShapeBorder(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onDestinationSelected':
          config.onDestinationSelected = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'selectedIndex':
          config.selectedIndex = toInt(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'tilePadding':
          config.tilePadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        default:
          handleUnknownArg('navigation_drawer', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedNavigationDrawerTagConfig {
  Color? backgroundColor;
  double? elevation;
  Widget? footer;
  Widget? header;
  Color? indicatorColor;
  ShapeBorder? indicatorShape;
  Key? key;
  ValueChanged<int>? onDestinationSelected;
  int? selectedIndex;
  Color? shadowColor;
  Color? surfaceTintColor;
  EdgeInsetsGeometry? tilePadding;
}

NavigationDrawer _buildGeneratedNavigationDrawerTagWidget(_GeneratedNavigationDrawerTagConfig config, List<Widget> children) {
  return NavigationDrawer(
    backgroundColor: config.backgroundColor,
    elevation: config.elevation,
    footer: config.footer,
    header: config.header,
    indicatorColor: config.indicatorColor,
    indicatorShape: config.indicatorShape,
    key: config.key,
    onDestinationSelected: config.onDestinationSelected,
    selectedIndex: config.selectedIndex ?? 0,
    shadowColor: config.shadowColor,
    surfaceTintColor: config.surfaceTintColor,
    tilePadding: config.tilePadding ?? const EdgeInsets.symmetric(horizontal: 12.0),
    children: children,
  );
}


class GeneratedNavigationDrawerDestinationTag extends WidgetTagBase with AsyncTag {
  GeneratedNavigationDrawerDestinationTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationDrawerDestinationTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationDrawerDestinationTagWidget(config, children));
  }

  _GeneratedNavigationDrawerDestinationTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedNavigationDrawerDestinationTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'selectedIcon':
          config.selectedIcon = resolveWidget(value);
          break;
        default:
          handleUnknownArg('navigation_drawer_destination', name);
          break;
      }
    }
    if (config.icon == null) {
      throw Exception('navigation_drawer_destination tag requires "icon"');
    }
    if (config.label == null) {
      throw Exception('navigation_drawer_destination tag requires "label"');
    }
    return config;
  }
}

class _GeneratedNavigationDrawerDestinationTagConfig {
  Color? backgroundColor;
  bool? enabled;
  Widget? icon;
  Key? key;
  Widget? label;
  Widget? selectedIcon;
}

NavigationDrawerDestination _buildGeneratedNavigationDrawerDestinationTagWidget(_GeneratedNavigationDrawerDestinationTagConfig config, List<Widget> children) {
  return NavigationDrawerDestination(
    backgroundColor: config.backgroundColor,
    enabled: config.enabled ?? true,
    icon: config.icon!,
    key: config.key,
    label: config.label!,
    selectedIcon: config.selectedIcon,
  );
}


class GeneratedNavigationRailTag extends WidgetTagBase with AsyncTag {
  GeneratedNavigationRailTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationRailTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationRailTagWidget(config, children));
  }

  _GeneratedNavigationRailTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedNavigationRailTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'destinations':
          config.destinations = parseGeneratedListOfNavigationRailDestination(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'extended':
          config.extended = toBool(value);
          break;
        case 'groupAlignment':
          config.groupAlignment = toDouble(value);
          break;
        case 'indicatorColor':
          config.indicatorColor = parseGeneratedColor(value);
          break;
        case 'indicatorShape':
          config.indicatorShape = parseGeneratedShapeBorder(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'labelType':
          config.labelType = parseGeneratedNavigationRailLabelType(value);
          break;
        case 'leading':
          config.leading = resolveWidget(value);
          break;
        case 'leadingAtTop':
          config.leadingAtTop = toBool(value);
          break;
        case 'minExtendedWidth':
          config.minExtendedWidth = toDouble(value);
          break;
        case 'minWidth':
          config.minWidth = toDouble(value);
          break;
        case 'onDestinationSelected':
          config.onDestinationSelected = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'scrollable':
          config.scrollable = toBool(value);
          break;
        case 'selectedIconTheme':
          config.selectedIconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'selectedIndex':
          config.selectedIndex = toInt(value);
          break;
        case 'selectedLabelTextStyle':
          config.selectedLabelTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'trailing':
          config.trailing = resolveWidget(value);
          break;
        case 'trailingAtBottom':
          config.trailingAtBottom = toBool(value);
          break;
        case 'unselectedIconTheme':
          config.unselectedIconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'unselectedLabelTextStyle':
          config.unselectedLabelTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'useIndicator':
          config.useIndicator = toBool(value);
          break;
        default:
          handleUnknownArg('navigation_rail', name);
          break;
      }
    }
    if (config.destinations == null) {
      throw Exception('navigation_rail tag requires "destinations"');
    }
    if (config.selectedIndex == null) {
      throw Exception('navigation_rail tag requires "selectedIndex"');
    }
    return config;
  }
}

class _GeneratedNavigationRailTagConfig {
  Color? backgroundColor;
  List<NavigationRailDestination>? destinations;
  double? elevation;
  bool? extended;
  double? groupAlignment;
  Color? indicatorColor;
  ShapeBorder? indicatorShape;
  Key? key;
  NavigationRailLabelType? labelType;
  Widget? leading;
  bool? leadingAtTop;
  double? minExtendedWidth;
  double? minWidth;
  ValueChanged<int>? onDestinationSelected;
  bool? scrollable;
  IconThemeData? selectedIconTheme;
  int? selectedIndex;
  TextStyle? selectedLabelTextStyle;
  Widget? trailing;
  bool? trailingAtBottom;
  IconThemeData? unselectedIconTheme;
  TextStyle? unselectedLabelTextStyle;
  bool? useIndicator;
}

NavigationRail _buildGeneratedNavigationRailTagWidget(_GeneratedNavigationRailTagConfig config, List<Widget> children) {
  return NavigationRail(
    backgroundColor: config.backgroundColor,
    destinations: config.destinations!,
    elevation: config.elevation,
    extended: config.extended ?? false,
    groupAlignment: config.groupAlignment,
    indicatorColor: config.indicatorColor,
    indicatorShape: config.indicatorShape,
    key: config.key,
    labelType: config.labelType,
    leading: config.leading,
    leadingAtTop: config.leadingAtTop ?? true,
    minExtendedWidth: config.minExtendedWidth,
    minWidth: config.minWidth,
    onDestinationSelected: config.onDestinationSelected,
    scrollable: config.scrollable ?? false,
    selectedIconTheme: config.selectedIconTheme,
    selectedIndex: config.selectedIndex,
    selectedLabelTextStyle: config.selectedLabelTextStyle,
    trailing: config.trailing,
    trailingAtBottom: config.trailingAtBottom ?? false,
    unselectedIconTheme: config.unselectedIconTheme,
    unselectedLabelTextStyle: config.unselectedLabelTextStyle,
    useIndicator: config.useIndicator,
  );
}


class GeneratedNavigationRailDestinationTag extends WidgetTagBase with AsyncTag {
  GeneratedNavigationRailDestinationTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationRailDestinationTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedNavigationRailDestinationTagWidget(config, children));
  }

  _GeneratedNavigationRailDestinationTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedNavigationRailDestinationTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'disabled':
          config.disabled = toBool(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'indicatorColor':
          config.indicatorColor = parseGeneratedColor(value);
          break;
        case 'indicatorShape':
          config.indicatorShape = parseGeneratedShapeBorder(value);
          break;
        case 'label':
          config.label = resolveWidget(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'selectedIcon':
          config.selectedIcon = resolveWidget(value);
          break;
        default:
          handleUnknownArg('navigation_rail_destination', name);
          break;
      }
    }
    if (config.icon == null) {
      throw Exception('navigation_rail_destination tag requires "icon"');
    }
    if (config.label == null) {
      throw Exception('navigation_rail_destination tag requires "label"');
    }
    return config;
  }
}

class _GeneratedNavigationRailDestinationTagConfig {
  bool? disabled;
  Widget? icon;
  Color? indicatorColor;
  ShapeBorder? indicatorShape;
  Widget? label;
  EdgeInsetsGeometry? padding;
  Widget? selectedIcon;
}

NavigationRailDestination _buildGeneratedNavigationRailDestinationTagWidget(_GeneratedNavigationRailDestinationTagConfig config, List<Widget> children) {
  return NavigationRailDestination(
    disabled: config.disabled ?? false,
    icon: config.icon!,
    indicatorColor: config.indicatorColor,
    indicatorShape: config.indicatorShape,
    label: config.label!,
    padding: config.padding,
    selectedIcon: config.selectedIcon,
  );
}


class GeneratedOffstageTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedOffstageTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedOffstageTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedOffstageTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('offstage').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endoffstage').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'offstage',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedOffstageTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedOffstageTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'offstage':
          config.offstage = toBool(value);
          break;
        default:
          handleUnknownArg('offstage', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedOffstageTagConfig {
  Key? key;
  bool? offstage;
}

Offstage _buildGeneratedOffstageTagWidget(_GeneratedOffstageTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Offstage(
    key: config.key,
    offstage: config.offstage ?? true,
    child: child,
  );
}


class GeneratedOpacityTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedOpacityTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedOpacityTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedOpacityTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('opacity').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endopacity').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'opacity',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedOpacityTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedOpacityTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alwaysIncludeSemantics':
          config.alwaysIncludeSemantics = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'opacity':
          config.opacity = toDouble(value);
          break;
        default:
          handleUnknownArg('opacity', name);
          break;
      }
    }
    if (config.opacity == null) {
      throw Exception('opacity tag requires "opacity"');
    }
    return config;
  }
}

class _GeneratedOpacityTagConfig {
  bool? alwaysIncludeSemantics;
  Key? key;
  double? opacity;
}

Opacity _buildGeneratedOpacityTagWidget(_GeneratedOpacityTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Opacity(
    alwaysIncludeSemantics: config.alwaysIncludeSemantics ?? false,
    key: config.key,
    opacity: config.opacity!,
    child: child,
  );
}


class GeneratedOutlinedButtonTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedOutlinedButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedOutlinedButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedOutlinedButtonTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('outlined_button').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endoutlined_button').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'outlined_button',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedOutlinedButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedOutlinedButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onHover':
          config.onHover = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onLongPress':
          config.onLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'style':
          config.style = parseGeneratedButtonStyle(evaluator, value);
          break;
        default:
          handleUnknownArg('outlined_button', name);
          break;
      }
    }
    if (config.onPressed == null) {
      throw Exception('outlined_button tag requires "onPressed"');
    }
    return config;
  }
}

class _GeneratedOutlinedButtonTagConfig {
  bool? autofocus;
  Clip? clipBehavior;
  FocusNode? focusNode;
  Key? key;
  ValueChanged<bool>? onFocusChange;
  ValueChanged<bool>? onHover;
  VoidCallback? onLongPress;
  VoidCallback? onPressed;
  MaterialStatesController? statesController;
  ButtonStyle? style;
}

OutlinedButton _buildGeneratedOutlinedButtonTagWidget(_GeneratedOutlinedButtonTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return OutlinedButton(
    autofocus: config.autofocus ?? false,
    clipBehavior: config.clipBehavior,
    focusNode: config.focusNode,
    key: config.key,
    onFocusChange: config.onFocusChange,
    onHover: config.onHover,
    onLongPress: config.onLongPress,
    onPressed: config.onPressed,
    statesController: config.statesController,
    style: config.style,
    child: child,
  );
}


class GeneratedOverflowBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedOverflowBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedOverflowBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedOverflowBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('overflow_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endoverflow_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'overflow_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedOverflowBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedOverflowBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'fit':
          config.fit = parseGeneratedOverflowBoxFit(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'maxHeight':
          config.maxHeight = toDouble(value);
          break;
        case 'maxWidth':
          config.maxWidth = toDouble(value);
          break;
        case 'minHeight':
          config.minHeight = toDouble(value);
          break;
        case 'minWidth':
          config.minWidth = toDouble(value);
          break;
        default:
          handleUnknownArg('overflow_box', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedOverflowBoxTagConfig {
  AlignmentGeometry? alignment;
  OverflowBoxFit? fit;
  Key? key;
  double? maxHeight;
  double? maxWidth;
  double? minHeight;
  double? minWidth;
}

OverflowBox _buildGeneratedOverflowBoxTagWidget(_GeneratedOverflowBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return OverflowBox(
    alignment: config.alignment ?? Alignment.center,
    fit: config.fit ?? OverflowBoxFit.max,
    key: config.key,
    maxHeight: config.maxHeight,
    maxWidth: config.maxWidth,
    minHeight: config.minHeight,
    minWidth: config.minWidth,
    child: child,
  );
}


class GeneratedPaddingTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedPaddingTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedPaddingTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedPaddingTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('padding').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endpadding').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'padding',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedPaddingTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPaddingTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        default:
          handleUnknownArg('padding', name);
          break;
      }
    }
    if (config.padding == null) {
      throw Exception('padding tag requires "padding"');
    }
    return config;
  }
}

class _GeneratedPaddingTagConfig {
  Key? key;
  EdgeInsetsGeometry? padding;
}

Padding _buildGeneratedPaddingTagWidget(_GeneratedPaddingTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Padding(
    key: config.key,
    padding: config.padding!,
    child: child,
  );
}


class GeneratedPageViewTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedPageViewTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedPageViewTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedPageViewTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('page_view').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endpage_view').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'page_view',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedPageViewTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPageViewTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'allowImplicitScrolling':
          config.allowImplicitScrolling = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'controller':
          config.controller = parseGeneratedPageController(evaluator, value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'hitTestBehavior':
          config.hitTestBehavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onPageChanged':
          config.onPageChanged = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'padEnds':
          config.padEnds = toBool(value);
          break;
        case 'pageSnapping':
          config.pageSnapping = toBool(value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'reverse':
          config.reverse = toBool(value);
          break;
        case 'scrollBehavior':
          config.scrollBehavior = parseGeneratedScrollBehavior(value);
          break;
        case 'scrollDirection':
          config.scrollDirection = parseGeneratedAxis(value);
          break;
        default:
          handleUnknownArg('page_view', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedPageViewTagConfig {
  bool? allowImplicitScrolling;
  Clip? clipBehavior;
  PageController? controller;
  DragStartBehavior? dragStartBehavior;
  HitTestBehavior? hitTestBehavior;
  Key? key;
  ValueChanged<int>? onPageChanged;
  bool? padEnds;
  bool? pageSnapping;
  ScrollPhysics? physics;
  String? restorationId;
  bool? reverse;
  ScrollBehavior? scrollBehavior;
  Axis? scrollDirection;
}

PageView _buildGeneratedPageViewTagWidget(_GeneratedPageViewTagConfig config, List<Widget> children) {
  return PageView(
    allowImplicitScrolling: config.allowImplicitScrolling ?? false,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    controller: config.controller,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    hitTestBehavior: config.hitTestBehavior ?? HitTestBehavior.opaque,
    key: config.key,
    onPageChanged: config.onPageChanged,
    padEnds: config.padEnds ?? true,
    pageSnapping: config.pageSnapping ?? true,
    physics: config.physics,
    restorationId: config.restorationId,
    reverse: config.reverse ?? false,
    scrollBehavior: config.scrollBehavior,
    scrollDirection: config.scrollDirection ?? Axis.horizontal,
    children: children,
  );
}


class GeneratedPaginatedDataTableTag extends WidgetTagBase with AsyncTag {
  GeneratedPaginatedDataTableTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedPaginatedDataTableTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedPaginatedDataTableTagWidget(config, children));
  }

  _GeneratedPaginatedDataTableTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPaginatedDataTableTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'actions':
          config.actions = value;
          break;
        case 'arrowHeadColor':
          config.arrowHeadColor = parseGeneratedColor(value);
          break;
        case 'availableRowsPerPage':
          config.availableRowsPerPage = parseGeneratedListOfInt(value);
          break;
        case 'checkboxHorizontalMargin':
          config.checkboxHorizontalMargin = toDouble(value);
          break;
        case 'columnSpacing':
          config.columnSpacing = toDouble(value);
          break;
        case 'columns':
          config.columns = parseGeneratedListOfDataColumn(value);
          break;
        case 'controller':
          config.controller = parseGeneratedScrollController(evaluator, value);
          break;
        case 'dataRowHeight':
          config.dataRowHeight = toDouble(value);
          break;
        case 'dataRowMaxHeight':
          config.dataRowMaxHeight = toDouble(value);
          break;
        case 'dataRowMinHeight':
          config.dataRowMinHeight = toDouble(value);
          break;
        case 'dividerThickness':
          config.dividerThickness = toDouble(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'header':
          config.header = resolveWidget(value);
          break;
        case 'headingRowColor':
          config.headingRowColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'headingRowHeight':
          config.headingRowHeight = toDouble(value);
          break;
        case 'horizontalMargin':
          config.horizontalMargin = toDouble(value);
          break;
        case 'initialFirstRowIndex':
          config.initialFirstRowIndex = toInt(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onPageChanged':
          config.onPageChanged = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'onRowsPerPageChanged':
          config.onRowsPerPageChanged = (value is ValueChanged<int?> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int?>?);
          break;
        case 'onSelectAll':
          config.onSelectAll = (value is ValueSetter<bool?> ? value : resolveGenericValueChanged(evaluator, value) as ValueSetter<bool?>?);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'rowsPerPage':
          config.rowsPerPage = toInt(value);
          break;
        case 'showCheckboxColumn':
          config.showCheckboxColumn = toBool(value);
          break;
        case 'showEmptyRows':
          config.showEmptyRows = toBool(value);
          break;
        case 'showFirstLastButtons':
          config.showFirstLastButtons = toBool(value);
          break;
        case 'sortAscending':
          config.sortAscending = toBool(value);
          break;
        case 'sortColumnIndex':
          config.sortColumnIndex = toInt(value);
          break;
        case 'source':
          config.source = parseGeneratedDataTableSource(value);
          break;
        default:
          handleUnknownArg('paginated_data_table', name);
          break;
      }
    }
    if (config.columns == null) {
      throw Exception('paginated_data_table tag requires "columns"');
    }
    if (config.source == null) {
      throw Exception('paginated_data_table tag requires "source"');
    }
    return config;
  }
}

class _GeneratedPaginatedDataTableTagConfig {
  List<Widget>? actions;
  Color? arrowHeadColor;
  List<int>? availableRowsPerPage;
  double? checkboxHorizontalMargin;
  double? columnSpacing;
  List<DataColumn>? columns;
  ScrollController? controller;
  double? dataRowHeight;
  double? dataRowMaxHeight;
  double? dataRowMinHeight;
  double? dividerThickness;
  DragStartBehavior? dragStartBehavior;
  Widget? header;
  WidgetStateProperty<Color?>? headingRowColor;
  double? headingRowHeight;
  double? horizontalMargin;
  int? initialFirstRowIndex;
  Key? key;
  ValueChanged<int>? onPageChanged;
  ValueChanged<int?>? onRowsPerPageChanged;
  ValueSetter<bool?>? onSelectAll;
  bool? primary;
  int? rowsPerPage;
  bool? showCheckboxColumn;
  bool? showEmptyRows;
  bool? showFirstLastButtons;
  bool? sortAscending;
  int? sortColumnIndex;
  DataTableSource? source;
}

PaginatedDataTable _buildGeneratedPaginatedDataTableTagWidget(_GeneratedPaginatedDataTableTagConfig config, List<Widget> children) {
  return PaginatedDataTable(
    actions: config.actions,
    arrowHeadColor: config.arrowHeadColor,
    availableRowsPerPage: config.availableRowsPerPage ?? const <int>[PaginatedDataTable.defaultRowsPerPage, PaginatedDataTable.defaultRowsPerPage * 2, PaginatedDataTable.defaultRowsPerPage * 5, PaginatedDataTable.defaultRowsPerPage * 10],
    checkboxHorizontalMargin: config.checkboxHorizontalMargin,
    columnSpacing: config.columnSpacing ?? 56.0,
    columns: config.columns!,
    controller: config.controller,
    dataRowHeight: config.dataRowHeight,
    dataRowMaxHeight: config.dataRowMaxHeight,
    dataRowMinHeight: config.dataRowMinHeight,
    dividerThickness: config.dividerThickness,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    header: config.header,
    headingRowColor: config.headingRowColor,
    headingRowHeight: config.headingRowHeight ?? 56.0,
    horizontalMargin: config.horizontalMargin ?? 24.0,
    initialFirstRowIndex: config.initialFirstRowIndex ?? 0,
    key: config.key,
    onPageChanged: config.onPageChanged,
    onRowsPerPageChanged: config.onRowsPerPageChanged,
    onSelectAll: config.onSelectAll,
    primary: config.primary,
    rowsPerPage: config.rowsPerPage ?? PaginatedDataTable.defaultRowsPerPage,
    showCheckboxColumn: config.showCheckboxColumn ?? true,
    showEmptyRows: config.showEmptyRows ?? true,
    showFirstLastButtons: config.showFirstLastButtons ?? false,
    sortAscending: config.sortAscending ?? true,
    sortColumnIndex: config.sortColumnIndex,
    source: config.source!,
  );
}


class GeneratedPhysicalModelTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedPhysicalModelTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedPhysicalModelTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedPhysicalModelTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('physical_model').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endphysical_model').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'physical_model',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedPhysicalModelTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPhysicalModelTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'borderRadius':
          config.borderRadius = parseGeneratedBorderRadius(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedBoxShape(value);
          break;
        default:
          handleUnknownArg('physical_model', name);
          break;
      }
    }
    if (config.color == null) {
      throw Exception('physical_model tag requires "color"');
    }
    return config;
  }
}

class _GeneratedPhysicalModelTagConfig {
  BorderRadius? borderRadius;
  Clip? clipBehavior;
  Color? color;
  double? elevation;
  Key? key;
  Color? shadowColor;
  BoxShape? shape;
}

PhysicalModel _buildGeneratedPhysicalModelTagWidget(_GeneratedPhysicalModelTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return PhysicalModel(
    borderRadius: config.borderRadius,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color!,
    elevation: config.elevation ?? 0.0,
    key: config.key,
    shadowColor: config.shadowColor ?? const Color(0xFF000000),
    shape: config.shape ?? BoxShape.rectangle,
    child: child,
  );
}


class GeneratedPlaceholderTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedPlaceholderTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedPlaceholderTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedPlaceholderTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('placeholder').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endplaceholder').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'placeholder',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedPlaceholderTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPlaceholderTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'fallbackHeight':
          config.fallbackHeight = toDouble(value);
          break;
        case 'fallbackWidth':
          config.fallbackWidth = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'strokeWidth':
          config.strokeWidth = toDouble(value);
          break;
        default:
          handleUnknownArg('placeholder', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedPlaceholderTagConfig {
  Color? color;
  double? fallbackHeight;
  double? fallbackWidth;
  Key? key;
  double? strokeWidth;
}

Placeholder _buildGeneratedPlaceholderTagWidget(_GeneratedPlaceholderTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Placeholder(
    color: config.color ?? const Color(0xFF455A64),
    fallbackHeight: config.fallbackHeight ?? 400.0,
    fallbackWidth: config.fallbackWidth ?? 400.0,
    key: config.key,
    strokeWidth: config.strokeWidth ?? 2.0,
    child: child,
  );
}


class GeneratedPopupMenuButtonTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedPopupMenuButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedPopupMenuButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedPopupMenuButtonTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('popup_menu_button').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endpopup_menu_button').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'popup_menu_button',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedPopupMenuButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPopupMenuButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'borderRadius':
          config.borderRadius = parseGeneratedBorderRadius(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'iconColor':
          config.iconColor = parseGeneratedColor(value);
          break;
        case 'iconSize':
          config.iconSize = toDouble(value);
          break;
        case 'initialValue':
          config.initialValue = parseGeneratedObject(evaluator, value);
          break;
        case 'itemBuilder':
          config.itemBuilder = (value is PopupMenuItemBuilder<Object?> ? value : resolveBuildContextCallback(evaluator, value) as PopupMenuItemBuilder<Object?>?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'menuPadding':
          config.menuPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'offset':
          config.offset = parseGeneratedOffset(value);
          break;
        case 'onCanceled':
          config.onCanceled = resolveActionCallback(evaluator, value);
          break;
        case 'onOpened':
          config.onOpened = resolveActionCallback(evaluator, value);
          break;
        case 'onSelected':
          config.onSelected = (value is PopupMenuItemSelected<Object?> ? value : resolveGenericValueChanged(evaluator, value) as PopupMenuItemSelected<Object?>?);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'popUpAnimationStyle':
          config.popUpAnimationStyle = parseGeneratedAnimationStyle(value);
          break;
        case 'position':
          config.position = parseGeneratedPopupMenuPosition(value);
          break;
        case 'requestFocus':
          config.requestFocus = toBool(value);
          break;
        case 'routeSettings':
          config.routeSettings = parseGeneratedRouteSettings(evaluator, value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'splashRadius':
          config.splashRadius = toDouble(value);
          break;
        case 'style':
          config.style = parseGeneratedButtonStyle(evaluator, value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'tooltip':
          config.tooltip = toStringValue(value);
          break;
        case 'useRootNavigator':
          config.useRootNavigator = toBool(value);
          break;
        default:
          handleUnknownArg('popup_menu_button', name);
          break;
      }
    }
    if (config.itemBuilder == null) {
      throw Exception('popup_menu_button tag requires "itemBuilder"');
    }
    return config;
  }
}

class _GeneratedPopupMenuButtonTagConfig {
  BorderRadius? borderRadius;
  Clip? clipBehavior;
  Color? color;
  BoxConstraints? constraints;
  double? elevation;
  bool? enableFeedback;
  bool? enabled;
  Widget? icon;
  Color? iconColor;
  double? iconSize;
  Object? initialValue;
  PopupMenuItemBuilder<Object?>? itemBuilder;
  Key? key;
  EdgeInsetsGeometry? menuPadding;
  Offset? offset;
  PopupMenuCanceled? onCanceled;
  VoidCallback? onOpened;
  PopupMenuItemSelected<Object?>? onSelected;
  EdgeInsetsGeometry? padding;
  AnimationStyle? popUpAnimationStyle;
  PopupMenuPosition? position;
  bool? requestFocus;
  RouteSettings? routeSettings;
  Color? shadowColor;
  ShapeBorder? shape;
  double? splashRadius;
  ButtonStyle? style;
  Color? surfaceTintColor;
  String? tooltip;
  bool? useRootNavigator;
}

PopupMenuButton _buildGeneratedPopupMenuButtonTagWidget(_GeneratedPopupMenuButtonTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return PopupMenuButton(
    borderRadius: config.borderRadius,
    clipBehavior: config.clipBehavior ?? Clip.none,
    color: config.color,
    constraints: config.constraints,
    elevation: config.elevation,
    enableFeedback: config.enableFeedback,
    enabled: config.enabled ?? true,
    icon: config.icon,
    iconColor: config.iconColor,
    iconSize: config.iconSize,
    initialValue: config.initialValue,
    itemBuilder: config.itemBuilder!,
    key: config.key,
    menuPadding: config.menuPadding,
    offset: config.offset ?? Offset.zero,
    onCanceled: config.onCanceled,
    onOpened: config.onOpened,
    onSelected: config.onSelected,
    padding: config.padding ?? const EdgeInsets.all(8.0),
    popUpAnimationStyle: config.popUpAnimationStyle,
    position: config.position,
    requestFocus: config.requestFocus,
    routeSettings: config.routeSettings,
    shadowColor: config.shadowColor,
    shape: config.shape,
    splashRadius: config.splashRadius,
    style: config.style,
    surfaceTintColor: config.surfaceTintColor,
    tooltip: config.tooltip,
    useRootNavigator: config.useRootNavigator ?? false,
    child: child,
  );
}


class GeneratedPopupMenuDividerTag extends WidgetTagBase with AsyncTag {
  GeneratedPopupMenuDividerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedPopupMenuDividerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedPopupMenuDividerTagWidget(config, children));
  }

  _GeneratedPopupMenuDividerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPopupMenuDividerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'endIndent':
          config.endIndent = toDouble(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'indent':
          config.indent = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'radius':
          config.radius = parseGeneratedBorderRadiusGeometry(value);
          break;
        case 'thickness':
          config.thickness = toDouble(value);
          break;
        default:
          handleUnknownArg('popup_menu_divider', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedPopupMenuDividerTagConfig {
  Color? color;
  double? endIndent;
  double? height;
  double? indent;
  Key? key;
  BorderRadiusGeometry? radius;
  double? thickness;
}

PopupMenuDivider _buildGeneratedPopupMenuDividerTagWidget(_GeneratedPopupMenuDividerTagConfig config, List<Widget> children) {
  return PopupMenuDivider(
    color: config.color,
    endIndent: config.endIndent,
    height: config.height ?? 16.0,
    indent: config.indent,
    key: config.key,
    radius: config.radius,
    thickness: config.thickness,
  );
}


class GeneratedPopupMenuItemTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedPopupMenuItemTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedPopupMenuItemTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedPopupMenuItemTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('popup_menu_item').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endpopup_menu_item').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'popup_menu_item',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedPopupMenuItemTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPopupMenuItemTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'labelTextStyle':
          config.labelTextStyle = (value is WidgetStateProperty<TextStyle?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<TextStyle?>?);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onTap':
          config.onTap = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsets(value);
          break;
        case 'textStyle':
          config.textStyle = parseGeneratedTextStyle(value);
          break;
        case 'value':
          config.value = parseGeneratedObject(evaluator, value);
          break;
        default:
          handleUnknownArg('popup_menu_item', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedPopupMenuItemTagConfig {
  bool? enabled;
  double? height;
  Key? key;
  WidgetStateProperty<TextStyle?>? labelTextStyle;
  MouseCursor? mouseCursor;
  VoidCallback? onTap;
  EdgeInsets? padding;
  TextStyle? textStyle;
  Object? value;
}

PopupMenuItem _buildGeneratedPopupMenuItemTagWidget(_GeneratedPopupMenuItemTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return PopupMenuItem(
    enabled: config.enabled ?? true,
    height: config.height ?? kMinInteractiveDimension,
    key: config.key,
    labelTextStyle: config.labelTextStyle,
    mouseCursor: config.mouseCursor,
    onTap: config.onTap,
    padding: config.padding,
    textStyle: config.textStyle,
    value: config.value,
    child: child,
  );
}


class GeneratedPositionedTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedPositionedTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedPositionedTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedPositionedTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('positioned').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endpositioned').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'positioned',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedPositionedTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedPositionedTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'bottom':
          config.bottom = toDouble(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'left':
          config.left = toDouble(value);
          break;
        case 'right':
          config.right = toDouble(value);
          break;
        case 'top':
          config.top = toDouble(value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('positioned', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedPositionedTagConfig {
  double? bottom;
  double? height;
  Key? key;
  double? left;
  double? right;
  double? top;
  double? width;
}

Positioned _buildGeneratedPositionedTagWidget(_GeneratedPositionedTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return Positioned(
    bottom: config.bottom,
    height: config.height,
    key: config.key,
    left: config.left,
    right: config.right,
    top: config.top,
    width: config.width,
    child: child,
  );
}


class GeneratedReorderableListViewTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedReorderableListViewTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedReorderableListViewTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedReorderableListViewTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('reorderable_list_view').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endreorderable_list_view').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'reorderable_list_view',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedReorderableListViewTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedReorderableListViewTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'anchor':
          config.anchor = toDouble(value);
          break;
        case 'autoScrollerVelocityScalar':
          config.autoScrollerVelocityScalar = toDouble(value);
          break;
        case 'buildDefaultDragHandles':
          config.buildDefaultDragHandles = toBool(value);
          break;
        case 'cacheExtent':
          config.cacheExtent = toDouble(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'dragBoundaryProvider':
          config.dragBoundaryProvider = (value is ReorderDragBoundaryProvider ? value : resolveBuildContextCallback(evaluator, value) as ReorderDragBoundaryProvider?);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'footer':
          config.footer = resolveWidget(value);
          break;
        case 'header':
          config.header = resolveWidget(value);
          break;
        case 'itemExtent':
          config.itemExtent = toDouble(value);
          break;
        case 'itemExtentBuilder':
          config.itemExtentBuilder = (value is ItemExtentBuilder ? value : resolveGenericCallback2(evaluator, value) as ItemExtentBuilder?);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardDismissBehavior':
          config.keyboardDismissBehavior = parseGeneratedScrollViewKeyboardDismissBehavior(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onReorder':
          config.onReorder = resolveReorderActionCallback(evaluator, value);
          break;
        case 'onReorderEnd':
          config.onReorderEnd = resolveIntActionCallback(evaluator, value);
          break;
        case 'onReorderStart':
          config.onReorderStart = resolveIntActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsets(value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'prototypeItem':
          config.prototypeItem = resolveWidget(value);
          break;
        case 'proxyDecorator':
          config.proxyDecorator = (value is ReorderItemProxyDecorator ? value : resolveCallbackValue(evaluator, value) as ReorderItemProxyDecorator?);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'reverse':
          config.reverse = toBool(value);
          break;
        case 'scrollController':
          config.scrollController = parseGeneratedScrollController(evaluator, value);
          break;
        case 'scrollDirection':
          config.scrollDirection = parseGeneratedAxis(value);
          break;
        case 'shrinkWrap':
          config.shrinkWrap = toBool(value);
          break;
        default:
          handleUnknownArg('reorderable_list_view', name);
          break;
      }
    }
    if (config.onReorder == null) {
      throw Exception('reorderable_list_view tag requires "onReorder"');
    }
    return config;
  }
}

class _GeneratedReorderableListViewTagConfig {
  double? anchor;
  double? autoScrollerVelocityScalar;
  bool? buildDefaultDragHandles;
  double? cacheExtent;
  Clip? clipBehavior;
  ReorderDragBoundaryProvider? dragBoundaryProvider;
  DragStartBehavior? dragStartBehavior;
  Widget? footer;
  Widget? header;
  double? itemExtent;
  ItemExtentBuilder? itemExtentBuilder;
  Key? key;
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
  MouseCursor? mouseCursor;
  ReorderCallback? onReorder;
  void Function(int)? onReorderEnd;
  void Function(int)? onReorderStart;
  EdgeInsets? padding;
  ScrollPhysics? physics;
  bool? primary;
  Widget? prototypeItem;
  ReorderItemProxyDecorator? proxyDecorator;
  String? restorationId;
  bool? reverse;
  ScrollController? scrollController;
  Axis? scrollDirection;
  bool? shrinkWrap;
}

ReorderableListView _buildGeneratedReorderableListViewTagWidget(_GeneratedReorderableListViewTagConfig config, List<Widget> children) {
  return ReorderableListView(
    anchor: config.anchor ?? 0.0,
    autoScrollerVelocityScalar: config.autoScrollerVelocityScalar,
    buildDefaultDragHandles: config.buildDefaultDragHandles ?? true,
    cacheExtent: config.cacheExtent,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    dragBoundaryProvider: config.dragBoundaryProvider,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    footer: config.footer,
    header: config.header,
    itemExtent: config.itemExtent,
    itemExtentBuilder: config.itemExtentBuilder,
    key: config.key,
    keyboardDismissBehavior: config.keyboardDismissBehavior,
    mouseCursor: config.mouseCursor,
    onReorder: config.onReorder!,
    onReorderEnd: config.onReorderEnd,
    onReorderStart: config.onReorderStart,
    padding: config.padding,
    physics: config.physics,
    primary: config.primary,
    prototypeItem: config.prototypeItem,
    proxyDecorator: config.proxyDecorator,
    restorationId: config.restorationId,
    reverse: config.reverse ?? false,
    scrollController: config.scrollController,
    scrollDirection: config.scrollDirection ?? Axis.vertical,
    shrinkWrap: config.shrinkWrap ?? false,
    children: children,
  );
}


class GeneratedRepaintBoundaryTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedRepaintBoundaryTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedRepaintBoundaryTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedRepaintBoundaryTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('repaint_boundary').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endrepaint_boundary').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'repaint_boundary',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedRepaintBoundaryTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedRepaintBoundaryTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('repaint_boundary', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedRepaintBoundaryTagConfig {
  Key? key;
}

RepaintBoundary _buildGeneratedRepaintBoundaryTagWidget(_GeneratedRepaintBoundaryTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return RepaintBoundary(
    key: config.key,
    child: child,
  );
}


class GeneratedRotatedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedRotatedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedRotatedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedRotatedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('rotated_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endrotated_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'rotated_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedRotatedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedRotatedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'quarterTurns':
          config.quarterTurns = toInt(value);
          break;
        default:
          handleUnknownArg('rotated_box', name);
          break;
      }
    }
    if (config.quarterTurns == null) {
      throw Exception('rotated_box tag requires "quarterTurns"');
    }
    return config;
  }
}

class _GeneratedRotatedBoxTagConfig {
  Key? key;
  int? quarterTurns;
}

RotatedBox _buildGeneratedRotatedBoxTagWidget(_GeneratedRotatedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return RotatedBox(
    key: config.key,
    quarterTurns: config.quarterTurns!,
    child: child,
  );
}


class GeneratedRowTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedRowTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedRowTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedRowTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('row').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endrow').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'row',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedRowTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedRowTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'crossAxisAlignment':
          config.crossAxisAlignment = parseGeneratedCrossAxisAlignment(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'mainAxisAlignment':
          config.mainAxisAlignment = parseGeneratedMainAxisAlignment(value);
          break;
        case 'mainAxisSize':
          config.mainAxisSize = parseGeneratedMainAxisSize(value);
          break;
        case 'spacing':
          config.spacing = toDouble(value);
          break;
        case 'textBaseline':
          config.textBaseline = parseGeneratedTextBaseline(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'verticalDirection':
          config.verticalDirection = parseGeneratedVerticalDirection(value);
          break;
        default:
          handleUnknownArg('row', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedRowTagConfig {
  CrossAxisAlignment? crossAxisAlignment;
  Key? key;
  MainAxisAlignment? mainAxisAlignment;
  MainAxisSize? mainAxisSize;
  double? spacing;
  TextBaseline? textBaseline;
  TextDirection? textDirection;
  VerticalDirection? verticalDirection;
}

Row _buildGeneratedRowTagWidget(_GeneratedRowTagConfig config, List<Widget> children) {
  return Row(
    crossAxisAlignment: config.crossAxisAlignment ?? CrossAxisAlignment.center,
    key: config.key,
    mainAxisAlignment: config.mainAxisAlignment ?? MainAxisAlignment.start,
    mainAxisSize: config.mainAxisSize ?? MainAxisSize.max,
    spacing: config.spacing ?? 0.0,
    textBaseline: config.textBaseline,
    textDirection: config.textDirection,
    verticalDirection: config.verticalDirection ?? VerticalDirection.down,
    children: children,
  );
}


class GeneratedSafeAreaTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedSafeAreaTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedSafeAreaTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedSafeAreaTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('safe_area').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endsafe_area').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'safe_area',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedSafeAreaTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSafeAreaTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'bottom':
          config.bottom = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'left':
          config.left = toBool(value);
          break;
        case 'maintainBottomViewPadding':
          config.maintainBottomViewPadding = toBool(value);
          break;
        case 'minimum':
          config.minimum = parseGeneratedEdgeInsets(value);
          break;
        case 'right':
          config.right = toBool(value);
          break;
        case 'top':
          config.top = toBool(value);
          break;
        default:
          handleUnknownArg('safe_area', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSafeAreaTagConfig {
  bool? bottom;
  Key? key;
  bool? left;
  bool? maintainBottomViewPadding;
  EdgeInsets? minimum;
  bool? right;
  bool? top;
}

SafeArea _buildGeneratedSafeAreaTagWidget(_GeneratedSafeAreaTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return SafeArea(
    bottom: config.bottom ?? true,
    key: config.key,
    left: config.left ?? true,
    maintainBottomViewPadding: config.maintainBottomViewPadding ?? false,
    minimum: config.minimum ?? EdgeInsets.zero,
    right: config.right ?? true,
    top: config.top ?? true,
    child: child,
  );
}


class GeneratedScaffoldTag extends WidgetTagBase with AsyncTag {
  GeneratedScaffoldTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedScaffoldTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedScaffoldTagWidget(config, children));
  }

  _GeneratedScaffoldTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedScaffoldTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'appBar':
          config.appBar = (value is PreferredSizeWidget ? value : parsePreferredSizeWidget(value) as PreferredSizeWidget?);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'body':
          config.body = resolveWidget(value);
          break;
        case 'bottomNavigationBar':
          config.bottomNavigationBar = resolveWidget(value);
          break;
        case 'bottomSheet':
          config.bottomSheet = resolveWidget(value);
          break;
        case 'drawer':
          config.drawer = resolveWidget(value);
          break;
        case 'drawerBarrierDismissible':
          config.drawerBarrierDismissible = toBool(value);
          break;
        case 'drawerDragStartBehavior':
          config.drawerDragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'drawerEdgeDragWidth':
          config.drawerEdgeDragWidth = toDouble(value);
          break;
        case 'drawerEnableOpenDragGesture':
          config.drawerEnableOpenDragGesture = toBool(value);
          break;
        case 'drawerScrimColor':
          config.drawerScrimColor = parseGeneratedColor(value);
          break;
        case 'endDrawer':
          config.endDrawer = resolveWidget(value);
          break;
        case 'endDrawerEnableOpenDragGesture':
          config.endDrawerEnableOpenDragGesture = toBool(value);
          break;
        case 'extendBody':
          config.extendBody = toBool(value);
          break;
        case 'extendBodyBehindAppBar':
          config.extendBodyBehindAppBar = toBool(value);
          break;
        case 'floatingActionButton':
          config.floatingActionButton = resolveWidget(value);
          break;
        case 'floatingActionButtonAnimator':
          config.floatingActionButtonAnimator = parseGeneratedFloatingActionButtonAnimator(value);
          break;
        case 'floatingActionButtonLocation':
          config.floatingActionButtonLocation = parseGeneratedFloatingActionButtonLocation(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onDrawerChanged':
          config.onDrawerChanged = resolveBoolActionCallback(evaluator, value);
          break;
        case 'onEndDrawerChanged':
          config.onEndDrawerChanged = resolveBoolActionCallback(evaluator, value);
          break;
        case 'persistentFooterAlignment':
          config.persistentFooterAlignment = parseGeneratedAlignmentDirectional(value);
          break;
        case 'persistentFooterButtons':
          config.persistentFooterButtons = value;
          break;
        case 'persistentFooterDecoration':
          config.persistentFooterDecoration = parseGeneratedBoxDecoration(evaluator, value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'resizeToAvoidBottomInset':
          config.resizeToAvoidBottomInset = toBool(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        default:
          handleUnknownArg('scaffold', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedScaffoldTagConfig {
  PreferredSizeWidget? appBar;
  Color? backgroundColor;
  Widget? body;
  Widget? bottomNavigationBar;
  Widget? bottomSheet;
  Widget? drawer;
  bool? drawerBarrierDismissible;
  DragStartBehavior? drawerDragStartBehavior;
  double? drawerEdgeDragWidth;
  bool? drawerEnableOpenDragGesture;
  Color? drawerScrimColor;
  Widget? endDrawer;
  bool? endDrawerEnableOpenDragGesture;
  bool? extendBody;
  bool? extendBodyBehindAppBar;
  Widget? floatingActionButton;
  FloatingActionButtonAnimator? floatingActionButtonAnimator;
  FloatingActionButtonLocation? floatingActionButtonLocation;
  Key? key;
  DrawerCallback? onDrawerChanged;
  DrawerCallback? onEndDrawerChanged;
  AlignmentDirectional? persistentFooterAlignment;
  List<Widget>? persistentFooterButtons;
  BoxDecoration? persistentFooterDecoration;
  bool? primary;
  bool? resizeToAvoidBottomInset;
  String? restorationId;
}

Scaffold _buildGeneratedScaffoldTagWidget(_GeneratedScaffoldTagConfig config, List<Widget> children) {
  return Scaffold(
    appBar: config.appBar,
    backgroundColor: config.backgroundColor,
    body: config.body,
    bottomNavigationBar: config.bottomNavigationBar,
    bottomSheet: config.bottomSheet,
    drawer: config.drawer,
    drawerBarrierDismissible: config.drawerBarrierDismissible ?? true,
    drawerDragStartBehavior: config.drawerDragStartBehavior ?? DragStartBehavior.start,
    drawerEdgeDragWidth: config.drawerEdgeDragWidth,
    drawerEnableOpenDragGesture: config.drawerEnableOpenDragGesture ?? true,
    drawerScrimColor: config.drawerScrimColor,
    endDrawer: config.endDrawer,
    endDrawerEnableOpenDragGesture: config.endDrawerEnableOpenDragGesture ?? true,
    extendBody: config.extendBody ?? false,
    extendBodyBehindAppBar: config.extendBodyBehindAppBar ?? false,
    floatingActionButton: config.floatingActionButton,
    floatingActionButtonAnimator: config.floatingActionButtonAnimator,
    floatingActionButtonLocation: config.floatingActionButtonLocation,
    key: config.key,
    onDrawerChanged: config.onDrawerChanged,
    onEndDrawerChanged: config.onEndDrawerChanged,
    persistentFooterAlignment: config.persistentFooterAlignment ?? AlignmentDirectional.centerEnd,
    persistentFooterButtons: config.persistentFooterButtons,
    persistentFooterDecoration: config.persistentFooterDecoration,
    primary: config.primary ?? true,
    resizeToAvoidBottomInset: config.resizeToAvoidBottomInset,
    restorationId: config.restorationId,
  );
}


class GeneratedSegmentedButtonTag extends WidgetTagBase with AsyncTag {
  GeneratedSegmentedButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSegmentedButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSegmentedButtonTagWidget(config, children));
  }

  _GeneratedSegmentedButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSegmentedButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'direction':
          config.direction = parseGeneratedAxis(value);
          break;
        case 'emptySelectionAllowed':
          config.emptySelectionAllowed = toBool(value);
          break;
        case 'expandedInsets':
          config.expandedInsets = parseGeneratedEdgeInsets(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'multiSelectionEnabled':
          config.multiSelectionEnabled = toBool(value);
          break;
        case 'onSelectionChanged':
          config.onSelectionChanged = (value is void Function(Set< Object?>) ? value : resolveGenericValueChanged(evaluator, value) as void Function(Set< Object?>)?);
          break;
        case 'segments':
          config.segments = parseGeneratedListOfButtonSegmentObject(evaluator, value);
          break;
        case 'selected':
          config.selected = parseGeneratedSetOfObject(evaluator, value);
          break;
        case 'selectedIcon':
          config.selectedIcon = resolveWidget(value);
          break;
        case 'showSelectedIcon':
          config.showSelectedIcon = toBool(value);
          break;
        case 'style':
          config.style = parseGeneratedButtonStyle(evaluator, value);
          break;
        default:
          handleUnknownArg('segmented_button', name);
          break;
      }
    }
    if (config.segments == null) {
      throw Exception('segmented_button tag requires "segments"');
    }
    if (config.selected == null) {
      throw Exception('segmented_button tag requires "selected"');
    }
    return config;
  }
}

class _GeneratedSegmentedButtonTagConfig {
  Axis? direction;
  bool? emptySelectionAllowed;
  EdgeInsets? expandedInsets;
  Key? key;
  bool? multiSelectionEnabled;
  void Function(Set< Object?>)? onSelectionChanged;
  List<ButtonSegment<Object?>>? segments;
  Set<Object?>? selected;
  Widget? selectedIcon;
  bool? showSelectedIcon;
  ButtonStyle? style;
}

SegmentedButton _buildGeneratedSegmentedButtonTagWidget(_GeneratedSegmentedButtonTagConfig config, List<Widget> children) {
  return SegmentedButton(
    direction: config.direction ?? Axis.horizontal,
    emptySelectionAllowed: config.emptySelectionAllowed ?? false,
    expandedInsets: config.expandedInsets,
    key: config.key,
    multiSelectionEnabled: config.multiSelectionEnabled ?? false,
    onSelectionChanged: config.onSelectionChanged,
    segments: config.segments!,
    selected: config.selected!,
    selectedIcon: config.selectedIcon,
    showSelectedIcon: config.showSelectedIcon ?? true,
    style: config.style,
  );
}


class GeneratedSelectableTextTag extends WidgetTagBase with AsyncTag {
  GeneratedSelectableTextTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSelectableTextTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSelectableTextTagWidget(config, children));
  }

  _GeneratedSelectableTextTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSelectableTextTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'contextMenuBuilder':
          config.contextMenuBuilder = (value is EditableTextContextMenuBuilder ? value : resolveWidgetBuilder2Callback(evaluator, value) as EditableTextContextMenuBuilder?);
          break;
        case 'cursorColor':
          config.cursorColor = parseGeneratedColor(value);
          break;
        case 'cursorHeight':
          config.cursorHeight = toDouble(value);
          break;
        case 'cursorRadius':
          config.cursorRadius = parseGeneratedRadius(value);
          break;
        case 'cursorWidth':
          config.cursorWidth = toDouble(value);
          break;
        case 'data':
          config.data = toStringValue(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'enableInteractiveSelection':
          config.enableInteractiveSelection = toBool(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'magnifierConfiguration':
          config.magnifierConfiguration = parseGeneratedTextMagnifierConfiguration(evaluator, value);
          break;
        case 'maxLines':
          config.maxLines = toInt(value);
          break;
        case 'minLines':
          config.minLines = toInt(value);
          break;
        case 'onSelectionChanged':
          config.onSelectionChanged = (value is SelectionChangedCallback ? value : resolveGenericActionCallback2(evaluator, value) as SelectionChangedCallback?);
          break;
        case 'onTap':
          config.onTap = resolveActionCallback(evaluator, value);
          break;
        case 'scrollBehavior':
          config.scrollBehavior = parseGeneratedScrollBehavior(value);
          break;
        case 'scrollPhysics':
          config.scrollPhysics = parseGeneratedScrollPhysics(value);
          break;
        case 'selectionColor':
          config.selectionColor = parseGeneratedColor(value);
          break;
        case 'selectionControls':
          config.selectionControls = parseGeneratedTextSelectionControls(value);
          break;
        case 'selectionHeightStyle':
          config.selectionHeightStyle = parseGeneratedBoxHeightStyle(value);
          break;
        case 'selectionWidthStyle':
          config.selectionWidthStyle = parseGeneratedBoxWidthStyle(value);
          break;
        case 'semanticsLabel':
          config.semanticsLabel = toStringValue(value);
          break;
        case 'showCursor':
          config.showCursor = toBool(value);
          break;
        case 'strutStyle':
          config.strutStyle = parseGeneratedStrutStyle(value);
          break;
        case 'style':
          config.style = parseGeneratedTextStyle(value);
          break;
        case 'textAlign':
          config.textAlign = parseGeneratedTextAlign(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'textHeightBehavior':
          config.textHeightBehavior = parseGeneratedTextHeightBehavior(value);
          break;
        case 'textScaleFactor':
          config.textScaleFactor = toDouble(value);
          break;
        case 'textScaler':
          config.textScaler = parseGeneratedTextScaler(value);
          break;
        case 'textWidthBasis':
          config.textWidthBasis = parseGeneratedTextWidthBasis(value);
          break;
        case 'toolbarOptions':
          config.toolbarOptions = parseGeneratedToolbarOptions(value);
          break;
        default:
          handleUnknownArg('selectable_text', name);
          break;
      }
    }
    if (config.data == null) {
      throw Exception('selectable_text tag requires "data"');
    }
    return config;
  }
}

class _GeneratedSelectableTextTagConfig {
  bool? autofocus;
  EditableTextContextMenuBuilder? contextMenuBuilder;
  Color? cursorColor;
  double? cursorHeight;
  Radius? cursorRadius;
  double? cursorWidth;
  String? data;
  DragStartBehavior? dragStartBehavior;
  bool? enableInteractiveSelection;
  FocusNode? focusNode;
  Key? key;
  TextMagnifierConfiguration? magnifierConfiguration;
  int? maxLines;
  int? minLines;
  SelectionChangedCallback? onSelectionChanged;
  GestureTapCallback? onTap;
  ScrollBehavior? scrollBehavior;
  ScrollPhysics? scrollPhysics;
  Color? selectionColor;
  TextSelectionControls? selectionControls;
  BoxHeightStyle? selectionHeightStyle;
  BoxWidthStyle? selectionWidthStyle;
  String? semanticsLabel;
  bool? showCursor;
  StrutStyle? strutStyle;
  TextStyle? style;
  TextAlign? textAlign;
  TextDirection? textDirection;
  TextHeightBehavior? textHeightBehavior;
  double? textScaleFactor;
  TextScaler? textScaler;
  TextWidthBasis? textWidthBasis;
  ToolbarOptions? toolbarOptions;
}

SelectableText _buildGeneratedSelectableTextTagWidget(_GeneratedSelectableTextTagConfig config, List<Widget> children) {
  return SelectableText(
    config.data!,
    autofocus: config.autofocus ?? false,
    contextMenuBuilder: config.contextMenuBuilder,
    cursorColor: config.cursorColor,
    cursorHeight: config.cursorHeight,
    cursorRadius: config.cursorRadius,
    cursorWidth: config.cursorWidth ?? 2.0,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    enableInteractiveSelection: config.enableInteractiveSelection ?? true,
    focusNode: config.focusNode,
    key: config.key,
    magnifierConfiguration: config.magnifierConfiguration,
    maxLines: config.maxLines,
    minLines: config.minLines,
    onSelectionChanged: config.onSelectionChanged,
    onTap: config.onTap,
    scrollBehavior: config.scrollBehavior,
    scrollPhysics: config.scrollPhysics,
    selectionColor: config.selectionColor,
    selectionControls: config.selectionControls,
    selectionHeightStyle: config.selectionHeightStyle,
    selectionWidthStyle: config.selectionWidthStyle,
    semanticsLabel: config.semanticsLabel,
    showCursor: config.showCursor ?? false,
    strutStyle: config.strutStyle,
    style: config.style,
    textAlign: config.textAlign,
    textDirection: config.textDirection,
    textHeightBehavior: config.textHeightBehavior,
    textScaleFactor: config.textScaleFactor,
    textScaler: config.textScaler,
    textWidthBasis: config.textWidthBasis,
    toolbarOptions: config.toolbarOptions,
  );
}


class GeneratedShaderMaskTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedShaderMaskTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedShaderMaskTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedShaderMaskTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('shader_mask').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endshader_mask').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'shader_mask',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedShaderMaskTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedShaderMaskTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'blendMode':
          config.blendMode = parseGeneratedBlendMode(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'shaderCallback':
          config.shaderCallback = (value is ShaderCallback ? value : resolveGenericCallback1(evaluator, value) as ShaderCallback?);
          break;
        default:
          handleUnknownArg('shader_mask', name);
          break;
      }
    }
    if (config.shaderCallback == null) {
      throw Exception('shader_mask tag requires "shaderCallback"');
    }
    return config;
  }
}

class _GeneratedShaderMaskTagConfig {
  BlendMode? blendMode;
  Key? key;
  ShaderCallback? shaderCallback;
}

ShaderMask _buildGeneratedShaderMaskTagWidget(_GeneratedShaderMaskTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return ShaderMask(
    blendMode: config.blendMode ?? BlendMode.modulate,
    key: config.key,
    shaderCallback: config.shaderCallback!,
    child: child,
  );
}


class GeneratedSimpleDialogTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedSimpleDialogTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedSimpleDialogTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedSimpleDialogTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('simple_dialog').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endsimple_dialog').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'simple_dialog',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedSimpleDialogTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSimpleDialogTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'contentPadding':
          config.contentPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'insetPadding':
          config.insetPadding = parseGeneratedEdgeInsets(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'semanticLabel':
          config.semanticLabel = toStringValue(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'titlePadding':
          config.titlePadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'titleTextStyle':
          config.titleTextStyle = parseGeneratedTextStyle(value);
          break;
        default:
          handleUnknownArg('simple_dialog', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSimpleDialogTagConfig {
  AlignmentGeometry? alignment;
  Color? backgroundColor;
  Clip? clipBehavior;
  BoxConstraints? constraints;
  EdgeInsetsGeometry? contentPadding;
  double? elevation;
  EdgeInsets? insetPadding;
  Key? key;
  String? semanticLabel;
  Color? shadowColor;
  ShapeBorder? shape;
  Color? surfaceTintColor;
  Widget? title;
  EdgeInsetsGeometry? titlePadding;
  TextStyle? titleTextStyle;
}

SimpleDialog _buildGeneratedSimpleDialogTagWidget(_GeneratedSimpleDialogTagConfig config, List<Widget> children) {
  return SimpleDialog(
    alignment: config.alignment,
    backgroundColor: config.backgroundColor,
    clipBehavior: config.clipBehavior,
    constraints: config.constraints,
    contentPadding: config.contentPadding ?? const EdgeInsets.fromLTRB(0.0, 12.0, 0.0, 16.0),
    elevation: config.elevation,
    insetPadding: config.insetPadding,
    key: config.key,
    semanticLabel: config.semanticLabel,
    shadowColor: config.shadowColor,
    shape: config.shape,
    surfaceTintColor: config.surfaceTintColor,
    title: config.title,
    titlePadding: config.titlePadding ?? const EdgeInsets.fromLTRB(24.0, 24.0, 24.0, 0.0),
    titleTextStyle: config.titleTextStyle,
    children: children,
  );
}


class GeneratedSingleChildScrollViewTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedSingleChildScrollViewTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedSingleChildScrollViewTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedSingleChildScrollViewTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('single_child_scroll_view').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endsingle_child_scroll_view').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'single_child_scroll_view',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedSingleChildScrollViewTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSingleChildScrollViewTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'controller':
          config.controller = parseGeneratedScrollController(evaluator, value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'hitTestBehavior':
          config.hitTestBehavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardDismissBehavior':
          config.keyboardDismissBehavior = parseGeneratedScrollViewKeyboardDismissBehavior(value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'reverse':
          config.reverse = toBool(value);
          break;
        case 'scrollDirection':
          config.scrollDirection = parseGeneratedAxis(value);
          break;
        default:
          handleUnknownArg('single_child_scroll_view', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSingleChildScrollViewTagConfig {
  Clip? clipBehavior;
  ScrollController? controller;
  DragStartBehavior? dragStartBehavior;
  HitTestBehavior? hitTestBehavior;
  Key? key;
  ScrollViewKeyboardDismissBehavior? keyboardDismissBehavior;
  EdgeInsetsGeometry? padding;
  ScrollPhysics? physics;
  bool? primary;
  String? restorationId;
  bool? reverse;
  Axis? scrollDirection;
}

SingleChildScrollView _buildGeneratedSingleChildScrollViewTagWidget(_GeneratedSingleChildScrollViewTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return SingleChildScrollView(
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    controller: config.controller,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    hitTestBehavior: config.hitTestBehavior ?? HitTestBehavior.opaque,
    key: config.key,
    keyboardDismissBehavior: config.keyboardDismissBehavior,
    padding: config.padding,
    physics: config.physics,
    primary: config.primary,
    restorationId: config.restorationId,
    reverse: config.reverse ?? false,
    scrollDirection: config.scrollDirection ?? Axis.vertical,
    child: child,
  );
}


class GeneratedSizedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedSizedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedSizedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedSizedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('sized_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endsized_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'sized_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedSizedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSizedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'height':
          config.height = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('sized_box', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSizedBoxTagConfig {
  double? height;
  Key? key;
  double? width;
}

SizedBox _buildGeneratedSizedBoxTagWidget(_GeneratedSizedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return SizedBox(
    height: config.height,
    key: config.key,
    width: config.width,
    child: child,
  );
}


class GeneratedSizedOverflowBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedSizedOverflowBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedSizedOverflowBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedSizedOverflowBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('sized_overflow_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endsized_overflow_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'sized_overflow_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedSizedOverflowBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSizedOverflowBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'size':
          config.size = parseGeneratedSize(value);
          break;
        default:
          handleUnknownArg('sized_overflow_box', name);
          break;
      }
    }
    if (config.size == null) {
      throw Exception('sized_overflow_box tag requires "size"');
    }
    return config;
  }
}

class _GeneratedSizedOverflowBoxTagConfig {
  AlignmentGeometry? alignment;
  Key? key;
  Size? size;
}

SizedOverflowBox _buildGeneratedSizedOverflowBoxTagWidget(_GeneratedSizedOverflowBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return SizedOverflowBox(
    alignment: config.alignment ?? Alignment.center,
    key: config.key,
    size: config.size!,
    child: child,
  );
}


class GeneratedSliderTag extends WidgetTagBase with AsyncTag {
  GeneratedSliderTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliderTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliderTagWidget(config, children));
  }

  _GeneratedSliderTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliderTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'activeColor':
          config.activeColor = parseGeneratedColor(value);
          break;
        case 'allowedInteraction':
          config.allowedInteraction = parseGeneratedSliderInteraction(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'divisions':
          config.divisions = toInt(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'inactiveColor':
          config.inactiveColor = parseGeneratedColor(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = toStringValue(value);
          break;
        case 'max':
          config.max = toDouble(value);
          break;
        case 'min':
          config.min = toDouble(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onChangeEnd':
          config.onChangeEnd = (value is ValueChanged<double> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<double>?);
          break;
        case 'onChangeStart':
          config.onChangeStart = (value is ValueChanged<double> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<double>?);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<double> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<double>?);
          break;
        case 'overlayColor':
          config.overlayColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'secondaryActiveColor':
          config.secondaryActiveColor = parseGeneratedColor(value);
          break;
        case 'secondaryTrackValue':
          config.secondaryTrackValue = toDouble(value);
          break;
        case 'semanticFormatterCallback':
          config.semanticFormatterCallback = (value is SemanticFormatterCallback ? value : resolveGenericCallback1(evaluator, value) as SemanticFormatterCallback?);
          break;
        case 'thumbColor':
          config.thumbColor = parseGeneratedColor(value);
          break;
        case 'value':
          config.value = toDouble(value);
          break;
        case 'year2023':
          config.year2023 = toBool(value);
          break;
        default:
          handleUnknownArg('slider', name);
          break;
      }
    }
    if (config.onChanged == null) {
      throw Exception('slider tag requires "onChanged"');
    }
    if (config.value == null) {
      throw Exception('slider tag requires "value"');
    }
    return config;
  }
}

class _GeneratedSliderTagConfig {
  Color? activeColor;
  SliderInteraction? allowedInteraction;
  bool? autofocus;
  int? divisions;
  FocusNode? focusNode;
  Color? inactiveColor;
  Key? key;
  String? label;
  double? max;
  double? min;
  MouseCursor? mouseCursor;
  ValueChanged<double>? onChangeEnd;
  ValueChanged<double>? onChangeStart;
  ValueChanged<double>? onChanged;
  WidgetStateProperty<Color?>? overlayColor;
  EdgeInsetsGeometry? padding;
  Color? secondaryActiveColor;
  double? secondaryTrackValue;
  SemanticFormatterCallback? semanticFormatterCallback;
  Color? thumbColor;
  double? value;
  bool? year2023;
}

Slider _buildGeneratedSliderTagWidget(_GeneratedSliderTagConfig config, List<Widget> children) {
  return Slider(
    activeColor: config.activeColor,
    allowedInteraction: config.allowedInteraction,
    autofocus: config.autofocus ?? false,
    divisions: config.divisions,
    focusNode: config.focusNode,
    inactiveColor: config.inactiveColor,
    key: config.key,
    label: config.label,
    max: config.max ?? 1.0,
    min: config.min ?? 0.0,
    mouseCursor: config.mouseCursor,
    onChangeEnd: config.onChangeEnd,
    onChangeStart: config.onChangeStart,
    onChanged: config.onChanged,
    overlayColor: config.overlayColor,
    padding: config.padding,
    secondaryActiveColor: config.secondaryActiveColor,
    secondaryTrackValue: config.secondaryTrackValue,
    semanticFormatterCallback: config.semanticFormatterCallback,
    thumbColor: config.thumbColor,
    value: config.value!,
    year2023: config.year2023,
  );
}


class GeneratedSliverAppBarTag extends WidgetTagBase with AsyncTag {
  GeneratedSliverAppBarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverAppBarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverAppBarTagWidget(config, children));
  }

  _GeneratedSliverAppBarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliverAppBarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'actions':
          config.actions = value;
          break;
        case 'actionsIconTheme':
          config.actionsIconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'actionsPadding':
          config.actionsPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'automaticallyImplyActions':
          config.automaticallyImplyActions = toBool(value);
          break;
        case 'automaticallyImplyLeading':
          config.automaticallyImplyLeading = toBool(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'bottom':
          config.bottom = (value is PreferredSizeWidget ? value : parsePreferredSizeWidget(value) as PreferredSizeWidget?);
          break;
        case 'centerTitle':
          config.centerTitle = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'collapsedHeight':
          config.collapsedHeight = toDouble(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'excludeHeaderSemantics':
          config.excludeHeaderSemantics = toBool(value);
          break;
        case 'expandedHeight':
          config.expandedHeight = toDouble(value);
          break;
        case 'flexibleSpace':
          config.flexibleSpace = resolveWidget(value);
          break;
        case 'floating':
          config.floating = toBool(value);
          break;
        case 'forceElevated':
          config.forceElevated = toBool(value);
          break;
        case 'forceMaterialTransparency':
          config.forceMaterialTransparency = toBool(value);
          break;
        case 'foregroundColor':
          config.foregroundColor = parseGeneratedColor(value);
          break;
        case 'iconTheme':
          config.iconTheme = parseGeneratedIconThemeData(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'leading':
          config.leading = resolveWidget(value);
          break;
        case 'leadingWidth':
          config.leadingWidth = toDouble(value);
          break;
        case 'onStretchTrigger':
          config.onStretchTrigger = parseAsyncCallback(evaluator, value);
          break;
        case 'pinned':
          config.pinned = toBool(value);
          break;
        case 'primary':
          config.primary = toBool(value);
          break;
        case 'scrolledUnderElevation':
          config.scrolledUnderElevation = toDouble(value);
          break;
        case 'shadowColor':
          config.shadowColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'snap':
          config.snap = toBool(value);
          break;
        case 'stretch':
          config.stretch = toBool(value);
          break;
        case 'stretchTriggerOffset':
          config.stretchTriggerOffset = toDouble(value);
          break;
        case 'surfaceTintColor':
          config.surfaceTintColor = parseGeneratedColor(value);
          break;
        case 'systemOverlayStyle':
          config.systemOverlayStyle = parseGeneratedSystemUiOverlayStyle(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'titleSpacing':
          config.titleSpacing = toDouble(value);
          break;
        case 'titleTextStyle':
          config.titleTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'toolbarHeight':
          config.toolbarHeight = toDouble(value);
          break;
        case 'toolbarTextStyle':
          config.toolbarTextStyle = parseGeneratedTextStyle(value);
          break;
        case 'useDefaultSemanticsOrder':
          config.useDefaultSemanticsOrder = toBool(value);
          break;
        default:
          handleUnknownArg('sliver_app_bar', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSliverAppBarTagConfig {
  List<Widget>? actions;
  IconThemeData? actionsIconTheme;
  EdgeInsetsGeometry? actionsPadding;
  bool? automaticallyImplyActions;
  bool? automaticallyImplyLeading;
  Color? backgroundColor;
  PreferredSizeWidget? bottom;
  bool? centerTitle;
  Clip? clipBehavior;
  double? collapsedHeight;
  double? elevation;
  bool? excludeHeaderSemantics;
  double? expandedHeight;
  Widget? flexibleSpace;
  bool? floating;
  bool? forceElevated;
  bool? forceMaterialTransparency;
  Color? foregroundColor;
  IconThemeData? iconTheme;
  Key? key;
  Widget? leading;
  double? leadingWidth;
  AsyncCallback? onStretchTrigger;
  bool? pinned;
  bool? primary;
  double? scrolledUnderElevation;
  Color? shadowColor;
  ShapeBorder? shape;
  bool? snap;
  bool? stretch;
  double? stretchTriggerOffset;
  Color? surfaceTintColor;
  SystemUiOverlayStyle? systemOverlayStyle;
  Widget? title;
  double? titleSpacing;
  TextStyle? titleTextStyle;
  double? toolbarHeight;
  TextStyle? toolbarTextStyle;
  bool? useDefaultSemanticsOrder;
}

SliverAppBar _buildGeneratedSliverAppBarTagWidget(_GeneratedSliverAppBarTagConfig config, List<Widget> children) {
  return SliverAppBar(
    actions: config.actions,
    actionsIconTheme: config.actionsIconTheme,
    actionsPadding: config.actionsPadding,
    automaticallyImplyActions: config.automaticallyImplyActions ?? true,
    automaticallyImplyLeading: config.automaticallyImplyLeading ?? true,
    backgroundColor: config.backgroundColor,
    bottom: config.bottom,
    centerTitle: config.centerTitle,
    clipBehavior: config.clipBehavior,
    collapsedHeight: config.collapsedHeight,
    elevation: config.elevation,
    excludeHeaderSemantics: config.excludeHeaderSemantics ?? false,
    expandedHeight: config.expandedHeight,
    flexibleSpace: config.flexibleSpace,
    floating: config.floating ?? false,
    forceElevated: config.forceElevated ?? false,
    forceMaterialTransparency: config.forceMaterialTransparency ?? false,
    foregroundColor: config.foregroundColor,
    iconTheme: config.iconTheme,
    key: config.key,
    leading: config.leading,
    leadingWidth: config.leadingWidth,
    onStretchTrigger: config.onStretchTrigger,
    pinned: config.pinned ?? false,
    primary: config.primary ?? true,
    scrolledUnderElevation: config.scrolledUnderElevation,
    shadowColor: config.shadowColor,
    shape: config.shape,
    snap: config.snap ?? false,
    stretch: config.stretch ?? false,
    stretchTriggerOffset: config.stretchTriggerOffset ?? 100.0,
    surfaceTintColor: config.surfaceTintColor,
    systemOverlayStyle: config.systemOverlayStyle,
    title: config.title,
    titleSpacing: config.titleSpacing,
    titleTextStyle: config.titleTextStyle,
    toolbarHeight: config.toolbarHeight ?? kToolbarHeight,
    toolbarTextStyle: config.toolbarTextStyle,
    useDefaultSemanticsOrder: config.useDefaultSemanticsOrder ?? true,
  );
}


class GeneratedSliverFillRemainingTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedSliverFillRemainingTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedSliverFillRemainingTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedSliverFillRemainingTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('sliver_fill_remaining').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endsliver_fill_remaining').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'sliver_fill_remaining',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedSliverFillRemainingTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliverFillRemainingTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'fillOverscroll':
          config.fillOverscroll = toBool(value);
          break;
        case 'hasScrollBody':
          config.hasScrollBody = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('sliver_fill_remaining', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSliverFillRemainingTagConfig {
  bool? fillOverscroll;
  bool? hasScrollBody;
  Key? key;
}

SliverFillRemaining _buildGeneratedSliverFillRemainingTagWidget(_GeneratedSliverFillRemainingTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return SliverFillRemaining(
    fillOverscroll: config.fillOverscroll ?? false,
    hasScrollBody: config.hasScrollBody ?? true,
    key: config.key,
    child: child,
  );
}


class GeneratedSliverGridTag extends WidgetTagBase with AsyncTag {
  GeneratedSliverGridTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverGridTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverGridTagWidget(config, children));
  }

  _GeneratedSliverGridTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliverGridTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'delegate':
          config.delegate = parseGeneratedSliverChildDelegate(evaluator, value);
          break;
        case 'gridDelegate':
          config.gridDelegate = parseGeneratedSliverGridDelegate(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('sliver_grid', name);
          break;
      }
    }
    if (config.delegate == null) {
      throw Exception('sliver_grid tag requires "delegate"');
    }
    if (config.gridDelegate == null) {
      throw Exception('sliver_grid tag requires "gridDelegate"');
    }
    return config;
  }
}

class _GeneratedSliverGridTagConfig {
  SliverChildDelegate? delegate;
  SliverGridDelegate? gridDelegate;
  Key? key;
}

SliverGrid _buildGeneratedSliverGridTagWidget(_GeneratedSliverGridTagConfig config, List<Widget> children) {
  return SliverGrid(
    delegate: config.delegate!,
    gridDelegate: config.gridDelegate!,
    key: config.key,
  );
}


class GeneratedSliverListTag extends WidgetTagBase with AsyncTag {
  GeneratedSliverListTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverListTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverListTagWidget(config, children));
  }

  _GeneratedSliverListTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliverListTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'delegate':
          config.delegate = parseGeneratedSliverChildDelegate(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('sliver_list', name);
          break;
      }
    }
    if (config.delegate == null) {
      throw Exception('sliver_list tag requires "delegate"');
    }
    return config;
  }
}

class _GeneratedSliverListTagConfig {
  SliverChildDelegate? delegate;
  Key? key;
}

SliverList _buildGeneratedSliverListTagWidget(_GeneratedSliverListTagConfig config, List<Widget> children) {
  return SliverList(
    delegate: config.delegate!,
    key: config.key,
  );
}


class GeneratedSliverPaddingTag extends WidgetTagBase with AsyncTag {
  GeneratedSliverPaddingTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverPaddingTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverPaddingTagWidget(config, children));
  }

  _GeneratedSliverPaddingTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliverPaddingTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'sliver':
          config.sliver = resolveWidget(value);
          break;
        default:
          handleUnknownArg('sliver_padding', name);
          break;
      }
    }
    if (config.padding == null) {
      throw Exception('sliver_padding tag requires "padding"');
    }
    return config;
  }
}

class _GeneratedSliverPaddingTagConfig {
  Key? key;
  EdgeInsetsGeometry? padding;
  Widget? sliver;
}

SliverPadding _buildGeneratedSliverPaddingTagWidget(_GeneratedSliverPaddingTagConfig config, List<Widget> children) {
  return SliverPadding(
    key: config.key,
    padding: config.padding!,
    sliver: config.sliver,
  );
}


class GeneratedSliverPersistentHeaderTag extends WidgetTagBase with AsyncTag {
  GeneratedSliverPersistentHeaderTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverPersistentHeaderTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSliverPersistentHeaderTagWidget(config, children));
  }

  _GeneratedSliverPersistentHeaderTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliverPersistentHeaderTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'delegate':
          config.delegate = parseGeneratedSliverPersistentHeaderDelegate(value);
          break;
        case 'floating':
          config.floating = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'pinned':
          config.pinned = toBool(value);
          break;
        default:
          handleUnknownArg('sliver_persistent_header', name);
          break;
      }
    }
    if (config.delegate == null) {
      throw Exception('sliver_persistent_header tag requires "delegate"');
    }
    return config;
  }
}

class _GeneratedSliverPersistentHeaderTagConfig {
  SliverPersistentHeaderDelegate? delegate;
  bool? floating;
  Key? key;
  bool? pinned;
}

SliverPersistentHeader _buildGeneratedSliverPersistentHeaderTagWidget(_GeneratedSliverPersistentHeaderTagConfig config, List<Widget> children) {
  return SliverPersistentHeader(
    delegate: config.delegate!,
    floating: config.floating ?? false,
    key: config.key,
    pinned: config.pinned ?? false,
  );
}


class GeneratedSliverToBoxAdapterTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedSliverToBoxAdapterTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedSliverToBoxAdapterTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedSliverToBoxAdapterTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('sliver_to_box_adapter').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endsliver_to_box_adapter').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'sliver_to_box_adapter',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedSliverToBoxAdapterTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSliverToBoxAdapterTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('sliver_to_box_adapter', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSliverToBoxAdapterTagConfig {
  Key? key;
}

SliverToBoxAdapter _buildGeneratedSliverToBoxAdapterTagWidget(_GeneratedSliverToBoxAdapterTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return SliverToBoxAdapter(
    key: config.key,
    child: child,
  );
}


class GeneratedSnackBarTag extends WidgetTagBase with AsyncTag {
  GeneratedSnackBarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSnackBarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSnackBarTagWidget(config, children));
  }

  _GeneratedSnackBarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSnackBarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'action':
          config.action = parseGeneratedSnackBarAction(evaluator, value);
          break;
        case 'actionOverflowThreshold':
          config.actionOverflowThreshold = toDouble(value);
          break;
        case 'animation':
          config.animation = parseGeneratedAnimationOfDouble(value);
          break;
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'behavior':
          config.behavior = parseGeneratedSnackBarBehavior(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'closeIconColor':
          config.closeIconColor = parseGeneratedColor(value);
          break;
        case 'content':
          config.content = resolveWidget(value);
          break;
        case 'dismissDirection':
          config.dismissDirection = parseGeneratedDismissDirection(value);
          break;
        case 'duration':
          config.duration = parseGeneratedDuration(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'hitTestBehavior':
          config.hitTestBehavior = parseGeneratedHitTestBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'onVisible':
          config.onVisible = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'persist':
          config.persist = toBool(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'showCloseIcon':
          config.showCloseIcon = toBool(value);
          break;
        case 'width':
          config.width = toDouble(value);
          break;
        default:
          handleUnknownArg('snack_bar', name);
          break;
      }
    }
    if (config.content == null) {
      throw Exception('snack_bar tag requires "content"');
    }
    return config;
  }
}

class _GeneratedSnackBarTagConfig {
  SnackBarAction? action;
  double? actionOverflowThreshold;
  Animation<double>? animation;
  Color? backgroundColor;
  SnackBarBehavior? behavior;
  Clip? clipBehavior;
  Color? closeIconColor;
  Widget? content;
  DismissDirection? dismissDirection;
  Duration? duration;
  double? elevation;
  HitTestBehavior? hitTestBehavior;
  Key? key;
  EdgeInsetsGeometry? margin;
  VoidCallback? onVisible;
  EdgeInsetsGeometry? padding;
  bool? persist;
  ShapeBorder? shape;
  bool? showCloseIcon;
  double? width;
}

SnackBar _buildGeneratedSnackBarTagWidget(_GeneratedSnackBarTagConfig config, List<Widget> children) {
  return SnackBar(
    action: config.action,
    actionOverflowThreshold: config.actionOverflowThreshold,
    animation: config.animation,
    backgroundColor: config.backgroundColor,
    behavior: config.behavior,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    closeIconColor: config.closeIconColor,
    content: config.content!,
    dismissDirection: config.dismissDirection,
    duration: config.duration ?? Duration.new(milliseconds: 4000),
    elevation: config.elevation,
    hitTestBehavior: config.hitTestBehavior,
    key: config.key,
    margin: config.margin,
    onVisible: config.onVisible,
    padding: config.padding,
    persist: config.persist,
    shape: config.shape,
    showCloseIcon: config.showCloseIcon,
    width: config.width,
  );
}


class GeneratedSnackBarActionTag extends WidgetTagBase with AsyncTag {
  GeneratedSnackBarActionTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSnackBarActionTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSnackBarActionTagWidget(config, children));
  }

  _GeneratedSnackBarActionTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSnackBarActionTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'backgroundColor':
          config.backgroundColor = parseGeneratedColor(value);
          break;
        case 'disabledBackgroundColor':
          config.disabledBackgroundColor = parseGeneratedColor(value);
          break;
        case 'disabledTextColor':
          config.disabledTextColor = parseGeneratedColor(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'label':
          config.label = toStringValue(value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'textColor':
          config.textColor = parseGeneratedColor(value);
          break;
        default:
          handleUnknownArg('snack_bar_action', name);
          break;
      }
    }
    if (config.label == null) {
      throw Exception('snack_bar_action tag requires "label"');
    }
    if (config.onPressed == null) {
      throw Exception('snack_bar_action tag requires "onPressed"');
    }
    return config;
  }
}

class _GeneratedSnackBarActionTagConfig {
  Color? backgroundColor;
  Color? disabledBackgroundColor;
  Color? disabledTextColor;
  Key? key;
  String? label;
  VoidCallback? onPressed;
  Color? textColor;
}

SnackBarAction _buildGeneratedSnackBarActionTagWidget(_GeneratedSnackBarActionTagConfig config, List<Widget> children) {
  return SnackBarAction(
    backgroundColor: config.backgroundColor,
    disabledBackgroundColor: config.disabledBackgroundColor,
    disabledTextColor: config.disabledTextColor,
    key: config.key,
    label: config.label!,
    onPressed: config.onPressed!,
    textColor: config.textColor,
  );
}


class GeneratedSpacerTag extends WidgetTagBase with AsyncTag {
  GeneratedSpacerTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSpacerTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSpacerTagWidget(config, children));
  }

  _GeneratedSpacerTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSpacerTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'flex':
          config.flex = toInt(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        default:
          handleUnknownArg('spacer', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedSpacerTagConfig {
  int? flex;
  Key? key;
}

Spacer _buildGeneratedSpacerTagWidget(_GeneratedSpacerTagConfig config, List<Widget> children) {
  return Spacer(
    flex: config.flex ?? 1,
    key: config.key,
  );
}


class GeneratedStackTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedStackTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedStackTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedStackTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('stack').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endstack').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'stack',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedStackTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedStackTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'fit':
          config.fit = parseGeneratedStackFit(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        default:
          handleUnknownArg('stack', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedStackTagConfig {
  AlignmentGeometry? alignment;
  Clip? clipBehavior;
  StackFit? fit;
  Key? key;
  TextDirection? textDirection;
}

Stack _buildGeneratedStackTagWidget(_GeneratedStackTagConfig config, List<Widget> children) {
  return Stack(
    alignment: config.alignment ?? AlignmentDirectional.topStart,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    fit: config.fit ?? StackFit.loose,
    key: config.key,
    textDirection: config.textDirection,
    children: children,
  );
}


class GeneratedStepperTag extends WidgetTagBase with AsyncTag {
  GeneratedStepperTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedStepperTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedStepperTagWidget(config, children));
  }

  _GeneratedStepperTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedStepperTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'connectorColor':
          config.connectorColor = (value is WidgetStateProperty<Color> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color>?);
          break;
        case 'connectorThickness':
          config.connectorThickness = toDouble(value);
          break;
        case 'controller':
          config.controller = parseGeneratedScrollController(evaluator, value);
          break;
        case 'controlsBuilder':
          config.controlsBuilder = (value is ControlsWidgetBuilder ? value : resolveWidgetBuilder2Callback(evaluator, value) as ControlsWidgetBuilder?);
          break;
        case 'currentStep':
          config.currentStep = toInt(value);
          break;
        case 'elevation':
          config.elevation = toDouble(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'onStepCancel':
          config.onStepCancel = resolveActionCallback(evaluator, value);
          break;
        case 'onStepContinue':
          config.onStepContinue = resolveActionCallback(evaluator, value);
          break;
        case 'onStepTapped':
          config.onStepTapped = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'stepIconBuilder':
          config.stepIconBuilder = (value is StepIconBuilder ? value : resolveGenericCallback2(evaluator, value) as StepIconBuilder?);
          break;
        case 'stepIconHeight':
          config.stepIconHeight = toDouble(value);
          break;
        case 'stepIconMargin':
          config.stepIconMargin = parseGeneratedEdgeInsets(value);
          break;
        case 'stepIconWidth':
          config.stepIconWidth = toDouble(value);
          break;
        case 'steps':
          config.steps = parseGeneratedListOfStep(value);
          break;
        case 'type':
          config.type = parseGeneratedStepperType(value);
          break;
        default:
          handleUnknownArg('stepper', name);
          break;
      }
    }
    if (config.steps == null) {
      throw Exception('stepper tag requires "steps"');
    }
    return config;
  }
}

class _GeneratedStepperTagConfig {
  Clip? clipBehavior;
  WidgetStateProperty<Color>? connectorColor;
  double? connectorThickness;
  ScrollController? controller;
  ControlsWidgetBuilder? controlsBuilder;
  int? currentStep;
  double? elevation;
  Key? key;
  EdgeInsetsGeometry? margin;
  VoidCallback? onStepCancel;
  VoidCallback? onStepContinue;
  ValueChanged<int>? onStepTapped;
  ScrollPhysics? physics;
  StepIconBuilder? stepIconBuilder;
  double? stepIconHeight;
  EdgeInsets? stepIconMargin;
  double? stepIconWidth;
  List<Step>? steps;
  StepperType? type;
}

Stepper _buildGeneratedStepperTagWidget(_GeneratedStepperTagConfig config, List<Widget> children) {
  return Stepper(
    clipBehavior: config.clipBehavior ?? Clip.none,
    connectorColor: config.connectorColor,
    connectorThickness: config.connectorThickness,
    controller: config.controller,
    controlsBuilder: config.controlsBuilder,
    currentStep: config.currentStep ?? 0,
    elevation: config.elevation,
    key: config.key,
    margin: config.margin,
    onStepCancel: config.onStepCancel,
    onStepContinue: config.onStepContinue,
    onStepTapped: config.onStepTapped,
    physics: config.physics,
    stepIconBuilder: config.stepIconBuilder,
    stepIconHeight: config.stepIconHeight,
    stepIconMargin: config.stepIconMargin,
    stepIconWidth: config.stepIconWidth,
    steps: config.steps!,
    type: config.type ?? StepperType.vertical,
  );
}


class GeneratedSwitchTag extends WidgetTagBase with AsyncTag {
  GeneratedSwitchTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSwitchTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSwitchTagWidget(config, children));
  }

  _GeneratedSwitchTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSwitchTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'activeColor':
          config.activeColor = parseGeneratedColor(value);
          break;
        case 'activeThumbColor':
          config.activeThumbColor = parseGeneratedColor(value);
          break;
        case 'activeThumbImage':
          config.activeThumbImage = (value is ImageProvider<Object> ? value : parseGeneratedImageProvider(value) as ImageProvider<Object>?);
          break;
        case 'activeTrackColor':
          config.activeTrackColor = parseGeneratedColor(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'focusColor':
          config.focusColor = parseGeneratedColor(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'inactiveThumbColor':
          config.inactiveThumbColor = parseGeneratedColor(value);
          break;
        case 'inactiveThumbImage':
          config.inactiveThumbImage = (value is ImageProvider<Object> ? value : parseGeneratedImageProvider(value) as ImageProvider<Object>?);
          break;
        case 'inactiveTrackColor':
          config.inactiveTrackColor = parseGeneratedColor(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onActiveThumbImageError':
          config.onActiveThumbImageError = (value is ImageErrorListener ? value : resolveGenericActionCallback2(evaluator, value) as ImageErrorListener?);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onInactiveThumbImageError':
          config.onInactiveThumbImageError = (value is ImageErrorListener ? value : resolveGenericActionCallback2(evaluator, value) as ImageErrorListener?);
          break;
        case 'overlayColor':
          config.overlayColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'splashRadius':
          config.splashRadius = toDouble(value);
          break;
        case 'thumbColor':
          config.thumbColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'thumbIcon':
          config.thumbIcon = (value is WidgetStateProperty<Icon?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Icon?>?);
          break;
        case 'trackColor':
          config.trackColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'trackOutlineColor':
          config.trackOutlineColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'trackOutlineWidth':
          config.trackOutlineWidth = (value is WidgetStateProperty<double?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<double?>?);
          break;
        case 'value':
          config.value = toBool(value);
          break;
        default:
          handleUnknownArg('switch', name);
          break;
      }
    }
    if (config.onChanged == null) {
      throw Exception('switch tag requires "onChanged"');
    }
    if (config.value == null) {
      throw Exception('switch tag requires "value"');
    }
    return config;
  }
}

class _GeneratedSwitchTagConfig {
  Color? activeColor;
  Color? activeThumbColor;
  ImageProvider<Object>? activeThumbImage;
  Color? activeTrackColor;
  bool? autofocus;
  DragStartBehavior? dragStartBehavior;
  Color? focusColor;
  FocusNode? focusNode;
  Color? hoverColor;
  Color? inactiveThumbColor;
  ImageProvider<Object>? inactiveThumbImage;
  Color? inactiveTrackColor;
  Key? key;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  ImageErrorListener? onActiveThumbImageError;
  ValueChanged<bool>? onChanged;
  ValueChanged<bool>? onFocusChange;
  ImageErrorListener? onInactiveThumbImageError;
  WidgetStateProperty<Color?>? overlayColor;
  EdgeInsetsGeometry? padding;
  double? splashRadius;
  WidgetStateProperty<Color?>? thumbColor;
  WidgetStateProperty<Icon?>? thumbIcon;
  WidgetStateProperty<Color?>? trackColor;
  WidgetStateProperty<Color?>? trackOutlineColor;
  WidgetStateProperty<double?>? trackOutlineWidth;
  bool? value;
}

Switch _buildGeneratedSwitchTagWidget(_GeneratedSwitchTagConfig config, List<Widget> children) {
  return Switch(
    activeColor: config.activeColor,
    activeThumbColor: config.activeThumbColor,
    activeThumbImage: config.activeThumbImage,
    activeTrackColor: config.activeTrackColor,
    autofocus: config.autofocus ?? false,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    focusColor: config.focusColor,
    focusNode: config.focusNode,
    hoverColor: config.hoverColor,
    inactiveThumbColor: config.inactiveThumbColor,
    inactiveThumbImage: config.inactiveThumbImage,
    inactiveTrackColor: config.inactiveTrackColor,
    key: config.key,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onActiveThumbImageError: config.onActiveThumbImageError,
    onChanged: config.onChanged,
    onFocusChange: config.onFocusChange,
    onInactiveThumbImageError: config.onInactiveThumbImageError,
    overlayColor: config.overlayColor,
    padding: config.padding,
    splashRadius: config.splashRadius,
    thumbColor: config.thumbColor,
    thumbIcon: config.thumbIcon,
    trackColor: config.trackColor,
    trackOutlineColor: config.trackOutlineColor,
    trackOutlineWidth: config.trackOutlineWidth,
    value: config.value!,
  );
}


class GeneratedSwitchListTileTag extends WidgetTagBase with AsyncTag {
  GeneratedSwitchListTileTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSwitchListTileTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedSwitchListTileTagWidget(config, children));
  }

  _GeneratedSwitchListTileTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedSwitchListTileTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'activeColor':
          config.activeColor = parseGeneratedColor(value);
          break;
        case 'activeThumbColor':
          config.activeThumbColor = parseGeneratedColor(value);
          break;
        case 'activeThumbImage':
          config.activeThumbImage = (value is ImageProvider<Object> ? value : parseGeneratedImageProvider(value) as ImageProvider<Object>?);
          break;
        case 'activeTrackColor':
          config.activeTrackColor = parseGeneratedColor(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'contentPadding':
          config.contentPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'controlAffinity':
          config.controlAffinity = parseGeneratedListTileControlAffinity(value);
          break;
        case 'dense':
          config.dense = toBool(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'inactiveThumbColor':
          config.inactiveThumbColor = parseGeneratedColor(value);
          break;
        case 'inactiveThumbImage':
          config.inactiveThumbImage = (value is ImageProvider<Object> ? value : parseGeneratedImageProvider(value) as ImageProvider<Object>?);
          break;
        case 'inactiveTrackColor':
          config.inactiveTrackColor = parseGeneratedColor(value);
          break;
        case 'internalAddSemanticForOnTap':
          config.internalAddSemanticForOnTap = toBool(value);
          break;
        case 'isThreeLine':
          config.isThreeLine = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'materialTapTargetSize':
          config.materialTapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onActiveThumbImageError':
          config.onActiveThumbImageError = (value is ImageErrorListener ? value : resolveGenericActionCallback2(evaluator, value) as ImageErrorListener?);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onInactiveThumbImageError':
          config.onInactiveThumbImageError = (value is ImageErrorListener ? value : resolveGenericActionCallback2(evaluator, value) as ImageErrorListener?);
          break;
        case 'overlayColor':
          config.overlayColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'secondary':
          config.secondary = resolveWidget(value);
          break;
        case 'selected':
          config.selected = toBool(value);
          break;
        case 'selectedTileColor':
          config.selectedTileColor = parseGeneratedColor(value);
          break;
        case 'shape':
          config.shape = parseGeneratedShapeBorder(value);
          break;
        case 'splashRadius':
          config.splashRadius = toDouble(value);
          break;
        case 'subtitle':
          config.subtitle = resolveWidget(value);
          break;
        case 'thumbColor':
          config.thumbColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'thumbIcon':
          config.thumbIcon = (value is WidgetStateProperty<Icon?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Icon?>?);
          break;
        case 'tileColor':
          config.tileColor = parseGeneratedColor(value);
          break;
        case 'title':
          config.title = resolveWidget(value);
          break;
        case 'trackColor':
          config.trackColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'trackOutlineColor':
          config.trackOutlineColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'value':
          config.value = toBool(value);
          break;
        case 'visualDensity':
          config.visualDensity = parseGeneratedVisualDensity(value);
          break;
        default:
          handleUnknownArg('switch_list_tile', name);
          break;
      }
    }
    if (config.onChanged == null) {
      throw Exception('switch_list_tile tag requires "onChanged"');
    }
    if (config.value == null) {
      throw Exception('switch_list_tile tag requires "value"');
    }
    return config;
  }
}

class _GeneratedSwitchListTileTagConfig {
  Color? activeColor;
  Color? activeThumbColor;
  ImageProvider<Object>? activeThumbImage;
  Color? activeTrackColor;
  bool? autofocus;
  EdgeInsetsGeometry? contentPadding;
  ListTileControlAffinity? controlAffinity;
  bool? dense;
  DragStartBehavior? dragStartBehavior;
  bool? enableFeedback;
  FocusNode? focusNode;
  Color? hoverColor;
  Color? inactiveThumbColor;
  ImageProvider<Object>? inactiveThumbImage;
  Color? inactiveTrackColor;
  bool? internalAddSemanticForOnTap;
  bool? isThreeLine;
  Key? key;
  MaterialTapTargetSize? materialTapTargetSize;
  MouseCursor? mouseCursor;
  ImageErrorListener? onActiveThumbImageError;
  ValueChanged<bool>? onChanged;
  ValueChanged<bool>? onFocusChange;
  ImageErrorListener? onInactiveThumbImageError;
  WidgetStateProperty<Color?>? overlayColor;
  Widget? secondary;
  bool? selected;
  Color? selectedTileColor;
  ShapeBorder? shape;
  double? splashRadius;
  Widget? subtitle;
  WidgetStateProperty<Color?>? thumbColor;
  WidgetStateProperty<Icon?>? thumbIcon;
  Color? tileColor;
  Widget? title;
  WidgetStateProperty<Color?>? trackColor;
  WidgetStateProperty<Color?>? trackOutlineColor;
  bool? value;
  VisualDensity? visualDensity;
}

SwitchListTile _buildGeneratedSwitchListTileTagWidget(_GeneratedSwitchListTileTagConfig config, List<Widget> children) {
  return SwitchListTile(
    activeColor: config.activeColor,
    activeThumbColor: config.activeThumbColor,
    activeThumbImage: config.activeThumbImage,
    activeTrackColor: config.activeTrackColor,
    autofocus: config.autofocus ?? false,
    contentPadding: config.contentPadding,
    controlAffinity: config.controlAffinity,
    dense: config.dense,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    enableFeedback: config.enableFeedback,
    focusNode: config.focusNode,
    hoverColor: config.hoverColor,
    inactiveThumbColor: config.inactiveThumbColor,
    inactiveThumbImage: config.inactiveThumbImage,
    inactiveTrackColor: config.inactiveTrackColor,
    internalAddSemanticForOnTap: config.internalAddSemanticForOnTap ?? false,
    isThreeLine: config.isThreeLine,
    key: config.key,
    materialTapTargetSize: config.materialTapTargetSize,
    mouseCursor: config.mouseCursor,
    onActiveThumbImageError: config.onActiveThumbImageError,
    onChanged: config.onChanged,
    onFocusChange: config.onFocusChange,
    onInactiveThumbImageError: config.onInactiveThumbImageError,
    overlayColor: config.overlayColor,
    secondary: config.secondary,
    selected: config.selected ?? false,
    selectedTileColor: config.selectedTileColor,
    shape: config.shape,
    splashRadius: config.splashRadius,
    subtitle: config.subtitle,
    thumbColor: config.thumbColor,
    thumbIcon: config.thumbIcon,
    tileColor: config.tileColor,
    title: config.title,
    trackColor: config.trackColor,
    trackOutlineColor: config.trackOutlineColor,
    value: config.value!,
    visualDensity: config.visualDensity,
  );
}


class GeneratedTabTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedTabTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedTabTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedTabTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('tab').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endtab').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'tab',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedTabTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTabTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'height':
          config.height = toDouble(value);
          break;
        case 'icon':
          config.icon = resolveWidget(value);
          break;
        case 'iconMargin':
          config.iconMargin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'text':
          config.text = toStringValue(value);
          break;
        default:
          handleUnknownArg('tab', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedTabTagConfig {
  double? height;
  Widget? icon;
  EdgeInsetsGeometry? iconMargin;
  Key? key;
  String? text;
}

Tab _buildGeneratedTabTagWidget(_GeneratedTabTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Tab(
    height: config.height,
    icon: config.icon,
    iconMargin: config.iconMargin,
    key: config.key,
    text: config.text,
    child: child,
  );
}


class GeneratedTabBarTag extends WidgetTagBase with AsyncTag {
  GeneratedTabBarTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTabBarTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTabBarTagWidget(config, children));
  }

  _GeneratedTabBarTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTabBarTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'automaticIndicatorColorAdjustment':
          config.automaticIndicatorColorAdjustment = toBool(value);
          break;
        case 'controller':
          config.controller = parseGeneratedTabController(value);
          break;
        case 'dividerColor':
          config.dividerColor = parseGeneratedColor(value);
          break;
        case 'dividerHeight':
          config.dividerHeight = toDouble(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'indicator':
          config.indicator = parseGeneratedDecoration(evaluator, value);
          break;
        case 'indicatorAnimation':
          config.indicatorAnimation = parseGeneratedTabIndicatorAnimation(value);
          break;
        case 'indicatorColor':
          config.indicatorColor = parseGeneratedColor(value);
          break;
        case 'indicatorPadding':
          config.indicatorPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'indicatorSize':
          config.indicatorSize = parseGeneratedTabBarIndicatorSize(value);
          break;
        case 'indicatorWeight':
          config.indicatorWeight = toDouble(value);
          break;
        case 'isScrollable':
          config.isScrollable = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'labelColor':
          config.labelColor = parseGeneratedColor(value);
          break;
        case 'labelPadding':
          config.labelPadding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'labelStyle':
          config.labelStyle = parseGeneratedTextStyle(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is TabValueChanged<bool> ? value : resolveGenericActionCallback2(evaluator, value) as TabValueChanged<bool>?);
          break;
        case 'onHover':
          config.onHover = (value is TabValueChanged<bool> ? value : resolveGenericActionCallback2(evaluator, value) as TabValueChanged<bool>?);
          break;
        case 'onTap':
          config.onTap = (value is ValueChanged<int> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<int>?);
          break;
        case 'overlayColor':
          config.overlayColor = (value is WidgetStateProperty<Color?> ? value : parseGeneratedWidgetStateProperty(value) as WidgetStateProperty<Color?>?);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'splashBorderRadius':
          config.splashBorderRadius = parseGeneratedBorderRadius(value);
          break;
        case 'splashFactory':
          config.splashFactory = parseGeneratedInteractiveInkFeatureFactory(value);
          break;
        case 'tabAlignment':
          config.tabAlignment = parseGeneratedTabAlignment(value);
          break;
        case 'tabs':
          config.tabs = value;
          break;
        case 'textScaler':
          config.textScaler = parseGeneratedTextScaler(value);
          break;
        case 'unselectedLabelColor':
          config.unselectedLabelColor = parseGeneratedColor(value);
          break;
        case 'unselectedLabelStyle':
          config.unselectedLabelStyle = parseGeneratedTextStyle(value);
          break;
        default:
          handleUnknownArg('tab_bar', name);
          break;
      }
    }
    if (config.tabs == null) {
      throw Exception('tab_bar tag requires "tabs"');
    }
    return config;
  }
}

class _GeneratedTabBarTagConfig {
  bool? automaticIndicatorColorAdjustment;
  TabController? controller;
  Color? dividerColor;
  double? dividerHeight;
  DragStartBehavior? dragStartBehavior;
  bool? enableFeedback;
  Decoration? indicator;
  TabIndicatorAnimation? indicatorAnimation;
  Color? indicatorColor;
  EdgeInsetsGeometry? indicatorPadding;
  TabBarIndicatorSize? indicatorSize;
  double? indicatorWeight;
  bool? isScrollable;
  Key? key;
  Color? labelColor;
  EdgeInsetsGeometry? labelPadding;
  TextStyle? labelStyle;
  MouseCursor? mouseCursor;
  TabValueChanged<bool>? onFocusChange;
  TabValueChanged<bool>? onHover;
  ValueChanged<int>? onTap;
  WidgetStateProperty<Color?>? overlayColor;
  EdgeInsetsGeometry? padding;
  ScrollPhysics? physics;
  BorderRadius? splashBorderRadius;
  InteractiveInkFeatureFactory? splashFactory;
  TabAlignment? tabAlignment;
  List<Widget>? tabs;
  TextScaler? textScaler;
  Color? unselectedLabelColor;
  TextStyle? unselectedLabelStyle;
}

TabBar _buildGeneratedTabBarTagWidget(_GeneratedTabBarTagConfig config, List<Widget> children) {
  return TabBar(
    automaticIndicatorColorAdjustment: config.automaticIndicatorColorAdjustment ?? true,
    controller: config.controller,
    dividerColor: config.dividerColor,
    dividerHeight: config.dividerHeight,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    enableFeedback: config.enableFeedback,
    indicator: config.indicator,
    indicatorAnimation: config.indicatorAnimation,
    indicatorColor: config.indicatorColor,
    indicatorPadding: config.indicatorPadding ?? EdgeInsets.zero,
    indicatorSize: config.indicatorSize,
    indicatorWeight: config.indicatorWeight ?? 2.0,
    isScrollable: config.isScrollable ?? false,
    key: config.key,
    labelColor: config.labelColor,
    labelPadding: config.labelPadding,
    labelStyle: config.labelStyle,
    mouseCursor: config.mouseCursor,
    onFocusChange: config.onFocusChange,
    onHover: config.onHover,
    onTap: config.onTap,
    overlayColor: config.overlayColor,
    padding: config.padding,
    physics: config.physics,
    splashBorderRadius: config.splashBorderRadius,
    splashFactory: config.splashFactory,
    tabAlignment: config.tabAlignment,
    tabs: config.tabs!,
    textScaler: config.textScaler,
    unselectedLabelColor: config.unselectedLabelColor,
    unselectedLabelStyle: config.unselectedLabelStyle,
  );
}


class GeneratedTabBarViewTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedTabBarViewTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedTabBarViewTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedTabBarViewTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('tab_bar_view').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endtab_bar_view').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'tab_bar_view',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedTabBarViewTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTabBarViewTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'controller':
          config.controller = parseGeneratedTabController(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'physics':
          config.physics = parseGeneratedScrollPhysics(value);
          break;
        case 'viewportFraction':
          config.viewportFraction = toDouble(value);
          break;
        default:
          handleUnknownArg('tab_bar_view', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedTabBarViewTagConfig {
  Clip? clipBehavior;
  TabController? controller;
  DragStartBehavior? dragStartBehavior;
  Key? key;
  ScrollPhysics? physics;
  double? viewportFraction;
}

TabBarView _buildGeneratedTabBarViewTagWidget(_GeneratedTabBarViewTagConfig config, List<Widget> children) {
  return TabBarView(
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    controller: config.controller,
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    key: config.key,
    physics: config.physics,
    viewportFraction: config.viewportFraction ?? 1.0,
    children: children,
  );
}


class GeneratedTableTag extends WidgetTagBase with AsyncTag {
  GeneratedTableTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTableTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTableTagWidget(config, children));
  }

  _GeneratedTableTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTableTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'border':
          config.border = parseGeneratedTableBorder(value);
          break;
        case 'children':
          config.children = parseGeneratedListOfTableRow(evaluator, value);
          break;
        case 'columnWidths':
          config.columnWidths = parseTableColumnWidths(value);
          break;
        case 'defaultColumnWidth':
          config.defaultColumnWidth = parseGeneratedTableColumnWidth(value);
          break;
        case 'defaultVerticalAlignment':
          config.defaultVerticalAlignment = parseGeneratedTableCellVerticalAlignment(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'textBaseline':
          config.textBaseline = parseGeneratedTextBaseline(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        default:
          handleUnknownArg('table', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedTableTagConfig {
  TableBorder? border;
  List<TableRow>? children;
  Map<int, TableColumnWidth>? columnWidths;
  TableColumnWidth? defaultColumnWidth;
  TableCellVerticalAlignment? defaultVerticalAlignment;
  Key? key;
  TextBaseline? textBaseline;
  TextDirection? textDirection;
}

Table _buildGeneratedTableTagWidget(_GeneratedTableTagConfig config, List<Widget> children) {
  return Table(
    border: config.border,
    children: config.children ?? const <TableRow>[],
    columnWidths: config.columnWidths,
    defaultColumnWidth: config.defaultColumnWidth ?? const FlexColumnWidth(),
    defaultVerticalAlignment: config.defaultVerticalAlignment ?? TableCellVerticalAlignment.top,
    key: config.key,
    textBaseline: config.textBaseline,
    textDirection: config.textDirection,
  );
}


class GeneratedTextTag extends WidgetTagBase with AsyncTag {
  GeneratedTextTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTextTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTextTagWidget(config, children));
  }

  _GeneratedTextTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTextTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'data':
          config.data = toStringValue(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'locale':
          config.locale = parseGeneratedLocale(value);
          break;
        case 'maxLines':
          config.maxLines = toInt(value);
          break;
        case 'overflow':
          config.overflow = parseGeneratedTextOverflow(value);
          break;
        case 'selectionColor':
          config.selectionColor = parseGeneratedColor(value);
          break;
        case 'semanticsIdentifier':
          config.semanticsIdentifier = toStringValue(value);
          break;
        case 'semanticsLabel':
          config.semanticsLabel = toStringValue(value);
          break;
        case 'softWrap':
          config.softWrap = toBool(value);
          break;
        case 'strutStyle':
          config.strutStyle = parseGeneratedStrutStyle(value);
          break;
        case 'style':
          config.style = parseGeneratedTextStyle(value);
          break;
        case 'textAlign':
          config.textAlign = parseGeneratedTextAlign(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'textHeightBehavior':
          config.textHeightBehavior = parseGeneratedTextHeightBehavior(value);
          break;
        case 'textScaleFactor':
          config.textScaleFactor = toDouble(value);
          break;
        case 'textScaler':
          config.textScaler = parseGeneratedTextScaler(value);
          break;
        case 'textWidthBasis':
          config.textWidthBasis = parseGeneratedTextWidthBasis(value);
          break;
        default:
          handleUnknownArg('text', name);
          break;
      }
    }
    if (config.data == null) {
      throw Exception('text tag requires "data"');
    }
    return config;
  }
}

class _GeneratedTextTagConfig {
  String? data;
  Key? key;
  Locale? locale;
  int? maxLines;
  TextOverflow? overflow;
  Color? selectionColor;
  String? semanticsIdentifier;
  String? semanticsLabel;
  bool? softWrap;
  StrutStyle? strutStyle;
  TextStyle? style;
  TextAlign? textAlign;
  TextDirection? textDirection;
  TextHeightBehavior? textHeightBehavior;
  double? textScaleFactor;
  TextScaler? textScaler;
  TextWidthBasis? textWidthBasis;
}

Text _buildGeneratedTextTagWidget(_GeneratedTextTagConfig config, List<Widget> children) {
  return Text(
    config.data!,
    key: config.key,
    locale: config.locale,
    maxLines: config.maxLines,
    overflow: config.overflow,
    selectionColor: config.selectionColor,
    semanticsIdentifier: config.semanticsIdentifier,
    semanticsLabel: config.semanticsLabel,
    softWrap: config.softWrap,
    strutStyle: config.strutStyle,
    style: config.style,
    textAlign: config.textAlign,
    textDirection: config.textDirection,
    textHeightBehavior: config.textHeightBehavior,
    textScaleFactor: config.textScaleFactor,
    textScaler: config.textScaler,
    textWidthBasis: config.textWidthBasis,
  );
}


class GeneratedTextButtonTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedTextButtonTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedTextButtonTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedTextButtonTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('text_button').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endtext_button').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'text_button',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedTextButtonTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTextButtonTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'isSemanticButton':
          config.isSemanticButton = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'onFocusChange':
          config.onFocusChange = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onHover':
          config.onHover = (value is ValueChanged<bool> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<bool>?);
          break;
        case 'onLongPress':
          config.onLongPress = resolveActionCallback(evaluator, value);
          break;
        case 'onPressed':
          config.onPressed = resolveActionCallback(evaluator, value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'style':
          config.style = parseGeneratedButtonStyle(evaluator, value);
          break;
        default:
          handleUnknownArg('text_button', name);
          break;
      }
    }
    if (config.onPressed == null) {
      throw Exception('text_button tag requires "onPressed"');
    }
    return config;
  }
}

class _GeneratedTextButtonTagConfig {
  bool? autofocus;
  Clip? clipBehavior;
  FocusNode? focusNode;
  bool? isSemanticButton;
  Key? key;
  ValueChanged<bool>? onFocusChange;
  ValueChanged<bool>? onHover;
  VoidCallback? onLongPress;
  VoidCallback? onPressed;
  MaterialStatesController? statesController;
  ButtonStyle? style;
}

TextButton _buildGeneratedTextButtonTagWidget(_GeneratedTextButtonTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return TextButton(
    autofocus: config.autofocus ?? false,
    clipBehavior: config.clipBehavior,
    focusNode: config.focusNode,
    isSemanticButton: config.isSemanticButton ?? true,
    key: config.key,
    onFocusChange: config.onFocusChange,
    onHover: config.onHover,
    onLongPress: config.onLongPress,
    onPressed: config.onPressed,
    statesController: config.statesController,
    style: config.style,
    child: child,
  );
}


class GeneratedTextFieldTag extends WidgetTagBase with AsyncTag {
  GeneratedTextFieldTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTextFieldTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTextFieldTagWidget(config, children));
  }

  _GeneratedTextFieldTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTextFieldTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autocorrect':
          config.autocorrect = toBool(value);
          break;
        case 'autofillHints':
          config.autofillHints = parseGeneratedIterableOfString(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'buildCounter':
          config.buildCounter = (value is InputCounterWidgetBuilder ? value : resolveCallbackValue(evaluator, value) as InputCounterWidgetBuilder?);
          break;
        case 'canRequestFocus':
          config.canRequestFocus = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'contentInsertionConfiguration':
          config.contentInsertionConfiguration = parseGeneratedContentInsertionConfiguration(evaluator, value);
          break;
        case 'contextMenuBuilder':
          config.contextMenuBuilder = (value is EditableTextContextMenuBuilder ? value : resolveWidgetBuilder2Callback(evaluator, value) as EditableTextContextMenuBuilder?);
          break;
        case 'controller':
          config.controller = parseGeneratedTextEditingController(value);
          break;
        case 'cursorColor':
          config.cursorColor = parseGeneratedColor(value);
          break;
        case 'cursorErrorColor':
          config.cursorErrorColor = parseGeneratedColor(value);
          break;
        case 'cursorHeight':
          config.cursorHeight = toDouble(value);
          break;
        case 'cursorOpacityAnimates':
          config.cursorOpacityAnimates = toBool(value);
          break;
        case 'cursorRadius':
          config.cursorRadius = parseGeneratedRadius(value);
          break;
        case 'cursorWidth':
          config.cursorWidth = toDouble(value);
          break;
        case 'decoration':
          config.decoration = parseGeneratedInputDecoration(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'enableIMEPersonalizedLearning':
          config.enableIMEPersonalizedLearning = toBool(value);
          break;
        case 'enableInteractiveSelection':
          config.enableInteractiveSelection = toBool(value);
          break;
        case 'enableSuggestions':
          config.enableSuggestions = toBool(value);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'expands':
          config.expands = toBool(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'groupId':
          config.groupId = parseGeneratedObject(evaluator, value);
          break;
        case 'hintLocales':
          config.hintLocales = parseGeneratedListOfLocale(value);
          break;
        case 'ignorePointers':
          config.ignorePointers = toBool(value);
          break;
        case 'inputFormatters':
          config.inputFormatters = parseGeneratedListOfTextInputFormatter(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardAppearance':
          config.keyboardAppearance = parseGeneratedBrightness(value);
          break;
        case 'keyboardType':
          config.keyboardType = parseGeneratedTextInputType(value);
          break;
        case 'magnifierConfiguration':
          config.magnifierConfiguration = parseGeneratedTextMagnifierConfiguration(evaluator, value);
          break;
        case 'maxLength':
          config.maxLength = toInt(value);
          break;
        case 'maxLengthEnforcement':
          config.maxLengthEnforcement = parseGeneratedMaxLengthEnforcement(value);
          break;
        case 'maxLines':
          config.maxLines = toInt(value);
          break;
        case 'minLines':
          config.minLines = toInt(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'obscureText':
          config.obscureText = toBool(value);
          break;
        case 'obscuringCharacter':
          config.obscuringCharacter = toStringValue(value);
          break;
        case 'onAppPrivateCommand':
          config.onAppPrivateCommand = (value is AppPrivateCommandCallback ? value : resolveGenericActionCallback2(evaluator, value) as AppPrivateCommandCallback?);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<String> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<String>?);
          break;
        case 'onEditingComplete':
          config.onEditingComplete = resolveActionCallback(evaluator, value);
          break;
        case 'onSubmitted':
          config.onSubmitted = (value is ValueChanged<String> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<String>?);
          break;
        case 'onTap':
          config.onTap = resolveActionCallback(evaluator, value);
          break;
        case 'onTapAlwaysCalled':
          config.onTapAlwaysCalled = toBool(value);
          break;
        case 'onTapOutside':
          config.onTapOutside = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTapUpOutside':
          config.onTapUpOutside = resolveGenericValueChanged(evaluator, value);
          break;
        case 'readOnly':
          config.readOnly = toBool(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'scribbleEnabled':
          config.scribbleEnabled = toBool(value);
          break;
        case 'scrollController':
          config.scrollController = parseGeneratedScrollController(evaluator, value);
          break;
        case 'scrollPadding':
          config.scrollPadding = parseGeneratedEdgeInsets(value);
          break;
        case 'scrollPhysics':
          config.scrollPhysics = parseGeneratedScrollPhysics(value);
          break;
        case 'selectAllOnFocus':
          config.selectAllOnFocus = toBool(value);
          break;
        case 'selectionControls':
          config.selectionControls = parseGeneratedTextSelectionControls(value);
          break;
        case 'selectionHeightStyle':
          config.selectionHeightStyle = parseGeneratedBoxHeightStyle(value);
          break;
        case 'selectionWidthStyle':
          config.selectionWidthStyle = parseGeneratedBoxWidthStyle(value);
          break;
        case 'showCursor':
          config.showCursor = toBool(value);
          break;
        case 'smartDashesType':
          config.smartDashesType = parseGeneratedSmartDashesType(value);
          break;
        case 'smartQuotesType':
          config.smartQuotesType = parseGeneratedSmartQuotesType(value);
          break;
        case 'spellCheckConfiguration':
          config.spellCheckConfiguration = parseGeneratedSpellCheckConfiguration(evaluator, value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'strutStyle':
          config.strutStyle = parseGeneratedStrutStyle(value);
          break;
        case 'style':
          config.style = parseGeneratedTextStyle(value);
          break;
        case 'stylusHandwritingEnabled':
          config.stylusHandwritingEnabled = toBool(value);
          break;
        case 'textAlign':
          config.textAlign = parseGeneratedTextAlign(value);
          break;
        case 'textAlignVertical':
          config.textAlignVertical = parseGeneratedTextAlignVertical(value);
          break;
        case 'textCapitalization':
          config.textCapitalization = parseGeneratedTextCapitalization(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'textInputAction':
          config.textInputAction = parseGeneratedTextInputAction(value);
          break;
        case 'toolbarOptions':
          config.toolbarOptions = parseGeneratedToolbarOptions(value);
          break;
        case 'undoController':
          config.undoController = parseGeneratedUndoHistoryController(value);
          break;
        default:
          handleUnknownArg('text_field', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedTextFieldTagConfig {
  bool? autocorrect;
  Iterable<String>? autofillHints;
  bool? autofocus;
  InputCounterWidgetBuilder? buildCounter;
  bool? canRequestFocus;
  Clip? clipBehavior;
  ContentInsertionConfiguration? contentInsertionConfiguration;
  EditableTextContextMenuBuilder? contextMenuBuilder;
  TextEditingController? controller;
  Color? cursorColor;
  Color? cursorErrorColor;
  double? cursorHeight;
  bool? cursorOpacityAnimates;
  Radius? cursorRadius;
  double? cursorWidth;
  InputDecoration? decoration;
  DragStartBehavior? dragStartBehavior;
  bool? enableIMEPersonalizedLearning;
  bool? enableInteractiveSelection;
  bool? enableSuggestions;
  bool? enabled;
  bool? expands;
  FocusNode? focusNode;
  Object? groupId;
  List<Locale>? hintLocales;
  bool? ignorePointers;
  List<TextInputFormatter>? inputFormatters;
  Key? key;
  Brightness? keyboardAppearance;
  TextInputType? keyboardType;
  TextMagnifierConfiguration? magnifierConfiguration;
  int? maxLength;
  MaxLengthEnforcement? maxLengthEnforcement;
  int? maxLines;
  int? minLines;
  MouseCursor? mouseCursor;
  bool? obscureText;
  String? obscuringCharacter;
  AppPrivateCommandCallback? onAppPrivateCommand;
  ValueChanged<String>? onChanged;
  VoidCallback? onEditingComplete;
  ValueChanged<String>? onSubmitted;
  GestureTapCallback? onTap;
  bool? onTapAlwaysCalled;
  TapRegionCallback? onTapOutside;
  TapRegionUpCallback? onTapUpOutside;
  bool? readOnly;
  String? restorationId;
  bool? scribbleEnabled;
  ScrollController? scrollController;
  EdgeInsets? scrollPadding;
  ScrollPhysics? scrollPhysics;
  bool? selectAllOnFocus;
  TextSelectionControls? selectionControls;
  BoxHeightStyle? selectionHeightStyle;
  BoxWidthStyle? selectionWidthStyle;
  bool? showCursor;
  SmartDashesType? smartDashesType;
  SmartQuotesType? smartQuotesType;
  SpellCheckConfiguration? spellCheckConfiguration;
  MaterialStatesController? statesController;
  StrutStyle? strutStyle;
  TextStyle? style;
  bool? stylusHandwritingEnabled;
  TextAlign? textAlign;
  TextAlignVertical? textAlignVertical;
  TextCapitalization? textCapitalization;
  TextDirection? textDirection;
  TextInputAction? textInputAction;
  ToolbarOptions? toolbarOptions;
  UndoHistoryController? undoController;
}

TextField _buildGeneratedTextFieldTagWidget(_GeneratedTextFieldTagConfig config, List<Widget> children) {
  return TextField(
    autocorrect: config.autocorrect,
    autofillHints: config.autofillHints ?? const <String>[],
    autofocus: config.autofocus ?? false,
    buildCounter: config.buildCounter,
    canRequestFocus: config.canRequestFocus ?? true,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    contentInsertionConfiguration: config.contentInsertionConfiguration,
    contextMenuBuilder: config.contextMenuBuilder,
    controller: config.controller,
    cursorColor: config.cursorColor,
    cursorErrorColor: config.cursorErrorColor,
    cursorHeight: config.cursorHeight,
    cursorOpacityAnimates: config.cursorOpacityAnimates,
    cursorRadius: config.cursorRadius,
    cursorWidth: config.cursorWidth ?? 2.0,
    decoration: config.decoration ?? const InputDecoration(),
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    enableIMEPersonalizedLearning: config.enableIMEPersonalizedLearning ?? true,
    enableInteractiveSelection: config.enableInteractiveSelection,
    enableSuggestions: config.enableSuggestions ?? true,
    enabled: config.enabled,
    expands: config.expands ?? false,
    focusNode: config.focusNode,
    groupId: config.groupId ?? EditableText,
    hintLocales: config.hintLocales,
    ignorePointers: config.ignorePointers,
    inputFormatters: config.inputFormatters,
    key: config.key,
    keyboardAppearance: config.keyboardAppearance,
    keyboardType: config.keyboardType,
    magnifierConfiguration: config.magnifierConfiguration,
    maxLength: config.maxLength,
    maxLengthEnforcement: config.maxLengthEnforcement,
    maxLines: config.maxLines ?? 1,
    minLines: config.minLines,
    mouseCursor: config.mouseCursor,
    obscureText: config.obscureText ?? false,
    obscuringCharacter: config.obscuringCharacter ?? '',
    onAppPrivateCommand: config.onAppPrivateCommand,
    onChanged: config.onChanged,
    onEditingComplete: config.onEditingComplete,
    onSubmitted: config.onSubmitted,
    onTap: config.onTap,
    onTapAlwaysCalled: config.onTapAlwaysCalled ?? false,
    onTapOutside: config.onTapOutside,
    onTapUpOutside: config.onTapUpOutside,
    readOnly: config.readOnly ?? false,
    restorationId: config.restorationId,
    scribbleEnabled: config.scribbleEnabled ?? true,
    scrollController: config.scrollController,
    scrollPadding: config.scrollPadding ?? const EdgeInsets.all(20.0),
    scrollPhysics: config.scrollPhysics,
    selectAllOnFocus: config.selectAllOnFocus,
    selectionControls: config.selectionControls,
    selectionHeightStyle: config.selectionHeightStyle,
    selectionWidthStyle: config.selectionWidthStyle,
    showCursor: config.showCursor,
    smartDashesType: config.smartDashesType,
    smartQuotesType: config.smartQuotesType,
    spellCheckConfiguration: config.spellCheckConfiguration,
    statesController: config.statesController,
    strutStyle: config.strutStyle,
    style: config.style,
    stylusHandwritingEnabled: config.stylusHandwritingEnabled ?? EditableText.defaultStylusHandwritingEnabled,
    textAlign: config.textAlign ?? TextAlign.start,
    textAlignVertical: config.textAlignVertical,
    textCapitalization: config.textCapitalization ?? TextCapitalization.none,
    textDirection: config.textDirection,
    textInputAction: config.textInputAction,
    toolbarOptions: config.toolbarOptions,
    undoController: config.undoController,
  );
}


class GeneratedTextFormFieldTag extends WidgetTagBase with AsyncTag {
  GeneratedTextFormFieldTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTextFormFieldTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTextFormFieldTagWidget(config, children));
  }

  _GeneratedTextFormFieldTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTextFormFieldTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'autocorrect':
          config.autocorrect = toBool(value);
          break;
        case 'autofillHints':
          config.autofillHints = parseGeneratedIterableOfString(value);
          break;
        case 'autofocus':
          config.autofocus = toBool(value);
          break;
        case 'autovalidateMode':
          config.autovalidateMode = parseGeneratedAutovalidateMode(value);
          break;
        case 'buildCounter':
          config.buildCounter = (value is InputCounterWidgetBuilder ? value : resolveCallbackValue(evaluator, value) as InputCounterWidgetBuilder?);
          break;
        case 'canRequestFocus':
          config.canRequestFocus = toBool(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'contentInsertionConfiguration':
          config.contentInsertionConfiguration = parseGeneratedContentInsertionConfiguration(evaluator, value);
          break;
        case 'contextMenuBuilder':
          config.contextMenuBuilder = (value is EditableTextContextMenuBuilder ? value : resolveWidgetBuilder2Callback(evaluator, value) as EditableTextContextMenuBuilder?);
          break;
        case 'controller':
          config.controller = parseGeneratedTextEditingController(value);
          break;
        case 'cursorColor':
          config.cursorColor = parseGeneratedColor(value);
          break;
        case 'cursorErrorColor':
          config.cursorErrorColor = parseGeneratedColor(value);
          break;
        case 'cursorHeight':
          config.cursorHeight = toDouble(value);
          break;
        case 'cursorOpacityAnimates':
          config.cursorOpacityAnimates = toBool(value);
          break;
        case 'cursorRadius':
          config.cursorRadius = parseGeneratedRadius(value);
          break;
        case 'cursorWidth':
          config.cursorWidth = toDouble(value);
          break;
        case 'decoration':
          config.decoration = parseGeneratedInputDecoration(value);
          break;
        case 'dragStartBehavior':
          config.dragStartBehavior = parseGeneratedDragStartBehavior(value);
          break;
        case 'enableIMEPersonalizedLearning':
          config.enableIMEPersonalizedLearning = toBool(value);
          break;
        case 'enableInteractiveSelection':
          config.enableInteractiveSelection = toBool(value);
          break;
        case 'enableSuggestions':
          config.enableSuggestions = toBool(value);
          break;
        case 'enabled':
          config.enabled = toBool(value);
          break;
        case 'errorBuilder':
          config.errorBuilder = (value is FormFieldErrorBuilder ? value : resolveWidgetBuilder2Callback(evaluator, value) as FormFieldErrorBuilder?);
          break;
        case 'expands':
          config.expands = toBool(value);
          break;
        case 'focusNode':
          config.focusNode = parseGeneratedFocusNode(evaluator, value);
          break;
        case 'forceErrorText':
          config.forceErrorText = toStringValue(value);
          break;
        case 'groupId':
          config.groupId = parseGeneratedObject(evaluator, value);
          break;
        case 'hintLocales':
          config.hintLocales = parseGeneratedListOfLocale(value);
          break;
        case 'ignorePointers':
          config.ignorePointers = toBool(value);
          break;
        case 'initialValue':
          config.initialValue = toStringValue(value);
          break;
        case 'inputFormatters':
          config.inputFormatters = parseGeneratedListOfTextInputFormatter(evaluator, value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'keyboardAppearance':
          config.keyboardAppearance = parseGeneratedBrightness(value);
          break;
        case 'keyboardType':
          config.keyboardType = parseGeneratedTextInputType(value);
          break;
        case 'magnifierConfiguration':
          config.magnifierConfiguration = parseGeneratedTextMagnifierConfiguration(evaluator, value);
          break;
        case 'maxLength':
          config.maxLength = toInt(value);
          break;
        case 'maxLengthEnforcement':
          config.maxLengthEnforcement = parseGeneratedMaxLengthEnforcement(value);
          break;
        case 'maxLines':
          config.maxLines = toInt(value);
          break;
        case 'minLines':
          config.minLines = toInt(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'obscureText':
          config.obscureText = toBool(value);
          break;
        case 'obscuringCharacter':
          config.obscuringCharacter = toStringValue(value);
          break;
        case 'onAppPrivateCommand':
          config.onAppPrivateCommand = (value is AppPrivateCommandCallback ? value : resolveGenericActionCallback2(evaluator, value) as AppPrivateCommandCallback?);
          break;
        case 'onChanged':
          config.onChanged = (value is ValueChanged<String> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<String>?);
          break;
        case 'onEditingComplete':
          config.onEditingComplete = resolveActionCallback(evaluator, value);
          break;
        case 'onFieldSubmitted':
          config.onFieldSubmitted = (value is ValueChanged<String> ? value : resolveGenericValueChanged(evaluator, value) as ValueChanged<String>?);
          break;
        case 'onSaved':
          config.onSaved = (value is FormFieldSetter<String> ? value : resolveGenericValueChanged(evaluator, value) as FormFieldSetter<String>?);
          break;
        case 'onTap':
          config.onTap = resolveActionCallback(evaluator, value);
          break;
        case 'onTapAlwaysCalled':
          config.onTapAlwaysCalled = toBool(value);
          break;
        case 'onTapOutside':
          config.onTapOutside = resolveGenericValueChanged(evaluator, value);
          break;
        case 'onTapUpOutside':
          config.onTapUpOutside = resolveGenericValueChanged(evaluator, value);
          break;
        case 'readOnly':
          config.readOnly = toBool(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'scribbleEnabled':
          config.scribbleEnabled = toBool(value);
          break;
        case 'scrollController':
          config.scrollController = parseGeneratedScrollController(evaluator, value);
          break;
        case 'scrollPadding':
          config.scrollPadding = parseGeneratedEdgeInsets(value);
          break;
        case 'scrollPhysics':
          config.scrollPhysics = parseGeneratedScrollPhysics(value);
          break;
        case 'selectAllOnFocus':
          config.selectAllOnFocus = toBool(value);
          break;
        case 'selectionControls':
          config.selectionControls = parseGeneratedTextSelectionControls(value);
          break;
        case 'selectionHeightStyle':
          config.selectionHeightStyle = parseGeneratedBoxHeightStyle(value);
          break;
        case 'selectionWidthStyle':
          config.selectionWidthStyle = parseGeneratedBoxWidthStyle(value);
          break;
        case 'showCursor':
          config.showCursor = toBool(value);
          break;
        case 'smartDashesType':
          config.smartDashesType = parseGeneratedSmartDashesType(value);
          break;
        case 'smartQuotesType':
          config.smartQuotesType = parseGeneratedSmartQuotesType(value);
          break;
        case 'spellCheckConfiguration':
          config.spellCheckConfiguration = parseGeneratedSpellCheckConfiguration(evaluator, value);
          break;
        case 'statesController':
          config.statesController = parseMaterialStatesController(value);
          break;
        case 'strutStyle':
          config.strutStyle = parseGeneratedStrutStyle(value);
          break;
        case 'style':
          config.style = parseGeneratedTextStyle(value);
          break;
        case 'stylusHandwritingEnabled':
          config.stylusHandwritingEnabled = toBool(value);
          break;
        case 'textAlign':
          config.textAlign = parseGeneratedTextAlign(value);
          break;
        case 'textAlignVertical':
          config.textAlignVertical = parseGeneratedTextAlignVertical(value);
          break;
        case 'textCapitalization':
          config.textCapitalization = parseGeneratedTextCapitalization(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'textInputAction':
          config.textInputAction = parseGeneratedTextInputAction(value);
          break;
        case 'toolbarOptions':
          config.toolbarOptions = parseGeneratedToolbarOptions(value);
          break;
        case 'undoController':
          config.undoController = parseGeneratedUndoHistoryController(value);
          break;
        case 'validator':
          config.validator = (value is FormFieldValidator<String> ? value : resolveGenericCallback1(evaluator, value) as FormFieldValidator<String>?);
          break;
        default:
          handleUnknownArg('text_form_field', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedTextFormFieldTagConfig {
  bool? autocorrect;
  Iterable<String>? autofillHints;
  bool? autofocus;
  AutovalidateMode? autovalidateMode;
  InputCounterWidgetBuilder? buildCounter;
  bool? canRequestFocus;
  Clip? clipBehavior;
  ContentInsertionConfiguration? contentInsertionConfiguration;
  EditableTextContextMenuBuilder? contextMenuBuilder;
  TextEditingController? controller;
  Color? cursorColor;
  Color? cursorErrorColor;
  double? cursorHeight;
  bool? cursorOpacityAnimates;
  Radius? cursorRadius;
  double? cursorWidth;
  InputDecoration? decoration;
  DragStartBehavior? dragStartBehavior;
  bool? enableIMEPersonalizedLearning;
  bool? enableInteractiveSelection;
  bool? enableSuggestions;
  bool? enabled;
  FormFieldErrorBuilder? errorBuilder;
  bool? expands;
  FocusNode? focusNode;
  String? forceErrorText;
  Object? groupId;
  List<Locale>? hintLocales;
  bool? ignorePointers;
  String? initialValue;
  List<TextInputFormatter>? inputFormatters;
  Key? key;
  Brightness? keyboardAppearance;
  TextInputType? keyboardType;
  TextMagnifierConfiguration? magnifierConfiguration;
  int? maxLength;
  MaxLengthEnforcement? maxLengthEnforcement;
  int? maxLines;
  int? minLines;
  MouseCursor? mouseCursor;
  bool? obscureText;
  String? obscuringCharacter;
  AppPrivateCommandCallback? onAppPrivateCommand;
  ValueChanged<String>? onChanged;
  VoidCallback? onEditingComplete;
  ValueChanged<String>? onFieldSubmitted;
  FormFieldSetter<String>? onSaved;
  GestureTapCallback? onTap;
  bool? onTapAlwaysCalled;
  TapRegionCallback? onTapOutside;
  TapRegionUpCallback? onTapUpOutside;
  bool? readOnly;
  String? restorationId;
  bool? scribbleEnabled;
  ScrollController? scrollController;
  EdgeInsets? scrollPadding;
  ScrollPhysics? scrollPhysics;
  bool? selectAllOnFocus;
  TextSelectionControls? selectionControls;
  BoxHeightStyle? selectionHeightStyle;
  BoxWidthStyle? selectionWidthStyle;
  bool? showCursor;
  SmartDashesType? smartDashesType;
  SmartQuotesType? smartQuotesType;
  SpellCheckConfiguration? spellCheckConfiguration;
  MaterialStatesController? statesController;
  StrutStyle? strutStyle;
  TextStyle? style;
  bool? stylusHandwritingEnabled;
  TextAlign? textAlign;
  TextAlignVertical? textAlignVertical;
  TextCapitalization? textCapitalization;
  TextDirection? textDirection;
  TextInputAction? textInputAction;
  ToolbarOptions? toolbarOptions;
  UndoHistoryController? undoController;
  FormFieldValidator<String>? validator;
}

TextFormField _buildGeneratedTextFormFieldTagWidget(_GeneratedTextFormFieldTagConfig config, List<Widget> children) {
  return TextFormField(
    autocorrect: config.autocorrect ?? true,
    autofillHints: config.autofillHints,
    autofocus: config.autofocus ?? false,
    autovalidateMode: config.autovalidateMode,
    buildCounter: config.buildCounter,
    canRequestFocus: config.canRequestFocus ?? true,
    clipBehavior: config.clipBehavior ?? Clip.hardEdge,
    contentInsertionConfiguration: config.contentInsertionConfiguration,
    contextMenuBuilder: config.contextMenuBuilder,
    controller: config.controller,
    cursorColor: config.cursorColor,
    cursorErrorColor: config.cursorErrorColor,
    cursorHeight: config.cursorHeight,
    cursorOpacityAnimates: config.cursorOpacityAnimates,
    cursorRadius: config.cursorRadius,
    cursorWidth: config.cursorWidth ?? 2.0,
    decoration: config.decoration ?? const InputDecoration(),
    dragStartBehavior: config.dragStartBehavior ?? DragStartBehavior.start,
    enableIMEPersonalizedLearning: config.enableIMEPersonalizedLearning ?? true,
    enableInteractiveSelection: config.enableInteractiveSelection,
    enableSuggestions: config.enableSuggestions ?? true,
    enabled: config.enabled,
    errorBuilder: config.errorBuilder,
    expands: config.expands ?? false,
    focusNode: config.focusNode,
    forceErrorText: config.forceErrorText,
    groupId: config.groupId ?? EditableText,
    hintLocales: config.hintLocales,
    ignorePointers: config.ignorePointers,
    initialValue: config.initialValue,
    inputFormatters: config.inputFormatters,
    key: config.key,
    keyboardAppearance: config.keyboardAppearance,
    keyboardType: config.keyboardType,
    magnifierConfiguration: config.magnifierConfiguration,
    maxLength: config.maxLength,
    maxLengthEnforcement: config.maxLengthEnforcement,
    maxLines: config.maxLines ?? 1,
    minLines: config.minLines,
    mouseCursor: config.mouseCursor,
    obscureText: config.obscureText ?? false,
    obscuringCharacter: config.obscuringCharacter ?? '',
    onAppPrivateCommand: config.onAppPrivateCommand,
    onChanged: config.onChanged,
    onEditingComplete: config.onEditingComplete,
    onFieldSubmitted: config.onFieldSubmitted,
    onSaved: config.onSaved,
    onTap: config.onTap,
    onTapAlwaysCalled: config.onTapAlwaysCalled ?? false,
    onTapOutside: config.onTapOutside,
    onTapUpOutside: config.onTapUpOutside,
    readOnly: config.readOnly ?? false,
    restorationId: config.restorationId,
    scribbleEnabled: config.scribbleEnabled ?? true,
    scrollController: config.scrollController,
    scrollPadding: config.scrollPadding ?? const EdgeInsets.all(20.0),
    scrollPhysics: config.scrollPhysics,
    selectAllOnFocus: config.selectAllOnFocus,
    selectionControls: config.selectionControls,
    selectionHeightStyle: config.selectionHeightStyle,
    selectionWidthStyle: config.selectionWidthStyle,
    showCursor: config.showCursor,
    smartDashesType: config.smartDashesType,
    smartQuotesType: config.smartQuotesType,
    spellCheckConfiguration: config.spellCheckConfiguration,
    statesController: config.statesController,
    strutStyle: config.strutStyle,
    style: config.style,
    stylusHandwritingEnabled: config.stylusHandwritingEnabled ?? EditableText.defaultStylusHandwritingEnabled,
    textAlign: config.textAlign ?? TextAlign.start,
    textAlignVertical: config.textAlignVertical,
    textCapitalization: config.textCapitalization ?? TextCapitalization.none,
    textDirection: config.textDirection,
    textInputAction: config.textInputAction,
    toolbarOptions: config.toolbarOptions,
    undoController: config.undoController,
    validator: config.validator,
  );
}


class GeneratedTimePickerDialogTag extends WidgetTagBase with AsyncTag {
  GeneratedTimePickerDialogTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTimePickerDialogTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    const children = <Widget>[];
    buffer.write(_buildGeneratedTimePickerDialogTagWidget(config, children));
  }

  _GeneratedTimePickerDialogTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTimePickerDialogTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'cancelText':
          config.cancelText = toStringValue(value);
          break;
        case 'confirmText':
          config.confirmText = toStringValue(value);
          break;
        case 'emptyInitialInput':
          config.emptyInitialInput = toBool(value);
          break;
        case 'errorInvalidText':
          config.errorInvalidText = toStringValue(value);
          break;
        case 'helpText':
          config.helpText = toStringValue(value);
          break;
        case 'hourLabelText':
          config.hourLabelText = toStringValue(value);
          break;
        case 'initialEntryMode':
          config.initialEntryMode = parseGeneratedTimePickerEntryMode(value);
          break;
        case 'initialTime':
          config.initialTime = parseGeneratedTimeOfDay(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'minuteLabelText':
          config.minuteLabelText = toStringValue(value);
          break;
        case 'onEntryModeChanged':
          config.onEntryModeChanged = resolveGenericValueChanged(evaluator, value);
          break;
        case 'orientation':
          config.orientation = parseGeneratedOrientation(value);
          break;
        case 'restorationId':
          config.restorationId = toStringValue(value);
          break;
        case 'switchToInputEntryModeIcon':
          config.switchToInputEntryModeIcon = parseGeneratedIcon(evaluator, value);
          break;
        case 'switchToTimerEntryModeIcon':
          config.switchToTimerEntryModeIcon = parseGeneratedIcon(evaluator, value);
          break;
        default:
          handleUnknownArg('time_picker_dialog', name);
          break;
      }
    }
    if (config.initialTime == null) {
      throw Exception('time_picker_dialog tag requires "initialTime"');
    }
    return config;
  }
}

class _GeneratedTimePickerDialogTagConfig {
  String? cancelText;
  String? confirmText;
  bool? emptyInitialInput;
  String? errorInvalidText;
  String? helpText;
  String? hourLabelText;
  TimePickerEntryMode? initialEntryMode;
  TimeOfDay? initialTime;
  Key? key;
  String? minuteLabelText;
  EntryModeChangeCallback? onEntryModeChanged;
  Orientation? orientation;
  String? restorationId;
  Icon? switchToInputEntryModeIcon;
  Icon? switchToTimerEntryModeIcon;
}

TimePickerDialog _buildGeneratedTimePickerDialogTagWidget(_GeneratedTimePickerDialogTagConfig config, List<Widget> children) {
  return TimePickerDialog(
    cancelText: config.cancelText,
    confirmText: config.confirmText,
    emptyInitialInput: config.emptyInitialInput ?? false,
    errorInvalidText: config.errorInvalidText,
    helpText: config.helpText,
    hourLabelText: config.hourLabelText,
    initialEntryMode: config.initialEntryMode ?? TimePickerEntryMode.dial,
    initialTime: config.initialTime!,
    key: config.key,
    minuteLabelText: config.minuteLabelText,
    onEntryModeChanged: config.onEntryModeChanged,
    orientation: config.orientation,
    restorationId: config.restorationId,
    switchToInputEntryModeIcon: config.switchToInputEntryModeIcon,
    switchToTimerEntryModeIcon: config.switchToTimerEntryModeIcon,
  );
}


class GeneratedToggleButtonsTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedToggleButtonsTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedToggleButtonsTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedToggleButtonsTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('toggle_buttons').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endtoggle_buttons').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'toggle_buttons',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedToggleButtonsTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedToggleButtonsTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'borderColor':
          config.borderColor = parseGeneratedColor(value);
          break;
        case 'borderRadius':
          config.borderRadius = parseGeneratedBorderRadius(value);
          break;
        case 'borderWidth':
          config.borderWidth = toDouble(value);
          break;
        case 'color':
          config.color = parseGeneratedColor(value);
          break;
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'direction':
          config.direction = parseGeneratedAxis(value);
          break;
        case 'disabledBorderColor':
          config.disabledBorderColor = parseGeneratedColor(value);
          break;
        case 'disabledColor':
          config.disabledColor = parseGeneratedColor(value);
          break;
        case 'fillColor':
          config.fillColor = parseGeneratedColor(value);
          break;
        case 'focusColor':
          config.focusColor = parseGeneratedColor(value);
          break;
        case 'focusNodes':
          config.focusNodes = parseGeneratedListOfFocusNode(evaluator, value);
          break;
        case 'highlightColor':
          config.highlightColor = parseGeneratedColor(value);
          break;
        case 'hoverColor':
          config.hoverColor = parseGeneratedColor(value);
          break;
        case 'isSelected':
          config.isSelected = parseGeneratedListOfBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onPressed':
          config.onPressed = resolveIntActionCallback(evaluator, value);
          break;
        case 'renderBorder':
          config.renderBorder = toBool(value);
          break;
        case 'selectedBorderColor':
          config.selectedBorderColor = parseGeneratedColor(value);
          break;
        case 'selectedColor':
          config.selectedColor = parseGeneratedColor(value);
          break;
        case 'splashColor':
          config.splashColor = parseGeneratedColor(value);
          break;
        case 'tapTargetSize':
          config.tapTargetSize = parseGeneratedMaterialTapTargetSize(value);
          break;
        case 'textStyle':
          config.textStyle = parseGeneratedTextStyle(value);
          break;
        case 'verticalDirection':
          config.verticalDirection = parseGeneratedVerticalDirection(value);
          break;
        default:
          handleUnknownArg('toggle_buttons', name);
          break;
      }
    }
    if (config.isSelected == null) {
      throw Exception('toggle_buttons tag requires "isSelected"');
    }
    return config;
  }
}

class _GeneratedToggleButtonsTagConfig {
  Color? borderColor;
  BorderRadius? borderRadius;
  double? borderWidth;
  Color? color;
  BoxConstraints? constraints;
  Axis? direction;
  Color? disabledBorderColor;
  Color? disabledColor;
  Color? fillColor;
  Color? focusColor;
  List<FocusNode>? focusNodes;
  Color? highlightColor;
  Color? hoverColor;
  List<bool>? isSelected;
  Key? key;
  MouseCursor? mouseCursor;
  void Function(int)? onPressed;
  bool? renderBorder;
  Color? selectedBorderColor;
  Color? selectedColor;
  Color? splashColor;
  MaterialTapTargetSize? tapTargetSize;
  TextStyle? textStyle;
  VerticalDirection? verticalDirection;
}

ToggleButtons _buildGeneratedToggleButtonsTagWidget(_GeneratedToggleButtonsTagConfig config, List<Widget> children) {
  return ToggleButtons(
    borderColor: config.borderColor,
    borderRadius: config.borderRadius,
    borderWidth: config.borderWidth,
    color: config.color,
    constraints: config.constraints,
    direction: config.direction ?? Axis.horizontal,
    disabledBorderColor: config.disabledBorderColor,
    disabledColor: config.disabledColor,
    fillColor: config.fillColor,
    focusColor: config.focusColor,
    focusNodes: config.focusNodes,
    highlightColor: config.highlightColor,
    hoverColor: config.hoverColor,
    isSelected: config.isSelected!,
    key: config.key,
    mouseCursor: config.mouseCursor,
    onPressed: config.onPressed,
    renderBorder: config.renderBorder ?? true,
    selectedBorderColor: config.selectedBorderColor,
    selectedColor: config.selectedColor,
    splashColor: config.splashColor,
    tapTargetSize: config.tapTargetSize,
    textStyle: config.textStyle,
    verticalDirection: config.verticalDirection ?? VerticalDirection.down,
    children: children,
  );
}


class GeneratedTooltipTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedTooltipTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedTooltipTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedTooltipTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('tooltip').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endtooltip').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'tooltip',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedTooltipTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTooltipTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'constraints':
          config.constraints = parseGeneratedBoxConstraints(value);
          break;
        case 'decoration':
          config.decoration = parseGeneratedDecoration(evaluator, value);
          break;
        case 'enableFeedback':
          config.enableFeedback = toBool(value);
          break;
        case 'enableTapToDismiss':
          config.enableTapToDismiss = toBool(value);
          break;
        case 'excludeFromSemantics':
          config.excludeFromSemantics = toBool(value);
          break;
        case 'exitDuration':
          config.exitDuration = parseGeneratedDuration(value);
          break;
        case 'height':
          config.height = toDouble(value);
          break;
        case 'ignorePointer':
          config.ignorePointer = toBool(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'margin':
          config.margin = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'message':
          config.message = toStringValue(value);
          break;
        case 'mouseCursor':
          config.mouseCursor = parseGeneratedMouseCursor(value);
          break;
        case 'onTriggered':
          config.onTriggered = resolveActionCallback(evaluator, value);
          break;
        case 'padding':
          config.padding = parseGeneratedEdgeInsetsGeometry(value);
          break;
        case 'preferBelow':
          config.preferBelow = toBool(value);
          break;
        case 'richMessage':
          config.richMessage = parseGeneratedInlineSpan(evaluator, value);
          break;
        case 'showDuration':
          config.showDuration = parseGeneratedDuration(value);
          break;
        case 'textAlign':
          config.textAlign = parseGeneratedTextAlign(value);
          break;
        case 'textStyle':
          config.textStyle = parseGeneratedTextStyle(value);
          break;
        case 'triggerMode':
          config.triggerMode = parseGeneratedTooltipTriggerMode(value);
          break;
        case 'verticalOffset':
          config.verticalOffset = toDouble(value);
          break;
        case 'waitDuration':
          config.waitDuration = parseGeneratedDuration(value);
          break;
        default:
          handleUnknownArg('tooltip', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedTooltipTagConfig {
  BoxConstraints? constraints;
  Decoration? decoration;
  bool? enableFeedback;
  bool? enableTapToDismiss;
  bool? excludeFromSemantics;
  Duration? exitDuration;
  double? height;
  bool? ignorePointer;
  Key? key;
  EdgeInsetsGeometry? margin;
  String? message;
  MouseCursor? mouseCursor;
  TooltipTriggeredCallback? onTriggered;
  EdgeInsetsGeometry? padding;
  bool? preferBelow;
  InlineSpan? richMessage;
  Duration? showDuration;
  TextAlign? textAlign;
  TextStyle? textStyle;
  TooltipTriggerMode? triggerMode;
  double? verticalOffset;
  Duration? waitDuration;
}

Tooltip _buildGeneratedTooltipTagWidget(_GeneratedTooltipTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Tooltip(
    constraints: config.constraints,
    decoration: config.decoration,
    enableFeedback: config.enableFeedback,
    enableTapToDismiss: config.enableTapToDismiss ?? true,
    excludeFromSemantics: config.excludeFromSemantics,
    exitDuration: config.exitDuration,
    height: config.height,
    ignorePointer: config.ignorePointer,
    key: config.key,
    margin: config.margin,
    message: config.message,
    mouseCursor: config.mouseCursor,
    onTriggered: config.onTriggered,
    padding: config.padding,
    preferBelow: config.preferBelow,
    richMessage: config.richMessage,
    showDuration: config.showDuration,
    textAlign: config.textAlign,
    textStyle: config.textStyle,
    triggerMode: config.triggerMode,
    verticalOffset: config.verticalOffset,
    waitDuration: config.waitDuration,
    child: child,
  );
}


class GeneratedTransformTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedTransformTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedTransformTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedTransformTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('transform').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endtransform').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'transform',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedTransformTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedTransformTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'filterQuality':
          config.filterQuality = parseGeneratedFilterQuality(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'origin':
          config.origin = parseGeneratedOffset(value);
          break;
        case 'transform':
          config.transform = parseGeneratedMatrix4(value);
          break;
        case 'transformHitTests':
          config.transformHitTests = toBool(value);
          break;
        default:
          handleUnknownArg('transform', name);
          break;
      }
    }
    if (config.transform == null) {
      throw Exception('transform tag requires "transform"');
    }
    return config;
  }
}

class _GeneratedTransformTagConfig {
  AlignmentGeometry? alignment;
  FilterQuality? filterQuality;
  Key? key;
  Offset? origin;
  Matrix4? transform;
  bool? transformHitTests;
}

Transform _buildGeneratedTransformTagWidget(_GeneratedTransformTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return Transform(
    alignment: config.alignment,
    filterQuality: config.filterQuality,
    key: config.key,
    origin: config.origin,
    transform: config.transform!,
    transformHitTests: config.transformHitTests ?? true,
    child: child,
  );
}


class GeneratedUnconstrainedBoxTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedUnconstrainedBoxTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedUnconstrainedBoxTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedUnconstrainedBoxTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('unconstrained_box').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endunconstrained_box').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'unconstrained_box',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedUnconstrainedBoxTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedUnconstrainedBoxTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedAlignmentGeometry(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'constrainedAxis':
          config.constrainedAxis = parseGeneratedAxis(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        default:
          handleUnknownArg('unconstrained_box', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedUnconstrainedBoxTagConfig {
  AlignmentGeometry? alignment;
  Clip? clipBehavior;
  Axis? constrainedAxis;
  Key? key;
  TextDirection? textDirection;
}

UnconstrainedBox _buildGeneratedUnconstrainedBoxTagWidget(_GeneratedUnconstrainedBoxTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : null;
  return UnconstrainedBox(
    alignment: config.alignment ?? Alignment.center,
    clipBehavior: config.clipBehavior ?? Clip.none,
    constrainedAxis: config.constrainedAxis,
    key: config.key,
    textDirection: config.textDirection,
    child: child,
  );
}


class GeneratedVisibilityTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedVisibilityTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedVisibilityTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedVisibilityTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('visibility').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endvisibility').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'visibility',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedVisibilityTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedVisibilityTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'maintainAnimation':
          config.maintainAnimation = toBool(value);
          break;
        case 'maintainFocusability':
          config.maintainFocusability = toBool(value);
          break;
        case 'maintainInteractivity':
          config.maintainInteractivity = toBool(value);
          break;
        case 'maintainSemantics':
          config.maintainSemantics = toBool(value);
          break;
        case 'maintainSize':
          config.maintainSize = toBool(value);
          break;
        case 'maintainState':
          config.maintainState = toBool(value);
          break;
        case 'replacement':
          config.replacement = resolveWidget(value);
          break;
        case 'visible':
          config.visible = toBool(value);
          break;
        default:
          handleUnknownArg('visibility', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedVisibilityTagConfig {
  Key? key;
  bool? maintainAnimation;
  bool? maintainFocusability;
  bool? maintainInteractivity;
  bool? maintainSemantics;
  bool? maintainSize;
  bool? maintainState;
  Widget? replacement;
  bool? visible;
}

Visibility _buildGeneratedVisibilityTagWidget(_GeneratedVisibilityTagConfig config, List<Widget> children) {
  final child = children.isNotEmpty
      ? wrapChildren(children)
      : const SizedBox.shrink();
  return Visibility(
    key: config.key,
    maintainAnimation: config.maintainAnimation ?? false,
    maintainFocusability: config.maintainFocusability ?? false,
    maintainInteractivity: config.maintainInteractivity ?? false,
    maintainSemantics: config.maintainSemantics ?? false,
    maintainSize: config.maintainSize ?? false,
    maintainState: config.maintainState ?? false,
    replacement: config.replacement ?? const SizedBox.shrink(),
    visible: config.visible ?? true,
    child: child,
  );
}


class GeneratedWrapTag extends WidgetTagBase with CustomTagParser, AsyncTag {
  GeneratedWrapTag(super.content, super.filters);

  @override
  dynamic evaluateWithContext(Evaluator evaluator, Buffer buffer) {
    final config = _parseConfig(evaluator);
    final children = captureChildrenSync(evaluator);
    buffer.write(_buildGeneratedWrapTagWidget(config, children));
  }

  @override
  Future<dynamic> evaluateWithContextAsync(Evaluator evaluator, Buffer buffer) async {
    final config = _parseConfig(evaluator);
    final children = await captureChildrenAsync(evaluator);
    buffer.write(_buildGeneratedWrapTagWidget(config, children));
  }

  @override
  Parser parser() {
    final start = tagStart() &
        string('wrap').trim() &
        ref0(tagContent).optional().trim() &
        ref0(filter).star().trim() &
        tagEnd();
    final endTag = tagStart() & string('endwrap').trim() & tagEnd();
    return (start & ref0(element).starLazy(endTag) & endTag).map((values) {
      final content = collapseTextNodes(values[2] as List<ASTNode>? ?? []);
      final filters = (values[3] as List).cast<Filter>();
      final nonFilterContent =
          content.where((node) => node is! Filter).toList();
      return Tag(
        'wrap',
        nonFilterContent,
        filters: filters,
        body: values[5].cast<ASTNode>(),
      );
    });
  }

  _GeneratedWrapTagConfig _parseConfig(Evaluator evaluator) {
    final config = _GeneratedWrapTagConfig();
    for (final arg in namedArgs) {
      final name = arg.identifier.name;
      final value = evaluator.evaluate(arg.value);
      switch (name) {
        case 'alignment':
          config.alignment = parseGeneratedWrapAlignment(value);
          break;
        case 'clipBehavior':
          config.clipBehavior = parseGeneratedClip(value);
          break;
        case 'crossAxisAlignment':
          config.crossAxisAlignment = parseGeneratedWrapCrossAlignment(value);
          break;
        case 'direction':
          config.direction = parseGeneratedAxis(value);
          break;
        case 'key':
          config.key = parseGeneratedKey(evaluator, value);
          break;
        case 'runAlignment':
          config.runAlignment = parseGeneratedWrapAlignment(value);
          break;
        case 'runSpacing':
          config.runSpacing = toDouble(value);
          break;
        case 'spacing':
          config.spacing = toDouble(value);
          break;
        case 'textDirection':
          config.textDirection = parseGeneratedTextDirection(value);
          break;
        case 'verticalDirection':
          config.verticalDirection = parseGeneratedVerticalDirection(value);
          break;
        default:
          handleUnknownArg('wrap', name);
          break;
      }
    }
    return config;
  }
}

class _GeneratedWrapTagConfig {
  WrapAlignment? alignment;
  Clip? clipBehavior;
  WrapCrossAlignment? crossAxisAlignment;
  Axis? direction;
  Key? key;
  WrapAlignment? runAlignment;
  double? runSpacing;
  double? spacing;
  TextDirection? textDirection;
  VerticalDirection? verticalDirection;
}

Wrap _buildGeneratedWrapTagWidget(_GeneratedWrapTagConfig config, List<Widget> children) {
  return Wrap(
    alignment: config.alignment ?? WrapAlignment.start,
    clipBehavior: config.clipBehavior ?? Clip.none,
    crossAxisAlignment: config.crossAxisAlignment ?? WrapCrossAlignment.start,
    direction: config.direction ?? Axis.horizontal,
    key: config.key,
    runAlignment: config.runAlignment ?? WrapAlignment.start,
    runSpacing: config.runSpacing ?? 0.0,
    spacing: config.spacing ?? 0.0,
    textDirection: config.textDirection,
    verticalDirection: config.verticalDirection ?? VerticalDirection.down,
    children: children,
  );
}


